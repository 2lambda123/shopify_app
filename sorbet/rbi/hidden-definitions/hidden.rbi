# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class AbstractController::ActionNotFound
end

class AbstractController::ActionNotFound
end

module AbstractController::AssetPaths
end

module AbstractController::AssetPaths
  extend ::ActiveSupport::Concern
end

class AbstractController::Base
  include ::ActiveSupport::Configurable
  def action_methods(); end

  def action_name(); end

  def action_name=(action_name); end

  def available_action?(action_name); end

  def controller_path(); end

  def formats(); end

  def formats=(formats); end

  def performed?(); end

  def process(action, *args); end

  def response_body(); end

  def response_body=(response_body); end

  def send_action(*_); end
end

class AbstractController::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.abstract(); end

  def self.abstract!(); end

  def self.abstract?(); end

  def self.action_methods(); end

  def self.clear_action_methods!(); end

  def self.controller_path(); end

  def self.inherited(klass); end

  def self.internal_methods(); end

  def self.method_added(name); end

  def self.supports_path?(); end
end

module AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  def view_cache_dependencies(); end
end

module AbstractController::Caching::ClassMethods
  def view_cache_dependency(&dependency); end
end

module AbstractController::Caching::ClassMethods
end

module AbstractController::Caching::ConfigMethods
  def cache_store(); end

  def cache_store=(store); end
end

module AbstractController::Caching::ConfigMethods
end

module AbstractController::Caching::Fragments
  def combined_fragment_cache_key(key); end

  def expire_fragment(key, options=T.unsafe(nil)); end

  def fragment_exist?(key, options=T.unsafe(nil)); end

  def instrument_fragment_cache(name, key); end

  def read_fragment(key, options=T.unsafe(nil)); end

  def write_fragment(key, content, options=T.unsafe(nil)); end
end

module AbstractController::Caching::Fragments::ClassMethods
  def fragment_cache_key(value=T.unsafe(nil), &key); end
end

module AbstractController::Caching::Fragments::ClassMethods
end

module AbstractController::Caching::Fragments
  extend ::ActiveSupport::Concern
end

module AbstractController::Caching
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module AbstractController::Callbacks
  def process_action(*args); end
end

module AbstractController::Callbacks::ClassMethods
  def _insert_callbacks(callbacks, block=T.unsafe(nil)); end

  def _normalize_callback_option(options, from, to); end

  def _normalize_callback_options(options); end
end

module AbstractController::Callbacks
  extend ::ActiveSupport::Concern
end

module AbstractController::Collector
  def atom(*args, &block); end

  def bmp(*args, &block); end

  def css(*args, &block); end

  def csv(*args, &block); end

  def gif(*args, &block); end

  def gzip(*args, &block); end

  def html(*args, &block); end

  def ics(*args, &block); end

  def jpeg(*args, &block); end

  def js(*args, &block); end

  def json(*args, &block); end

  def m4a(*args, &block); end

  def mp3(*args, &block); end

  def mp4(*args, &block); end

  def mpeg(*args, &block); end

  def multipart_form(*args, &block); end

  def ogg(*args, &block); end

  def otf(*args, &block); end

  def pdf(*args, &block); end

  def png(*args, &block); end

  def rss(*args, &block); end

  def svg(*args, &block); end

  def text(*args, &block); end

  def tiff(*args, &block); end

  def ttf(*args, &block); end

  def url_encoded_form(*args, &block); end

  def vcf(*args, &block); end

  def vtt(*args, &block); end

  def webm(*args, &block); end

  def woff(*args, &block); end

  def woff2(*args, &block); end

  def xml(*args, &block); end

  def yaml(*args, &block); end

  def zip(*args, &block); end
end

module AbstractController::Collector
  def self.generate_method_for_mime(mime); end
end

class AbstractController::DoubleRenderError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class AbstractController::DoubleRenderError
end

class AbstractController::Error
end

class AbstractController::Error
end

module AbstractController::Helpers
end

module AbstractController::Helpers::ClassMethods
  def clear_helpers(); end

  def helper(*args, &block); end

  def helper_method(*meths); end

  def inherited(klass); end

  def modules_for_helpers(args); end
end

module AbstractController::Helpers::ClassMethods
end

class AbstractController::Helpers::MissingHelperError
  def initialize(error, path); end
end

class AbstractController::Helpers::MissingHelperError
end

module AbstractController::Helpers
  extend ::ActiveSupport::Concern
end

module AbstractController::Logger
end

module AbstractController::Logger
  extend ::ActiveSupport::Concern
end

module AbstractController::Railties
end

module AbstractController::Railties::RoutesHelpers
end

module AbstractController::Railties::RoutesHelpers
  def self.with(routes, include_path_helpers=T.unsafe(nil)); end
end

module AbstractController::Railties
end

module AbstractController::Rendering
  def render(*args, &block); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*args, &block); end

  def rendered_format(); end

  def view_assigns(); end
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module AbstractController::Rendering
  extend ::ActiveSupport::Concern
end

module AbstractController::Translation
  def l(*args); end

  def localize(*args); end

  def t(key, options=T.unsafe(nil)); end

  def translate(key, options=T.unsafe(nil)); end
end

module AbstractController::Translation
end

module AbstractController::UrlFor
  def _routes(); end
end

module AbstractController::UrlFor::ClassMethods
  def _routes(); end

  def action_methods(); end
end

module AbstractController::UrlFor::ClassMethods
end

module AbstractController::UrlFor
  extend ::ActiveSupport::Concern
end

module AbstractController
  extend ::ActiveSupport::Autoload
end

module ActionCable
  INTERNAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel
end

class ActionCable::Channel::Base
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Channel::Callbacks
  include ::ActionCable::Channel::PeriodicTimers
  include ::ActionCable::Channel::Streams
  include ::ActionCable::Channel::Naming
  include ::ActionCable::Channel::Broadcasting
  include ::ActiveSupport::Rescuable
  def __callbacks(); end

  def __callbacks?(); end

  def _run_subscribe_callbacks(&block); end

  def _run_unsubscribe_callbacks(&block); end

  def _subscribe_callbacks(); end

  def _unsubscribe_callbacks(); end

  def connection(); end

  def identifier(); end

  def initialize(connection, identifier, params=T.unsafe(nil)); end

  def logger(*args, &block); end

  def params(); end

  def perform_action(data); end

  def periodic_timers=(val); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def subscribe_to_channel(); end

  def unsubscribe_from_channel(); end
end

class ActionCable::Channel::Base
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Channel::Callbacks::ClassMethods
  extend ::ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::ActionCable::Channel::Naming::ClassMethods
  extend ::ActionCable::Channel::Broadcasting::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._subscribe_callbacks(); end

  def self._subscribe_callbacks=(value); end

  def self._unsubscribe_callbacks(); end

  def self._unsubscribe_callbacks=(value); end

  def self.action_methods(); end

  def self.periodic_timers(); end

  def self.periodic_timers=(val); end

  def self.periodic_timers?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end
end

module ActionCable::Channel::Broadcasting
  def broadcast_to(*args, &block); end

  def broadcasting_for(*args, &block); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
  def broadcast_to(model, message); end

  def broadcasting_for(model); end

  def serialize_broadcasting(object); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
end

module ActionCable::Channel::Broadcasting
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::Callbacks
end

module ActionCable::Channel::Callbacks::ClassMethods
  def after_subscribe(*methods, &block); end

  def after_unsubscribe(*methods, &block); end

  def before_subscribe(*methods, &block); end

  def before_unsubscribe(*methods, &block); end

  def on_subscribe(*methods, &block); end

  def on_unsubscribe(*methods, &block); end
end

module ActionCable::Channel::Callbacks::ClassMethods
end

module ActionCable::Channel::Callbacks
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::Naming
  def channel_name(*args, &block); end
end

module ActionCable::Channel::Naming::ClassMethods
  def channel_name(); end
end

module ActionCable::Channel::Naming::ClassMethods
end

module ActionCable::Channel::Naming
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::PeriodicTimers
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
  def periodically(callback_or_method_name=T.unsafe(nil), every:, &block); end
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
end

module ActionCable::Channel::PeriodicTimers
  extend ::ActiveSupport::Concern
end

module ActionCable::Channel::Streams
  def pubsub(*args, &block); end

  def stop_all_streams(); end

  def stream_for(model, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end

  def stream_from(broadcasting, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end
end

module ActionCable::Channel::Streams
  extend ::ActiveSupport::Concern
end

class ActionCable::Channel::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  def _channel_class(); end

  def _channel_class=(val); end

  def _channel_class?(); end

  def connection(); end

  def subscription(); end
end

module ActionCable::Channel::TestCase::Behavior
  include ::ActionCable::TestHelper
  def assert_broadcast_on(stream_or_object, *args); end

  def assert_broadcasts(stream_or_object, *args); end

  def assert_has_stream(stream); end

  def assert_has_stream_for(object); end

  def assert_no_streams(); end

  def perform(action, data=T.unsafe(nil)); end

  def stub_connection(identifiers=T.unsafe(nil)); end

  def subscribe(params=T.unsafe(nil)); end

  def transmissions(); end

  def unsubscribe(); end
  CHANNEL_IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
  def channel_class(); end

  def determine_default_channel(name); end

  def tests(channel); end
end

module ActionCable::Channel::TestCase::Behavior::ClassMethods
end

module ActionCable::Channel::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionCable::Channel::TestCase
  extend ::ActionCable::Channel::TestCase::Behavior::ClassMethods
  def self._channel_class(); end

  def self._channel_class=(val); end

  def self._channel_class?(); end
end

module ActionCable::Channel
  extend ::ActiveSupport::Autoload
end

module ActionCable::Connection
end

module ActionCable::Connection::Assertions
  def assert_reject_connection(&block); end
end

module ActionCable::Connection::Assertions
end

module ActionCable::Connection::Authorization
  def reject_unauthorized_connection(); end
end

class ActionCable::Connection::Authorization::UnauthorizedError
end

class ActionCable::Connection::Authorization::UnauthorizedError
end

module ActionCable::Connection::Authorization
end

class ActionCable::Connection::Base
  include ::ActionCable::Connection::Identification
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Authorization
  def beat(); end

  def close(reason: T.unsafe(nil), reconnect: T.unsafe(nil)); end

  def dispatch_websocket_message(websocket_message); end

  def env(); end

  def event_loop(*args, &block); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, env, coder: T.unsafe(nil)); end

  def logger(); end

  def on_close(reason, code); end

  def on_error(message); end

  def on_message(message); end

  def on_open(); end

  def process(); end

  def protocol(); end

  def pubsub(*args, &block); end

  def receive(websocket_message); end

  def send_async(method, *arguments); end

  def server(); end

  def statistics(); end

  def subscriptions(); end

  def transmit(cable_message); end

  def worker_pool(); end
end

class ActionCable::Connection::Base
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::Connection::ClientSocket
  def alive?(); end

  def client_gone(); end

  def close(code=T.unsafe(nil), reason=T.unsafe(nil)); end

  def env(); end

  def initialize(env, event_target, event_loop, protocols); end

  def parse(data); end

  def protocol(); end

  def rack_response(); end

  def start_driver(); end

  def transmit(message); end

  def url(); end

  def write(data); end
  CLOSED = ::T.let(nil, ::T.untyped)
  CLOSING = ::T.let(nil, ::T.untyped)
  CONNECTING = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

class ActionCable::Connection::ClientSocket
  def self.determine_url(env); end

  def self.secure_request?(env); end
end

module ActionCable::Connection::Identification
  def connection_identifier(); end
end

module ActionCable::Connection::Identification::ClassMethods
  def identified_by(*identifiers); end
end

module ActionCable::Connection::Identification::ClassMethods
end

module ActionCable::Connection::Identification
  extend ::ActiveSupport::Concern
end

module ActionCable::Connection::InternalChannel
end

module ActionCable::Connection::InternalChannel
  extend ::ActiveSupport::Concern
end

class ActionCable::Connection::MessageBuffer
  def append(message); end

  def initialize(connection); end

  def process!(); end

  def processing?(); end
end

class ActionCable::Connection::MessageBuffer
end

class ActionCable::Connection::Stream
  def close(); end

  def each(&callback); end

  def flush_write_buffer(); end

  def hijack_rack_socket(); end

  def initialize(event_loop, socket); end

  def receive(data); end

  def shutdown(); end

  def write(data); end
end

class ActionCable::Connection::Stream
end

class ActionCable::Connection::StreamEventLoop
  def attach(io, stream); end

  def detach(io, stream); end

  def post(task=T.unsafe(nil), &block); end

  def stop(); end

  def timer(interval, &block); end

  def writes_pending(io); end
end

class ActionCable::Connection::StreamEventLoop
end

class ActionCable::Connection::Subscriptions
  def add(data); end

  def execute_command(data); end

  def identifiers(); end

  def initialize(connection); end

  def logger(*args, &block); end

  def perform_action(data); end

  def remove(data); end

  def remove_subscription(subscription); end

  def unsubscribe_from_all(); end
end

class ActionCable::Connection::Subscriptions
end

class ActionCable::Connection::TaggedLoggerProxy
  def add_tags(*tags); end

  def debug(message); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def initialize(logger, tags:); end

  def tag(logger); end

  def tags(); end

  def unknown(message); end

  def warn(message); end
end

class ActionCable::Connection::TaggedLoggerProxy
end

class ActionCable::Connection::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  def _connection_class(); end

  def _connection_class=(val); end

  def _connection_class?(); end

  def connection(); end
end

module ActionCable::Connection::TestCase::Behavior
  include ::ActionCable::Connection::Assertions
  def connect(path=T.unsafe(nil), **request_params); end

  def cookies(); end

  def disconnect(); end
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
  def connection_class(); end

  def determine_default_connection(name); end

  def tests(connection); end
end

module ActionCable::Connection::TestCase::Behavior::ClassMethods
end

module ActionCable::Connection::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionCable::Connection::TestCase
  extend ::ActionCable::Connection::TestCase::Behavior::ClassMethods
  def self._connection_class(); end

  def self._connection_class=(val); end

  def self._connection_class?(); end
end

class ActionCable::Connection::WebSocket
  def alive?(); end

  def close(); end

  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  def possible?(); end

  def protocol(); end

  def rack_response(); end

  def transmit(data); end
end

class ActionCable::Connection::WebSocket
end

module ActionCable::Connection
  extend ::ActiveSupport::Autoload
end

class ActionCable::Engine
end

class ActionCable::Engine
end

module ActionCable::Helpers
end

module ActionCable::Helpers::ActionCableHelper
  def action_cable_meta_tag(); end
end

module ActionCable::Helpers::ActionCableHelper
end

module ActionCable::Helpers
end

class ActionCable::RemoteConnections
  def initialize(server); end

  def server(); end

  def where(identifier); end
end

class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Identification
  def disconnect(); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, ids); end

  def server(); end
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::RemoteConnections
end

module ActionCable::Server
end

class ActionCable::Server::Base
  include ::ActionCable::Server::Broadcasting
  include ::ActionCable::Server::Connections
  def call(env); end

  def config(); end

  def connection_identifiers(); end

  def disconnect(identifiers); end

  def event_loop(); end

  def initialize(config: T.unsafe(nil)); end

  def logger(*args, &block); end

  def mutex(); end

  def pubsub(); end

  def remote_connections(); end

  def restart(); end

  def worker_pool(); end
end

class ActionCable::Server::Base
  def self.config(); end

  def self.config=(obj); end

  def self.logger(); end
end

module ActionCable::Server::Broadcasting
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

class ActionCable::Server::Broadcasting::Broadcaster
  def broadcast(message); end

  def broadcasting(); end

  def coder(); end

  def initialize(server, broadcasting, coder:); end

  def server(); end
end

class ActionCable::Server::Broadcasting::Broadcaster
end

module ActionCable::Server::Broadcasting
end

class ActionCable::Server::Configuration
  def allow_same_origin_as_host(); end

  def allow_same_origin_as_host=(allow_same_origin_as_host); end

  def allowed_request_origins(); end

  def allowed_request_origins=(allowed_request_origins); end

  def cable(); end

  def cable=(cable); end

  def connection_class(); end

  def connection_class=(connection_class); end

  def disable_request_forgery_protection(); end

  def disable_request_forgery_protection=(disable_request_forgery_protection); end

  def log_tags(); end

  def log_tags=(log_tags); end

  def logger(); end

  def logger=(logger); end

  def mount_path(); end

  def mount_path=(mount_path); end

  def pubsub_adapter(); end

  def url(); end

  def url=(url); end

  def worker_pool_size(); end

  def worker_pool_size=(worker_pool_size); end
end

class ActionCable::Server::Configuration
end

module ActionCable::Server::Connections
  def add_connection(connection); end

  def connections(); end

  def open_connections_statistics(); end

  def remove_connection(connection); end

  def setup_heartbeat_timer(); end
  BEAT_INTERVAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Server::Connections
end

class ActionCable::Server::Worker
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def __callbacks(); end

  def __callbacks?(); end

  def _run_work_callbacks(&block); end

  def _work_callbacks(); end

  def async_exec(receiver, *args, connection:, &block); end

  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  def connection(); end

  def connection=(obj); end

  def executor(); end

  def halt(); end

  def initialize(max_size: T.unsafe(nil)); end

  def invoke(receiver, method, *args, connection:, &block); end

  def stopping?(); end

  def work(connection); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def with_database_connections(); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Concern
end

class ActionCable::Server::Worker
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._work_callbacks(); end

  def self._work_callbacks=(value); end

  def self.connection(); end

  def self.connection=(obj); end
end

module ActionCable::Server
  extend ::ActiveSupport::Autoload
end

module ActionCable::SubscriptionAdapter
end

class ActionCable::SubscriptionAdapter::Async
end

class ActionCable::SubscriptionAdapter::Async
end

class ActionCable::SubscriptionAdapter::Base
  def broadcast(channel, payload); end

  def initialize(server); end

  def logger(); end

  def server(); end

  def shutdown(); end

  def subscribe(channel, message_callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, message_callback); end
end

class ActionCable::SubscriptionAdapter::Base
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  def broadcast(channel, payload); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
end

class ActionCable::SubscriptionAdapter::Inline
  def initialize(*_); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

class ActionCable::SubscriptionAdapter::Inline
end

class ActionCable::SubscriptionAdapter::SubscriberMap
  def add_channel(channel, on_success); end

  def add_subscriber(channel, subscriber, on_success); end

  def broadcast(channel, message); end

  def invoke_callback(callback, message); end

  def remove_channel(channel); end

  def remove_subscriber(channel, subscriber); end
end

class ActionCable::SubscriptionAdapter::SubscriberMap
end

class ActionCable::SubscriptionAdapter::Test
  def broadcasts(channel); end

  def clear(); end

  def clear_messages(channel); end
end

class ActionCable::SubscriptionAdapter::Test
end

module ActionCable::SubscriptionAdapter
  extend ::ActiveSupport::Autoload
end

class ActionCable::TestCase
  include ::ActionCable::TestHelper
end

class ActionCable::TestCase
end

module ActionCable::TestHelper
  def after_teardown(); end

  def assert_broadcast_on(stream, data); end

  def assert_broadcasts(stream, number); end

  def assert_no_broadcasts(stream, &block); end

  def before_setup(); end

  def broadcasts(*args, &block); end

  def clear_messages(*args, &block); end

  def pubsub_adapter(); end
end

module ActionCable::TestHelper
end

module ActionCable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionCable::VERSION
end

module ActionCable
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.server(); end

  def self.version(); end
end

class ActionController::API
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionController::ApiRendering
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::BasicImplicitRender
  include ::ActionController::StrongParameters
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::ForceSSL
  include ::ActionController::DataStreaming
  include ::ActionController::DefaultHeaders
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  def __callbacks(); end

  def __callbacks?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(val); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _wrapper_options(); end

  def _wrapper_options=(val); end

  def _wrapper_options?(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def etaggers(); end

  def etaggers=(val); end

  def etaggers?(); end

  def logger(); end

  def logger=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end
  MODULES = ::T.let(nil, ::T.untyped)
end

class ActionController::API
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::ForceSSL::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::ActionController::Railties::Helpers
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.without_modules(*modules); end
end

class ActionController::ActionControllerError
end

class ActionController::ActionControllerError
end

module ActionController::ApiRendering
  def render_to_body(options=T.unsafe(nil)); end
end

module ActionController::ApiRendering
  extend ::ActiveSupport::Concern
end

class ActionController::BadRequest
  def initialize(msg=T.unsafe(nil)); end
end

class ActionController::BadRequest
end

class ActionController::Base
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::EtagWithTemplateDigest
  include ::ActionController::EtagWithFlash
  include ::ActionController::Caching
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionController::MimeResponds
  include ::ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  include ::ActionController::StrongParameters
  include ::ActionController::ParameterEncoding
  include ::ActionController::Cookies
  include ::ActionController::Flash
  include ::ActionController::FormBuilder
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::RequestForgeryProtection
  include ::ActionController::ContentSecurityPolicy
  include ::ActionController::ForceSSL
  include ::ActionController::Streaming
  include ::ActionController::DataStreaming
  include ::ActionController::HttpAuthentication::Basic::ControllerMethods
  include ::ActionController::HttpAuthentication::Digest::ControllerMethods
  include ::ActionController::HttpAuthentication::Token::ControllerMethods
  include ::ActionController::DefaultHeaders
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(val); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(val); end

  def _view_cache_dependencies?(); end

  def _wrapper_options(); end

  def _wrapper_options=(val); end

  def _wrapper_options?(); end

  def alert(); end

  def allow_forgery_protection(); end

  def allow_forgery_protection=(value); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_protect_from_forgery(); end

  def default_protect_from_forgery=(value); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def etag_with_template_digest(); end

  def etag_with_template_digest=(val); end

  def etag_with_template_digest?(); end

  def etaggers(); end

  def etaggers=(val); end

  def etaggers?(); end

  def flash(*args, &block); end

  def forgery_protection_origin_check(); end

  def forgery_protection_origin_check=(value); end

  def forgery_protection_strategy(); end

  def forgery_protection_strategy=(value); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(val); end

  def fragment_cache_keys?(); end

  def helpers_path(); end

  def helpers_path=(val); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(val); end

  def include_all_helpers?(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def log_warning_on_csrf_failure(); end

  def log_warning_on_csrf_failure=(value); end

  def logger(); end

  def logger=(value); end

  def notice(); end

  def per_form_csrf_tokens(); end

  def per_form_csrf_tokens=(value); end

  def perform_caching(); end

  def perform_caching=(value); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def request_forgery_protection_token(); end

  def request_forgery_protection_token=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end
  MODULES = ::T.let(nil, ::T.untyped)
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionController::Base
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionController::Helpers::ClassMethods
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::ActionController::ParameterEncoding::ClassMethods
  extend ::ActionController::Flash::ClassMethods
  extend ::ActionController::FormBuilder::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::RequestForgeryProtection::ClassMethods
  extend ::ActionController::ContentSecurityPolicy::ClassMethods
  extend ::ActionController::ForceSSL::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::ActionController::Railties::Helpers
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._default_form_builder(); end

  def self._default_form_builder=(val); end

  def self._default_form_builder?(); end

  def self._flash_types(); end

  def self._flash_types=(val); end

  def self._flash_types?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.allow_forgery_protection(); end

  def self.allow_forgery_protection=(value); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_protect_from_forgery(); end

  def self.default_protect_from_forgery=(value); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.etag_with_template_digest(); end

  def self.etag_with_template_digest=(val); end

  def self.etag_with_template_digest?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.forgery_protection_origin_check(); end

  def self.forgery_protection_origin_check=(value); end

  def self.forgery_protection_strategy(); end

  def self.forgery_protection_strategy=(value); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(val); end

  def self.fragment_cache_keys?(); end

  def self.helpers_path(); end

  def self.helpers_path=(val); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(val); end

  def self.include_all_helpers?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.log_warning_on_csrf_failure(); end

  def self.log_warning_on_csrf_failure=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.per_form_csrf_tokens(); end

  def self.per_form_csrf_tokens=(value); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.request_forgery_protection_token(); end

  def self.request_forgery_protection_token=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.without_modules(*modules); end
end

module ActionController::BasicImplicitRender
  def default_render(); end

  def send_action(method, *args); end
end

module ActionController::BasicImplicitRender
end

module ActionController::Caching
end

module ActionController::Caching
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

module ActionController::ConditionalGet
  include ::ActionController::Head
  def expires_in(seconds, options=T.unsafe(nil)); end

  def expires_now(); end

  def fresh_when(object=T.unsafe(nil), etag: T.unsafe(nil), weak_etag: T.unsafe(nil), strong_etag: T.unsafe(nil), last_modified: T.unsafe(nil), public: T.unsafe(nil), template: T.unsafe(nil)); end

  def http_cache_forever(public: T.unsafe(nil)); end

  def stale?(object=T.unsafe(nil), **freshness_kwargs); end
end

module ActionController::ConditionalGet::ClassMethods
  def etag(&etagger); end
end

module ActionController::ConditionalGet::ClassMethods
end

module ActionController::ConditionalGet
  extend ::ActiveSupport::Concern
end

module ActionController::ContentSecurityPolicy
end

module ActionController::ContentSecurityPolicy::ClassMethods
  def content_security_policy(enabled=T.unsafe(nil), **options, &block); end

  def content_security_policy_report_only(report_only=T.unsafe(nil), **options); end
end

module ActionController::ContentSecurityPolicy::ClassMethods
end

module ActionController::ContentSecurityPolicy
  extend ::ActiveSupport::Concern
end

module ActionController::Cookies
end

module ActionController::Cookies
  extend ::ActiveSupport::Concern
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::DataStreaming
  extend ::ActiveSupport::Concern
end

module ActionController::DefaultHeaders
end

module ActionController::DefaultHeaders::ClassMethods
  def make_response!(request); end
end

module ActionController::DefaultHeaders::ClassMethods
end

module ActionController::DefaultHeaders
  extend ::ActiveSupport::Concern
end

module ActionController::EtagWithFlash
end

module ActionController::EtagWithFlash
  extend ::ActiveSupport::Concern
end

module ActionController::EtagWithTemplateDigest
end

module ActionController::EtagWithTemplateDigest
  extend ::ActiveSupport::Concern
end

module ActionController::Flash
  extend ::ActiveSupport::Concern
end

module ActionController::ForceSSL
  def force_ssl_redirect(host_or_options=T.unsafe(nil)); end
  ACTION_OPTIONS = ::T.let(nil, ::T.untyped)
  REDIRECT_OPTIONS = ::T.let(nil, ::T.untyped)
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::ForceSSL::ClassMethods
  def force_ssl(options=T.unsafe(nil)); end
end

module ActionController::ForceSSL::ClassMethods
end

module ActionController::ForceSSL
  extend ::ActiveSupport::Concern
end

module ActionController::FormBuilder
  def default_form_builder(); end
end

module ActionController::FormBuilder::ClassMethods
  def default_form_builder(builder); end
end

module ActionController::FormBuilder::ClassMethods
end

module ActionController::FormBuilder
  extend ::ActiveSupport::Concern
end

module ActionController::Head
  def head(status, options=T.unsafe(nil)); end
end

module ActionController::Head
end

module ActionController::Helpers
  def helpers(); end
end

module ActionController::Helpers::ClassMethods
  def all_helpers_from_path(path); end

  def helper_attr(*attrs); end

  def helpers(); end

  def modules_for_helpers(args); end
end

module ActionController::Helpers::ClassMethods
end

module ActionController::Helpers
  extend ::ActiveSupport::Concern
  def self.helpers_path(); end

  def self.helpers_path=(helpers_path); end
end

module ActionController::HttpAuthentication
end

module ActionController::HttpAuthentication::Basic
  def auth_param(request); end

  def auth_scheme(request); end

  def authenticate(request, &login_procedure); end

  def authentication_request(controller, realm, message); end

  def decode_credentials(request); end

  def encode_credentials(user_name, password); end

  def has_basic_credentials?(request); end

  def user_name_and_password(request); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  def authenticate_or_request_with_http_basic(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_basic(&login_procedure); end

  def http_basic_authenticate_or_request_with(name:, password:, realm: T.unsafe(nil), message: T.unsafe(nil)); end

  def request_http_basic_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  extend ::ActiveSupport::Concern
end

module ActionController::HttpAuthentication::Basic
  extend ::ActionController::HttpAuthentication::Basic
end

module ActionController::HttpAuthentication::Digest
  def authenticate(request, realm, &password_procedure); end

  def authentication_header(controller, realm); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def decode_credentials(header); end

  def decode_credentials_header(request); end

  def encode_credentials(http_method, credentials, password, password_is_ha1); end

  def expected_response(http_method, uri, credentials, password, password_is_ha1=T.unsafe(nil)); end

  def ha1(credentials, password); end

  def nonce(secret_key, time=T.unsafe(nil)); end

  def opaque(secret_key); end

  def secret_token(request); end

  def validate_digest_response(request, realm, &password_procedure); end

  def validate_nonce(secret_key, request, value, seconds_to_timeout=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  def authenticate_or_request_with_http_digest(realm=T.unsafe(nil), message=T.unsafe(nil), &password_procedure); end

  def authenticate_with_http_digest(realm=T.unsafe(nil), &password_procedure); end

  def request_http_digest_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
end

module ActionController::HttpAuthentication::Digest
  extend ::ActionController::HttpAuthentication::Digest
end

module ActionController::HttpAuthentication::Token
  def authenticate(controller, &login_procedure); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def encode_credentials(token, options=T.unsafe(nil)); end

  def params_array_from(raw_params); end

  def raw_params(auth); end

  def rewrite_param_values(array_params); end

  def token_and_options(request); end

  def token_params_from(auth); end
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token::ControllerMethods
  def authenticate_or_request_with_http_token(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_token(&login_procedure); end

  def request_http_token_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Token::ControllerMethods
end

module ActionController::HttpAuthentication::Token
  extend ::ActionController::HttpAuthentication::Token
end

module ActionController::HttpAuthentication
end

module ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  def default_render(); end

  def method_for_action(action_name); end
end

module ActionController::ImplicitRender
end

module ActionController::Instrumentation
  def process_action(*args); end

  def redirect_to(*args); end

  def render(*args); end

  def send_data(data, options=T.unsafe(nil)); end

  def send_file(path, options=T.unsafe(nil)); end

  def view_runtime(); end

  def view_runtime=(view_runtime); end
end

module ActionController::Instrumentation::ClassMethods
  def log_process_action(payload); end
end

module ActionController::Instrumentation::ClassMethods
end

module ActionController::Instrumentation
  extend ::ActiveSupport::Concern
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidCrossOriginRequest
end

class ActionController::InvalidCrossOriginRequest
end

module ActionController::Live
  def new_controller_thread(); end

  def process(name); end

  def response_body=(body); end
end

class ActionController::Live::Buffer
  include ::MonitorMixin
  def call_on_error(); end

  def connected?(); end

  def ignore_disconnect(); end

  def ignore_disconnect=(ignore_disconnect); end

  def initialize(response); end

  def on_error(&block); end
end

class ActionController::Live::Buffer
end

module ActionController::Live::ClassMethods
  def make_response!(request); end
end

module ActionController::Live::ClassMethods
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::Response
end

class ActionController::Live::Response
end

class ActionController::Live::SSE
  def close(); end

  def initialize(stream, options=T.unsafe(nil)); end

  def write(object, options=T.unsafe(nil)); end
  PERMITTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::Live::SSE
end

module ActionController::Live
  extend ::ActiveSupport::Concern
end

class ActionController::LiveTestResponse
  def error?(); end

  def missing?(); end

  def success?(); end
end

class ActionController::LiveTestResponse
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def expire_page(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end

  def write_page(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

class ActionController::LogSubscriber
end

class ActionController::Metal
  include ::ActionController::Testing::Functional
  def content_type(*args, &block); end

  def content_type=(arg); end

  def controller_name(); end

  def dispatch(name, request, response); end

  def headers(*args, &block); end

  def location(*args, &block); end

  def location=(arg); end

  def media_type(*args, &block); end

  def middleware_stack(); end

  def middleware_stack=(val); end

  def middleware_stack?(); end

  def params=(val); end

  def request=(request); end

  def reset_session(); end

  def response=(response); end

  def response_body=(body); end

  def response_code(*args, &block); end

  def session(*args, &block); end

  def set_request!(request); end

  def set_response!(response); end

  def status(*args, &block); end

  def status=(arg); end

  def to_a(); end

  def url_for(string); end
end

class ActionController::Metal
  def self.action(name); end

  def self.binary_params_for?(action); end

  def self.controller_name(); end

  def self.dispatch(name, req, res); end

  def self.inherited(base); end

  def self.make_response!(request); end

  def self.middleware(); end

  def self.middleware_stack(); end

  def self.middleware_stack=(val); end

  def self.middleware_stack?(); end

  def self.use(*args, &block); end
end

class ActionController::MethodNotAllowed
  def initialize(*allowed_methods); end
end

class ActionController::MethodNotAllowed
end

class ActionController::MiddlewareStack
  def build(action, app=T.unsafe(nil), &block); end
  EXCLUDE = ::T.let(nil, ::T.untyped)
  INCLUDE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionController::MiddlewareStack::Middleware
  def initialize(klass, args, actions, strategy, block); end

  def valid?(action); end
end

class ActionController::MiddlewareStack::Middleware
end

class ActionController::MiddlewareStack
end

class ActionController::MimeResponds::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime_type, &block); end

  def format(); end

  def format=(format); end

  def initialize(mimes, variant=T.unsafe(nil)); end

  def negotiate_format(request); end

  def response(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
  def all(*args, &block); end

  def any(*args, &block); end

  def initialize(variant=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def variant(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
end

class ActionController::MissingExactTemplate
end

class ActionController::MissingExactTemplate
end

class ActionController::MissingFile
end

class ActionController::MissingFile
end

class ActionController::MissingRenderer
  def initialize(format); end
end

class ActionController::MissingRenderer
end

class ActionController::NotImplemented
end

class ActionController::NotImplemented
end

module ActionController::ParameterEncoding
end

module ActionController::ParameterEncoding::ClassMethods
  def binary_params_for?(action); end

  def inherited(klass); end

  def setup_param_encode(); end

  def skip_parameter_encoding(action); end
end

module ActionController::ParameterEncoding::ClassMethods
end

module ActionController::ParameterEncoding
  extend ::ActiveSupport::Concern
end

class ActionController::ParameterMissing
  def initialize(param); end

  def param(); end
end

class ActionController::ParameterMissing
end

class ActionController::Parameters
  def converted_arrays(); end

  def each_key(*args, &block); end

  def each_value(&block); end

  def fields_for_style?(); end

  def init_with(coder); end

  def stringify_keys(); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActionController::Parameters
  def self.hook_into_yaml_loading(); end
end

module ActionController::ParamsWrapper
  def process_action(*args); end
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper::ClassMethods
  def _set_wrapper_options(options); end

  def inherited(klass); end

  def wrap_parameters(name_or_model_or_options, options=T.unsafe(nil)); end
end

module ActionController::ParamsWrapper::ClassMethods
end

class ActionController::ParamsWrapper::Options
  include ::Mutex_m
  def initialize(name, format, include, exclude, klass, model); end

  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActionController::ParamsWrapper::Options
  def self.from_hash(hash); end
end

module ActionController::ParamsWrapper
  extend ::ActiveSupport::Concern
end

class ActionController::Railtie
end

class ActionController::Railtie
end

module ActionController::Railties
end

module ActionController::Railties::Helpers
  def inherited(klass); end
end

module ActionController::Railties::Helpers
end

module ActionController::Railties
end

module ActionController::Redirecting
  def _compute_redirect_to_location(request, options); end

  def redirect_back(fallback_location:, allow_other_host: T.unsafe(nil), **args); end

  def redirect_to(options=T.unsafe(nil), response_options=T.unsafe(nil)); end
end

module ActionController::Redirecting
  extend ::ActiveSupport::Concern
  def self._compute_redirect_to_location(request, options); end
end

class ActionController::RenderError
end

class ActionController::RenderError
end

class ActionController::Renderer
  def controller(); end

  def defaults(); end

  def initialize(controller, env, defaults); end

  def new(env=T.unsafe(nil)); end

  def render(*args); end

  def with_defaults(defaults); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  RACK_KEY_TRANSLATION = ::T.let(nil, ::T.untyped)
  RACK_VALUE_TRANSLATION = ::T.let(nil, ::T.untyped)
end

class ActionController::Renderer
  def self.for(controller, env=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

module ActionController::Renderers
  def _render_to_body_with_renderer(options); end

  def _render_with_renderer_js(js, options); end

  def _render_with_renderer_json(json, options); end

  def _render_with_renderer_xml(xml, options); end

  def render_to_body(options); end
  RENDERERS = ::T.let(nil, ::T.untyped)
end

module ActionController::Renderers::All
end

module ActionController::Renderers::All
  extend ::ActiveSupport::Concern
end

module ActionController::Renderers::ClassMethods
  def use_renderer(*args); end

  def use_renderers(*args); end
end

module ActionController::Renderers::ClassMethods
end

module ActionController::Renderers
  extend ::ActiveSupport::Concern
  def self._render_with_renderer_method_name(key); end

  def self.add(key, &block); end

  def self.remove(key); end
end

module ActionController::Rendering
  def process_action(*_); end

  def render(*args); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*_); end
  RENDER_FORMATS_IN_PRIORITY = ::T.let(nil, ::T.untyped)
end

module ActionController::Rendering::ClassMethods
  def inherited(klass); end

  def render(*args, &block); end

  def renderer(); end

  def setup_renderer!(); end
end

module ActionController::Rendering::ClassMethods
end

module ActionController::Rendering
  extend ::ActiveSupport::Concern
end

module ActionController::RequestForgeryProtection
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
  NULL_ORIGIN_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActionController::RequestForgeryProtection::ClassMethods
  def skip_forgery_protection(options=T.unsafe(nil)); end
end

module ActionController::RequestForgeryProtection::ProtectionMethods
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
  def write(*_); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
  def initialize(req); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
end

module ActionController::RequestForgeryProtection::ProtectionMethods
end

module ActionController::RequestForgeryProtection
  extend ::ActiveSupport::Concern
end

module ActionController::Rescue
  def show_detailed_exceptions?(); end
end

module ActionController::Rescue
  extend ::ActiveSupport::Concern
end

class ActionController::RespondToMismatchError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::RespondToMismatchError
end

class ActionController::RoutingError
  def failures(); end

  def initialize(message, failures=T.unsafe(nil)); end
end

class ActionController::RoutingError
end

class ActionController::SessionOverflowError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::SessionOverflowError
end

module ActionController::Streaming
end

module ActionController::Streaming
  extend ::ActiveSupport::Concern
end

module ActionController::StrongParameters
  def params=(value); end
end

module ActionController::TemplateAssertions
  def assert_template(options=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::TemplateAssertions
end

class ActionController::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Rails::Controller::Testing::TestProcess
  include ::Rails::Controller::Testing::TemplateAssertions
  def _controller_class(); end

  def _controller_class=(val); end

  def _controller_class?(); end
end

module ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def build_response(klass); end

  def controller_class_name(); end

  def delete(action, **args); end

  def generated_path(generated_extras); end

  def get(action, **args); end

  def head(action, **args); end

  def patch(action, **args); end

  def post(action, **args); end

  def process(action, method: T.unsafe(nil), params: T.unsafe(nil), session: T.unsafe(nil), body: T.unsafe(nil), flash: T.unsafe(nil), format: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def put(action, **args); end

  def query_parameter_names(generated_extras); end

  def request(); end

  def response(); end

  def setup_controller_request_and_response(); end
end

module ActionController::TestCase::Behavior::ClassMethods
  def controller_class(); end

  def controller_class=(new_class); end

  def determine_default_controller_class(name); end

  def tests(controller_class); end
end

module ActionController::TestCase::Behavior::ClassMethods
end

module ActionController::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionController::TestCase
  extend ::ActionController::TestCase::Behavior::ClassMethods
  def self._controller_class(); end

  def self._controller_class=(val); end

  def self._controller_class?(); end
end

class ActionController::TestRequest
  def assign_parameters(routes, controller_path, action, parameters, generated_path, query_string_keys); end

  def content_type=(type); end

  def initialize(env, session, controller_class); end

  def query_string=(string); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionController::TestRequest
  def self.create(controller_class); end

  def self.new_session(); end
end

class ActionController::TestSession
  def fetch(key, *args, &block); end

  def initialize(session=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::TestSession
end

module ActionController::Testing
end

module ActionController::Testing::Functional
  def recycle!(); end
end

module ActionController::Testing::Functional
end

module ActionController::Testing
  extend ::ActiveSupport::Concern
end

class ActionController::UnfilteredParameters
  def initialize(); end
end

class ActionController::UnfilteredParameters
end

class ActionController::UnknownFormat
end

class ActionController::UnknownFormat
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnpermittedParameters
  def initialize(params); end

  def params(); end
end

class ActionController::UnpermittedParameters
end

module ActionController::UrlFor
  def url_options(); end
end

module ActionController::UrlFor
  extend ::ActiveSupport::Concern
end

class ActionController::UrlGenerationError
end

class ActionController::UrlGenerationError
end

module ActionController
  extend ::ActiveSupport::Autoload
  def self.add_renderer(key, &block); end

  def self.remove_renderer(key); end
end

module ActionDispatch
  def test_app(); end

  def test_app=(obj); end
end

class ActionDispatch::ActionableExceptions
  def call(env); end

  def endpoint(); end

  def endpoint=(obj); end

  def initialize(app); end
end

class ActionDispatch::ActionableExceptions
  def self.endpoint(); end

  def self.endpoint=(obj); end
end

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def html_document(); end
end

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response(type, message=T.unsafe(nil)); end
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Assertions::ResponseAssertions
end

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_recognizes(expected_options, path, extras=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_routing(path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def method_missing(selector, *args, &block); end

  def setup(); end

  def with_routing(); end
end

module ActionDispatch::Assertions::RoutingAssertions
end

module ActionDispatch::Assertions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Callbacks
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _call_callbacks(); end

  def _run_call_callbacks(&block); end

  def call(env); end

  def initialize(app); end
end

class ActionDispatch::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._call_callbacks(); end

  def self._call_callbacks=(value); end

  def self.after(*args, &block); end

  def self.before(*args, &block); end
end

class ActionDispatch::ContentSecurityPolicy
  def base_uri(*sources); end

  def block_all_mixed_content(enabled=T.unsafe(nil)); end

  def build(context=T.unsafe(nil), nonce=T.unsafe(nil), nonce_directives=T.unsafe(nil)); end

  def child_src(*sources); end

  def connect_src(*sources); end

  def default_src(*sources); end

  def directives(); end

  def font_src(*sources); end

  def form_action(*sources); end

  def frame_ancestors(*sources); end

  def frame_src(*sources); end

  def img_src(*sources); end

  def manifest_src(*sources); end

  def media_src(*sources); end

  def object_src(*sources); end

  def plugin_types(*types); end

  def prefetch_src(*sources); end

  def report_uri(uri); end

  def require_sri_for(*types); end

  def sandbox(*values); end

  def script_src(*sources); end

  def style_src(*sources); end

  def upgrade_insecure_requests(enabled=T.unsafe(nil)); end

  def worker_src(*sources); end
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  def call(env); end

  def initialize(app); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ContentSecurityPolicy::Middleware
end

module ActionDispatch::ContentSecurityPolicy::Request
  def content_security_policy(); end

  def content_security_policy=(policy); end

  def content_security_policy_nonce(); end

  def content_security_policy_nonce_directives(); end

  def content_security_policy_nonce_directives=(generator); end

  def content_security_policy_nonce_generator(); end

  def content_security_policy_nonce_generator=(generator); end

  def content_security_policy_report_only(); end

  def content_security_policy_report_only=(value); end
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_DIRECTIVES = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
end

class ActionDispatch::ContentSecurityPolicy
end

class ActionDispatch::Cookies
  def call(env); end

  def initialize(app); end
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
  USE_COOKIES_WITH_METADATA = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::AbstractCookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar); end

  def request(); end
end

class ActionDispatch::Cookies::AbstractCookieJar
end

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted(); end

  def permanent(); end

  def signed(); end

  def signed_or_encrypted(); end
end

module ActionDispatch::Cookies::ChainedCookieJars
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  include ::Enumerable
  def [](name); end

  def []=(name, options); end

  def always_write_cookie(); end

  def always_write_cookie=(obj); end

  def clear(options=T.unsafe(nil)); end

  def commit!(); end

  def committed?(); end

  def delete(name, options=T.unsafe(nil)); end

  def deleted?(name, options=T.unsafe(nil)); end

  def each(&block); end

  def fetch(name, *args, &block); end

  def handle_options(options); end

  def has_key?(name); end

  def initialize(request); end

  def key?(name); end

  def request(); end

  def to_hash(*_); end

  def to_header(); end

  def update(other_hash); end

  def update_cookies_from_jar(); end

  def write(headers); end
  DOMAIN_REGEXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::CookieJar
  def self.always_write_cookie(); end

  def self.always_write_cookie=(obj); end

  def self.build(req, cookies); end
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
end

class ActionDispatch::Cookies::JsonSerializer
end

class ActionDispatch::Cookies::JsonSerializer
  def self.dump(value); end

  def self.load(value); end
end

class ActionDispatch::Cookies::PermanentCookieJar
end

class ActionDispatch::Cookies::PermanentCookieJar
end

module ActionDispatch::Cookies::SerializedCookieJars
  def deserialize(name); end

  def digest(); end

  def needs_migration?(value); end

  def serialize(value); end

  def serializer(); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

module ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
end

class ActionDispatch::Cookies
end

class ActionDispatch::DebugExceptions
  def call(env); end

  def initialize(app, routes_app=T.unsafe(nil), response_format=T.unsafe(nil), interceptors=T.unsafe(nil)); end
end

class ActionDispatch::DebugExceptions
  def self.interceptors(); end

  def self.register_interceptor(object=T.unsafe(nil), &block); end
end

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::DebugView
  def debug_hash(object); end

  def debug_headers(headers); end

  def debug_params(params); end

  def initialize(assigns); end

  def params_valid?(); end

  def protect_against_forgery?(); end

  def render(*_); end
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugView
end

class ActionDispatch::ExceptionWrapper
  def application_trace(); end

  def backtrace_cleaner(); end

  def exception(); end

  def file(); end

  def framework_trace(); end

  def full_trace(); end

  def initialize(backtrace_cleaner, exception); end

  def line_number(); end

  def rescue_responses(); end

  def rescue_responses=(obj); end

  def rescue_template(); end

  def rescue_templates(); end

  def rescue_templates=(obj); end

  def source_extracts(); end

  def source_to_show_id(); end

  def status_code(); end

  def trace_to_show(); end

  def traces(); end

  def unwrapped_exception(); end

  def wrapped_causes(); end

  def wrapper_exceptions(); end

  def wrapper_exceptions=(obj); end
end

class ActionDispatch::ExceptionWrapper
  def self.rescue_responses(); end

  def self.rescue_responses=(obj); end

  def self.rescue_templates(); end

  def self.rescue_templates=(obj); end

  def self.status_code_for_exception(class_name); end

  def self.wrapper_exceptions(); end

  def self.wrapper_exceptions=(obj); end
end

class ActionDispatch::Executor
  def call(env); end

  def initialize(app, executor); end
end

class ActionDispatch::Executor
end

class ActionDispatch::FileHandler
  def call(env); end

  def initialize(root, index: T.unsafe(nil), headers: T.unsafe(nil)); end

  def match?(path); end

  def serve(request); end
end

class ActionDispatch::FileHandler
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash::FlashHash
  include ::Enumerable
  def [](k); end

  def []=(k, v); end

  def alert(); end

  def alert=(message); end

  def clear(); end

  def delete(key); end

  def discard(k=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def initialize(flashes=T.unsafe(nil), discard=T.unsafe(nil)); end

  def keep(k=T.unsafe(nil)); end

  def key?(name); end

  def keys(); end

  def merge!(h); end

  def notice(); end

  def notice=(message); end

  def now(); end

  def now_is_loaded?(); end

  def replace(h); end

  def sweep(); end

  def to_hash(); end

  def to_session_value(); end

  def update(h); end
end

class ActionDispatch::Flash::FlashHash
  def self.from_session_value(value); end
end

class ActionDispatch::Flash::FlashNow
  def [](k); end

  def []=(k, v); end

  def alert=(message); end

  def flash(); end

  def flash=(flash); end

  def initialize(flash); end

  def notice=(message); end
end

class ActionDispatch::Flash::FlashNow
end

module ActionDispatch::Flash::RequestMethods
  def commit_flash(); end

  def flash(); end

  def flash=(flash); end

  def flash_hash(); end

  def reset_session(); end
end

module ActionDispatch::Flash::RequestMethods
end

class ActionDispatch::Flash
  def self.new(app); end
end

class ActionDispatch::HostAuthorization
  def call(env); end

  def initialize(app, hosts, response_app=T.unsafe(nil)); end
  DEFAULT_RESPONSE_APP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization::Permissions
  def allows?(host); end

  def empty?(); end

  def initialize(hosts); end
end

class ActionDispatch::HostAuthorization::Permissions
end

class ActionDispatch::HostAuthorization
end

module ActionDispatch::Http
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end

  def fresh?(response); end

  def if_modified_since(); end

  def if_none_match(); end

  def if_none_match_etags(); end

  def not_modified?(modified_at); end
  HTTP_IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  HTTP_IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Request
end

module ActionDispatch::Http::Cache::Response
  def cache_control(); end

  def date(); end

  def date=(utc_time); end

  def date?(); end

  def etag=(weak_validators); end

  def etag?(); end

  def last_modified(); end

  def last_modified=(utc_time); end

  def last_modified?(); end

  def strong_etag=(strong_validators); end

  def strong_etag?(); end

  def weak_etag=(weak_validators); end

  def weak_etag?(); end
  DATE = ::T.let(nil, ::T.untyped)
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  MUST_REVALIDATE = ::T.let(nil, ::T.untyped)
  NO_CACHE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Response
end

module ActionDispatch::Http::Cache
end

class ActionDispatch::Http::ContentDisposition
  def ascii_filename(); end

  def disposition(); end

  def filename(); end

  def initialize(disposition:, filename:); end

  def utf8_filename(); end
  RFC_5987_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
  TRADITIONAL_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::ContentDisposition
  def self.format(disposition:, filename:); end
end

module ActionDispatch::Http::FilterParameters
  def filtered_env(); end

  def filtered_parameters(); end

  def filtered_path(); end

  def initialize(); end
  ENV_MATCH = ::T.let(nil, ::T.untyped)
  KV_RE = ::T.let(nil, ::T.untyped)
  NULL_ENV_FILTER = ::T.let(nil, ::T.untyped)
  NULL_PARAM_FILTER = ::T.let(nil, ::T.untyped)
  PAIR_RE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
end

module ActionDispatch::Http::FilterRedirect
  def filtered_location(); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
end

class ActionDispatch::Http::Headers
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def add(key, value); end

  def each(&block); end

  def env(); end

  def fetch(key, default=T.unsafe(nil)); end

  def include?(key); end

  def initialize(request); end

  def key?(key); end

  def merge(headers_or_env); end

  def merge!(headers_or_env); end
  CGI_VARIABLES = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::Headers
  def self.from_hash(hash); end
end

module ActionDispatch::Http::MimeNegotiation
  def accepts(); end

  def content_mime_type(); end

  def content_type(); end

  def format(view_path=T.unsafe(nil)); end

  def format=(extension); end

  def formats(); end

  def formats=(extensions); end

  def has_content_type?(); end

  def negotiate_mime(order); end

  def variant(); end

  def variant=(variant); end
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
  RESCUABLE_MIME_FORMAT_ERRORS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  extend ::ActiveSupport::Concern
end

ActionDispatch::Http::ParameterFilter = ActiveSupport::ParameterFilter

module ActionDispatch::Http::Parameters
  def path_parameters(); end

  def path_parameters=(parameters); end
  DEFAULT_PARSERS = ::T.let(nil, ::T.untyped)
  PARAMETERS_KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Parameters
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Http::URL
  def domain(tld_length=T.unsafe(nil)); end

  def host(); end

  def host_with_port(); end

  def initialize(); end

  def optional_port(); end

  def port(); end

  def port_string(); end

  def protocol(); end

  def raw_host_with_port(); end

  def server_port(); end

  def standard_port(); end

  def standard_port?(); end

  def subdomain(tld_length=T.unsafe(nil)); end

  def subdomains(tld_length=T.unsafe(nil)); end

  def tld_length(); end

  def tld_length=(obj); end

  def url(); end
  HOST_REGEXP = ::T.let(nil, ::T.untyped)
  IP_HOST_REGEXP = ::T.let(nil, ::T.untyped)
  PROTOCOL_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  def self.extract_domain(host, tld_length); end

  def self.extract_subdomain(host, tld_length); end

  def self.extract_subdomains(host, tld_length); end

  def self.full_url_for(options); end

  def self.path_for(options); end

  def self.tld_length(); end

  def self.tld_length=(obj); end

  def self.url_for(options); end
end

class ActionDispatch::Http::UploadedFile
  def close(unlink_now=T.unsafe(nil)); end

  def content_type(); end

  def content_type=(content_type); end

  def eof?(); end

  def headers(); end

  def headers=(headers); end

  def initialize(hash); end

  def open(); end

  def original_filename(); end

  def original_filename=(original_filename); end

  def path(); end

  def read(length=T.unsafe(nil), buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def tempfile(); end

  def tempfile=(tempfile); end

  def to_io(); end

  def to_path(); end
end

class ActionDispatch::Http::UploadedFile
end

module ActionDispatch::Http
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::IllegalStateError
end

class ActionDispatch::IllegalStateError
end

module ActionDispatch::Integration
end

module ActionDispatch::Integration::RequestHelpers
  def delete(path, **args); end

  def follow_redirect!(**args); end

  def get(path, **args); end

  def head(path, *args); end

  def patch(path, **args); end

  def post(path, **args); end

  def put(path, **args); end
end

module ActionDispatch::Integration::RequestHelpers
end

module ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def app(); end

  def assigns(*args); end

  def before_setup(); end

  def cookies(*args); end

  def copy_session_variables!(); end

  def create_session(app); end

  def default_url_options(); end

  def default_url_options=(options); end

  def delete(*args); end

  def follow_redirect!(*args); end

  def get(*args); end

  def head(*args); end

  def initialize(*args, &blk); end

  def integration_session(); end

  def open_session(); end

  def patch(*args); end

  def post(*args); end

  def put(*args); end

  def remove!(); end

  def reset!(); end
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration::Runner
end

class ActionDispatch::Integration::Session
  include ::Minitest::Assertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Integration::RequestHelpers
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def accept(); end

  def accept=(accept); end

  def body(*args, &block); end

  def controller(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def headers(*args, &block); end

  def host(); end

  def host!(_); end

  def host=(host); end

  def https!(flag=T.unsafe(nil)); end

  def https?(); end

  def initialize(app); end

  def path(*args, &block); end

  def process(method, path, params: T.unsafe(nil), headers: T.unsafe(nil), env: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def redirect?(*args, &block); end

  def remote_addr(); end

  def remote_addr=(remote_addr); end

  def request(); end

  def request_count(); end

  def request_count=(request_count); end

  def reset!(); end

  def response(); end

  def status(*args, &block); end

  def status_message(*args, &block); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Integration
end

class ActionDispatch::IntegrationTest
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::IntegrationTest::UrlOptions
  include ::Rails::Controller::Testing::TemplateAssertions
  include ::Rails::Controller::Testing::Integration
  include ::Rails::Controller::Testing::TestProcess
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActionMailer::TestCase::ClearTestDeliveries
end

module ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionController::TemplateAssertions
  def app(); end

  def document_root_element(); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  def app(); end

  def app=(app); end

  def register_encoder(*args); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::IntegrationTest::Behavior
  extend ::ActiveSupport::Concern
end

module ActionDispatch::IntegrationTest::UrlOptions
  def url_options(); end
end

module ActionDispatch::IntegrationTest::UrlOptions
  extend ::ActiveSupport::Concern
end

class ActionDispatch::IntegrationTest
  extend ::ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::Journey
end

class ActionDispatch::Journey::Format
  def evaluate(hash); end

  def initialize(parts); end
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Format::Parameter
  def escape(value); end

  def escaper(); end

  def escaper=(_); end

  def name(); end

  def name=(_); end
end

class ActionDispatch::Journey::Format::Parameter
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Journey::Format
  def self.required_path(symbol); end

  def self.required_segment(symbol); end
end

class ActionDispatch::Journey::Formatter
  def clear(); end

  def generate(name, options, path_parameters, parameterize=T.unsafe(nil)); end

  def initialize(routes); end

  def routes(); end
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  DEFAULT_INPUT = ::T.let(nil, ::T.untyped)
  DEFAULT_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  def self.===(regex); end
end

class ActionDispatch::Journey::Formatter
end

module ActionDispatch::Journey::GTG
end

class ActionDispatch::Journey::GTG::Builder
  def ast(); end

  def endpoints(); end

  def firstpos(node); end

  def followpos(node); end

  def initialize(root); end

  def lastpos(node); end

  def nullable?(node); end

  def root(); end

  def transition_table(); end
  DUMMY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
end

class ActionDispatch::Journey::GTG::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::GTG::MatchData
end

class ActionDispatch::Journey::GTG::Simulator
  def initialize(transition_table); end

  def memos(string); end

  def tt(); end
end

class ActionDispatch::Journey::GTG::Simulator
end

class ActionDispatch::Journey::GTG::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(from, to, sym); end

  def accepting?(state); end

  def accepting_states(); end

  def add_accepting(state); end

  def add_memo(idx, memo); end

  def eclosure(t); end

  def memo(idx); end

  def memos(); end

  def move(t, a); end

  def states(); end

  def to_svg(); end

  def transitions(); end

  def visualizer(paths, title=T.unsafe(nil)); end
end

class ActionDispatch::Journey::GTG::TransitionTable
end

module ActionDispatch::Journey::GTG
end

module ActionDispatch::Journey::NFA
end

class ActionDispatch::Journey::NFA::Builder
  def initialize(ast); end

  def transition_table(); end
end

class ActionDispatch::Journey::NFA::Builder
end

module ActionDispatch::Journey::NFA::Dot
  def to_dot(); end
end

module ActionDispatch::Journey::NFA::Dot
end

class ActionDispatch::Journey::NFA::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::NFA::MatchData
end

class ActionDispatch::Journey::NFA::Simulator
  def =~(string); end

  def initialize(transition_table); end

  def match(string); end

  def simulate(string); end

  def tt(); end
end

class ActionDispatch::Journey::NFA::Simulator
end

class ActionDispatch::Journey::NFA::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(i, f, s); end

  def accepting(); end

  def accepting=(accepting); end

  def accepting?(state); end

  def accepting_states(); end

  def add_memo(idx, memo); end

  def alphabet(); end

  def eclosure(t); end

  def following_states(t, a); end

  def memo(idx); end

  def memos(); end

  def merge(left, right); end

  def move(t, a); end

  def states(); end

  def transitions(); end
end

class ActionDispatch::Journey::NFA::TransitionTable
end

class ActionDispatch::Journey::NFA::Visitor
  def initialize(tt); end

  def visit_CAT(node); end

  def visit_GROUP(node); end

  def visit_OR(node); end
end

class ActionDispatch::Journey::NFA::Visitor
end

module ActionDispatch::Journey::NFA
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Nodes::Binary
  def children(); end

  def initialize(left, right); end

  def right(); end

  def right=(right); end
end

class ActionDispatch::Journey::Nodes::Binary
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dummy
  def initialize(x=T.unsafe(nil)); end
end

class ActionDispatch::Journey::Nodes::Dummy
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Node
  include ::Enumerable
  def cat?(); end

  def each(&block); end

  def group?(); end

  def initialize(left); end

  def left(); end

  def left=(left); end

  def literal?(); end

  def memo(); end

  def memo=(memo); end

  def name(); end

  def star?(); end

  def symbol?(); end

  def terminal?(); end

  def to_dot(); end

  def to_sym(); end

  def type(); end
end

class ActionDispatch::Journey::Nodes::Node
end

class ActionDispatch::Journey::Nodes::Or
  def children(); end

  def initialize(children); end
end

class ActionDispatch::Journey::Nodes::Or
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Symbol
  def default_regexp?(); end

  def regexp(); end

  def regexp=(regexp); end
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
end

class ActionDispatch::Journey::Nodes::Terminal
  def symbol(); end
end

class ActionDispatch::Journey::Nodes::Terminal
end

class ActionDispatch::Journey::Nodes::Unary
  def children(); end
end

class ActionDispatch::Journey::Nodes::Unary
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Parser
  include ::ActionDispatch::Journey::Nodes
  def _reduce_1(val, _values); end

  def _reduce_10(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def parse(string); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
  def self.parse(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Path::Pattern
  def =~(other); end

  def anchored(); end

  def ast(); end

  def build_formatter(); end

  def eager_load!(); end

  def initialize(ast, requirements, separators, anchored); end

  def match(other); end

  def names(); end

  def optional_names(); end

  def required_names(); end

  def requirements(); end

  def source(); end

  def spec(); end

  def to_regexp(); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def initialize(separator, matchers); end

  def visit_CAT(node); end

  def visit_DOT(node); end

  def visit_GROUP(node); end

  def visit_LITERAL(node); end

  def visit_OR(node); end

  def visit_SLASH(node); end

  def visit_STAR(node); end

  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::MatchData
  def [](x); end

  def captures(); end

  def initialize(names, offsets, match); end

  def length(); end

  def named_captures(); end

  def names(); end

  def post_match(); end
end

class ActionDispatch::Journey::Path::Pattern::MatchData
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern
  def self.build(path, requirements, separators, anchored); end

  def self.from_string(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Route
  def app(); end

  def ast(); end

  def conditions(); end

  def constraints(); end

  def defaults(); end

  def dispatcher?(); end

  def eager_load!(); end

  def format(path_options); end

  def glob?(); end

  def initialize(name, app, path, constraints, required_defaults, defaults, request_method_match, precedence, scope_options, internal=T.unsafe(nil)); end

  def internal(); end

  def ip(); end

  def matches?(request); end

  def name(); end

  def parts(); end

  def path(); end

  def precedence(); end

  def required_default?(key); end

  def required_defaults(); end

  def required_keys(); end

  def required_parts(); end

  def requirements(); end

  def requires_matching_verb?(); end

  def scope_options(); end

  def score(supplied_keys); end

  def segment_keys(); end

  def segments(); end

  def verb(); end
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Route::VerbMatchers::All
end

class ActionDispatch::Journey::Route::VerbMatchers::All
  def self.call(_); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
  def call(request); end

  def initialize(verb); end

  def verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
end

module ActionDispatch::Journey::Route::VerbMatchers
end

class ActionDispatch::Journey::Route
  def self.build(name, app, path, constraints, required_defaults, defaults); end

  def self.verb_matcher(verb); end
end

class ActionDispatch::Journey::Router
  def eager_load!(); end

  def initialize(routes); end

  def recognize(rails_req); end

  def routes(); end

  def routes=(routes); end

  def serve(req); end

  def visualizer(); end
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  def escape_fragment(fragment); end

  def escape_path(path); end

  def escape_segment(segment); end

  def unescape_uri(uri); end
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
end

class ActionDispatch::Journey::Router::Utils
  def self.escape_fragment(fragment); end

  def self.escape_path(path); end

  def self.escape_segment(segment); end

  def self.normalize_path(path); end

  def self.unescape_uri(uri); end
end

class ActionDispatch::Journey::Router
end

class ActionDispatch::Journey::Routes
  include ::Enumerable
  def add_route(name, mapping); end

  def anchored_routes(); end

  def ast(); end

  def clear(); end

  def custom_routes(); end

  def each(&block); end

  def empty?(); end

  def last(); end

  def length(); end

  def partition_route(route); end

  def routes(); end

  def simulator(); end

  def size(); end
end

class ActionDispatch::Journey::Routes
end

class ActionDispatch::Journey::Scanner
  def eos?(); end

  def next_token(); end

  def pos(); end

  def pre_match(); end

  def scan_setup(str); end
end

class ActionDispatch::Journey::Scanner
end

module ActionDispatch::Journey::Visitors
end

class ActionDispatch::Journey::Visitors::Dot
  def accept(node, seed=T.unsafe(nil)); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
end

class ActionDispatch::Journey::Visitors::Each
  def visit(node, block); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  def accept(node, seed); end

  def binary(node, seed); end

  def nary(node, seed); end

  def terminal(node, seed); end

  def unary(node, seed); end

  def visit(node, seed); end

  def visit_CAT(n, seed); end

  def visit_DOT(n, seed); end

  def visit_GROUP(n, seed); end

  def visit_LITERAL(n, seed); end

  def visit_OR(n, seed); end

  def visit_SLASH(n, seed); end

  def visit_STAR(n, seed); end

  def visit_SYMBOL(n, seed); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
end

class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
end

module ActionDispatch::Journey::Visitors
end

module ActionDispatch::Journey
end

class ActionDispatch::MiddlewareStack
  include ::Enumerable
  def [](i); end

  def build(app=T.unsafe(nil), &block); end

  def delete(target); end

  def each(&blk); end

  def initialize(*args); end

  def insert(index, klass, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, klass, *args, &block); end

  def last(); end

  def middlewares(); end

  def middlewares=(middlewares); end

  def size(); end

  def swap(target, *args, &block); end

  def unshift(klass, *args, &block); end

  def use(klass, *args, &block); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def ==(middleware); end

  def args(); end

  def block(); end

  def build(app); end

  def build_instrumented(app); end

  def initialize(klass, args, block); end

  def klass(); end

  def name(); end
end

class ActionDispatch::MiddlewareStack::Middleware
end

class ActionDispatch::MiddlewareStack
end

class ActionDispatch::PublicExceptions
  def call(env); end

  def initialize(public_path); end

  def public_path(); end

  def public_path=(public_path); end
end

class ActionDispatch::PublicExceptions
end

class ActionDispatch::Railtie
end

class ActionDispatch::Railtie
end

class ActionDispatch::Reloader
end

class ActionDispatch::Reloader
end

class ActionDispatch::RemoteIp
  def call(env); end

  def check_ip(); end

  def initialize(app, ip_spoofing_check=T.unsafe(nil), custom_proxies=T.unsafe(nil)); end

  def proxies(); end
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RemoteIp::GetIp
  def calculate_ip(); end

  def initialize(req, check_ip, proxies); end
end

class ActionDispatch::RemoteIp::GetIp
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp
end

class ActionDispatch::Request
  include ::Rack::Request::Helpers
  include ::ActionDispatch::Http::Cache::Request
  include ::ActionDispatch::Http::MimeNegotiation
  include ::ActionDispatch::Http::Parameters
  include ::ActionDispatch::Http::FilterParameters
  include ::ActionDispatch::Http::URL
  include ::ActionDispatch::ContentSecurityPolicy::Request
  include ::Rack::Request::Env
  include ::ActionDispatch::Flash::RequestMethods
  def accept(); end

  def accept_charset(); end

  def auth_type(); end

  def authenticated_encrypted_cookie_salt(); end

  def authorization(); end

  def body_stream(); end

  def cache_control(); end

  def client_ip(); end

  def controller_class(); end

  def controller_class_for(name); end

  def controller_instance(); end

  def controller_instance=(controller); end

  def cookie_jar(); end

  def cookie_jar=(jar); end

  def cookies_digest(); end

  def cookies_rotations(); end

  def cookies_serializer(); end

  def encrypted_cookie_cipher(); end

  def encrypted_cookie_salt(); end

  def encrypted_signed_cookie_salt(); end

  def engine_script_name(_routes); end

  def engine_script_name=(name); end

  def from(); end

  def gateway_interface(); end

  def have_cookie_jar?(); end

  def http_auth_salt(); end

  def ignore_accept_header(); end

  def ignore_accept_header=(obj); end

  def key_generator(); end

  def method(); end

  def method_symbol(); end

  def negotiate(); end

  def origin(); end

  def original_script_name(); end

  def path_translated(); end

  def pragma(); end

  def query_parameters(); end

  def raw_post(); end

  def remote_addr(); end

  def remote_host(); end

  def remote_ident(); end

  def remote_ip=(remote_ip); end

  def remote_user(); end

  def request_id=(id); end

  def request_method=(request_method); end

  def request_method_symbol(); end

  def request_parameters(); end

  def request_parameters=(params); end

  def routes(); end

  def routes=(routes); end

  def secret_key_base(); end

  def send_early_hints(links); end

  def server_addr(); end

  def server_protocol(); end

  def server_software(); end

  def session=(session); end

  def session_options=(options); end

  def show_exceptions?(); end

  def signed_cookie_digest(); end

  def signed_cookie_salt(); end

  def use_authenticated_cookie_encryption(); end

  def use_cookies_with_metadata(); end

  def uuid(); end

  def version(); end

  def x_csrf_token(); end

  def x_forwarded_for(); end

  def x_forwarded_host(); end

  def x_request_id(); end

  def xml_http_request?(); end
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request
  def self.empty(); end

  def self.ignore_accept_header(); end

  def self.ignore_accept_header=(obj); end

  def self.parameter_parsers(); end
end

class ActionDispatch::RequestEncoder
  def accept_header(); end

  def content_type(); end

  def encode_params(params); end

  def initialize(mime_name, param_encoder, response_parser); end

  def response_parser(); end
end

class ActionDispatch::RequestEncoder::IdentityEncoder
  def accept_header(); end

  def content_type(); end

  def encode_params(params); end

  def response_parser(); end
end

class ActionDispatch::RequestEncoder::IdentityEncoder
end

class ActionDispatch::RequestEncoder
  def self.encoder(name); end

  def self.parser(content_type); end

  def self.register_encoder(mime_name, param_encoder: T.unsafe(nil), response_parser: T.unsafe(nil)); end
end

class ActionDispatch::RequestId
  def call(env); end

  def initialize(app); end
  X_REQUEST_ID = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RequestId
end

class ActionDispatch::Response
  include ::Rack::Response::Helpers
  include ::ActionDispatch::Http::FilterRedirect
  include ::ActionDispatch::Http::Cache::Response
  include ::MonitorMixin
  def [](*args, &block); end

  def []=(*args, &block); end

  def _cache_control(); end

  def _cache_control=(v); end

  def abort(); end

  def await_commit(); end

  def await_sent(); end

  def body(); end

  def body=(body); end

  def body_parts(); end

  def charset(); end

  def charset=(charset); end

  def close(); end

  def code(); end

  def commit!(); end

  def committed?(); end

  def cookies(); end

  def default_charset(); end

  def default_charset=(obj); end

  def default_headers(); end

  def default_headers=(obj); end

  def delete_header(key); end

  def each(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil)); end

  def message(); end

  def prepare!(); end

  def redirect_url(); end

  def request(); end

  def request=(request); end

  def reset_body!(); end

  def response_code(); end

  def return_only_media_type_on_content_type(); end

  def return_only_media_type_on_content_type=(obj); end

  def send_file(path); end

  def sending!(); end

  def sending?(); end

  def sending_file=(v); end

  def sent!(); end

  def sent?(); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def status_message(); end

  def stream(); end

  def to_a(); end

  def write(string); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE_PARSER = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  NullContentTypeHeader = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response::Buffer
  def abort(); end

  def body(); end

  def close(); end

  def closed?(); end

  def each(&block); end

  def initialize(response, buf); end

  def write(string); end
end

class ActionDispatch::Response::Buffer
end

class ActionDispatch::Response
  def self.create(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil), default_headers: T.unsafe(nil)); end

  def self.default_charset(); end

  def self.default_charset=(obj); end

  def self.default_headers(); end

  def self.default_headers=(obj); end

  def self.merge_default_headers(original, default); end

  def self.return_only_media_type_on_content_type(); end

  def self.return_only_media_type_on_content_type=(obj); end
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::ConsoleFormatter::Base
  def header(routes); end

  def no_routes(routes, filter); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter::Base
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded
end

class ActionDispatch::Routing::ConsoleFormatter::Expanded
end

class ActionDispatch::Routing::ConsoleFormatter::Sheet
end

class ActionDispatch::Routing::ConsoleFormatter::Sheet
end

module ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::Endpoint
  def app(); end

  def dispatcher?(); end

  def engine?(); end

  def matches?(req); end

  def rack_app(); end

  def redirect?(); end
end

class ActionDispatch::Routing::Endpoint
end

class ActionDispatch::Routing::HtmlTableFormatter
  def header(routes); end

  def initialize(view); end

  def no_routes(*_); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::HtmlTableFormatter
end

class ActionDispatch::Routing::Mapper
  include ::ActionDispatch::Routing::Mapper::Base
  include ::ActionDispatch::Routing::Mapper::HttpHelpers
  include ::ActionDispatch::Routing::Redirection
  include ::ActionDispatch::Routing::Mapper::Scoping
  include ::ActionDispatch::Routing::Mapper::Concerns
  include ::ActionDispatch::Routing::Mapper::Resources
  include ::ActionDispatch::Routing::Mapper::CustomUrls
  def initialize(set); end
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end

  def default_url_options=(options); end

  def has_named_route?(name); end

  def match(path, options=T.unsafe(nil)); end

  def mount(app, options=T.unsafe(nil)); end

  def with_default_scope(scope, &block); end
end

module ActionDispatch::Routing::Mapper::Base
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable=T.unsafe(nil), &block); end

  def concerns(*args); end
end

module ActionDispatch::Routing::Mapper::Concerns
end

class ActionDispatch::Routing::Mapper::Constraints
  def constraints(); end

  def initialize(app, constraints, strategy); end

  def serve(req); end
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Constraints
end

module ActionDispatch::Routing::Mapper::CustomUrls
  def direct(name, options=T.unsafe(nil), &block); end

  def resolve(*args, &block); end
end

module ActionDispatch::Routing::Mapper::CustomUrls
end

class ActionDispatch::Routing::Mapper::Mapping
  def application(); end

  def ast(); end

  def conditions(); end

  def default_action(); end

  def default_controller(); end

  def defaults(); end

  def initialize(set, ast, defaults, controller, default_action, modyoule, to, formatted, scope_constraints, scope_options, blocks, via, options_constraints, anchor, options); end

  def make_route(name, precedence); end

  def path(); end

  def required_defaults(); end

  def requirements(); end

  def scope_options(); end

  def to(); end
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  def self.build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end

  def self.check_via(via); end

  def self.normalize_path(path, format); end

  def self.optional_format?(path, format); end
end

module ActionDispatch::Routing::Mapper::Resources
  def nested(); end

  def new(); end

  def resources_path_names(options); end
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Resources::Resource
  def actions(); end

  def available_actions(); end

  def collection_name(); end

  def collection_scope(); end

  def controller(); end

  def default_actions(); end

  def initialize(entities, api_only, shallow, options=T.unsafe(nil)); end

  def member_name(); end

  def member_scope(); end

  def name(); end

  def nested_param(); end

  def nested_scope(); end

  def new_scope(new_path); end

  def param(); end

  def path(); end

  def plural(); end

  def resource_scope(); end

  def shallow?(); end

  def shallow_scope(); end

  def singleton?(); end

  def singular(); end
end

class ActionDispatch::Routing::Mapper::Resources::Resource
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
  def initialize(entities, api_only, shallow, options); end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
end

class ActionDispatch::Routing::Mapper::Scope
  include ::Enumerable
  def [](key); end

  def action_name(name_prefix, prefix, collection_name, member_name); end

  def each(&blk); end

  def frame(); end

  def initialize(hash, parent=T.unsafe(nil), scope_level=T.unsafe(nil)); end

  def nested?(); end

  def new(hash); end

  def new_level(level); end

  def null?(); end

  def options(); end

  def parent(); end

  def resource_method_scope?(); end

  def resource_scope?(); end

  def resources?(); end

  def root?(); end

  def scope_level(); end
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
end

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints=T.unsafe(nil)); end

  def controller(controller); end

  def defaults(defaults=T.unsafe(nil)); end

  def namespace(path, options=T.unsafe(nil)); end

  def scope(*args); end
  POISON = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
end

class ActionDispatch::Routing::Mapper
  def self.normalize_name(name); end

  def self.normalize_path(path); end
end

class ActionDispatch::Routing::OptionRedirect
  def options(); end
end

class ActionDispatch::Routing::OptionRedirect
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::PathRedirect
end

module ActionDispatch::Routing::PolymorphicRoutes
  def edit_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def edit_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def polymorphic_path(record_or_hash_or_array, options=T.unsafe(nil)); end

  def polymorphic_url(record_or_hash_or_array, options=T.unsafe(nil)); end
end

module ActionDispatch::Routing::PolymorphicRoutes
end

class ActionDispatch::Routing::Redirect
  def block(); end

  def call(env); end

  def initialize(status, block); end

  def path(params, request); end

  def serve(req); end

  def status(); end
end

class ActionDispatch::Routing::Redirect
end

module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end

module ActionDispatch::Routing::Redirection
end

class ActionDispatch::Routing::RouteSet
  def add_polymorphic_mapping(klass, options, &block); end

  def add_route(mapping, name); end

  def add_url_helper(name, options, &block); end

  def api_only?(); end

  def append(&block); end

  def call(env); end

  def clear!(); end

  def default_scope(); end

  def default_scope=(default_scope); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def define_mounted_helper(name, script_namer=T.unsafe(nil)); end

  def disable_clear_and_finalize(); end

  def disable_clear_and_finalize=(disable_clear_and_finalize); end

  def eager_load!(); end

  def empty?(); end

  def env_key(); end

  def extra_keys(options, recall=T.unsafe(nil)); end

  def finalize!(); end

  def find_relative_url_root(options); end

  def find_script_name(options); end

  def formatter(); end

  def formatter=(formatter); end

  def generate_extras(options, recall=T.unsafe(nil)); end

  def initialize(config=T.unsafe(nil)); end

  def mounted_helpers(); end

  def named_routes(); end

  def named_routes=(named_routes); end

  def optimize_routes_generation?(); end

  def path_for(options, route_name=T.unsafe(nil)); end

  def polymorphic_mappings(); end

  def prepend(&block); end

  def recognize_path(path, environment=T.unsafe(nil)); end

  def recognize_path_with_request(req, path, extras, raise_on_missing: T.unsafe(nil)); end

  def relative_url_root(); end

  def request_class(); end

  def resources_path_names(); end

  def resources_path_names=(resources_path_names); end

  def router(); end

  def router=(router); end

  def routes(); end

  def set(); end

  def set=(set); end

  def url_for(options, route_name=T.unsafe(nil), url_strategy=T.unsafe(nil)); end

  def url_helpers(supports_path=T.unsafe(nil)); end
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Config
  def api_only(); end

  def api_only=(_); end

  def relative_url_root(); end

  def relative_url_root=(_); end
end

class ActionDispatch::Routing::RouteSet::Config
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
  def block(); end

  def call(t, args, only_path=T.unsafe(nil)); end

  def defaults(); end

  def initialize(name, defaults, &block); end

  def name(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
end

class ActionDispatch::Routing::RouteSet::Dispatcher
  def initialize(raise_on_name_error); end

  def serve(req); end
end

class ActionDispatch::Routing::RouteSet::Dispatcher
end

class ActionDispatch::Routing::RouteSet::Generator
  def controller(); end

  def current_controller(); end

  def different_controller?(); end

  def generate(); end

  def initialize(named_route, options, recall, set); end

  def named_route(); end

  def normalize_controller!(); end

  def normalize_controller_action_id!(); end

  def normalize_options!(); end

  def options(); end

  def recall(); end

  def set(); end

  def use_recall_for(key); end

  def use_relative_controller!(); end
  PARAMETERIZE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Generator
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def _shopify_app(); end

  def main_app(); end

  def shopify_app(); end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include ::Enumerable
  def [](name); end

  def []=(name, route); end

  def add(name, route); end

  def add_url_helper(name, defaults, &block); end

  def clear(); end

  def clear!(); end

  def each(&blk); end

  def get(name); end

  def helper_names(); end

  def key?(name); end

  def length(); end

  def names(); end

  def path_helpers_module(); end

  def route_defined?(name); end

  def url_helpers_module(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def call(t, args, inner_options); end

  def handle_positional_args(controller_options, inner_options, args, result, path_params); end

  def initialize(route, options, route_name, url_strategy); end

  def route_name(); end

  def url_strategy(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
  def arg_size(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def self.create(route, options, route_name, url_strategy); end

  def self.optimize_helper?(route); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
  def initialize(controller_class); end
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
end

class ActionDispatch::Routing::RouteSet
  def self.default_resources_path_names(); end

  def self.new_with_config(config); end
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def action(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def constraints(); end

  def controller(); end

  def endpoint(); end

  def engine?(); end

  def name(); end

  def path(); end

  def rack_app(); end

  def reqs(); end
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Routing::RoutesInspector
  def format(formatter, filter=T.unsafe(nil)); end

  def initialize(routes); end
end

class ActionDispatch::Routing::RoutesInspector
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def full_url_for(options=T.unsafe(nil)); end

  def initialize(*_); end

  def optimize_routes_generation?(); end

  def route_for(name, *args); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionDispatch::Routing::UrlFor
  extend ::ActiveSupport::Concern
end

module ActionDispatch::Routing
  extend ::ActiveSupport::Autoload
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

module ActionDispatch::Session
end

class ActionDispatch::Session::AbstractSecureStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractSecureStore
end

class ActionDispatch::Session::AbstractStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractStore
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  def generate_sid(); end

  def initialize(app, options=T.unsafe(nil)); end
end

module ActionDispatch::Session::Compatibility
end

class ActionDispatch::Session::CookieStore
  def delete_session(req, session_id, options); end

  def load_session(req); end
end

class ActionDispatch::Session::CookieStore::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value=T.unsafe(nil)); end
end

class ActionDispatch::Session::CookieStore::SessionId
end

class ActionDispatch::Session::CookieStore
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end

  def prepare_session(req); end
end

module ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::SessionRestoreError
  def initialize(); end
end

class ActionDispatch::Session::SessionRestoreError
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end

  def load_session(env); end

  def stale_session_check!(); end
end

module ActionDispatch::Session::StaleSessionCheck
end

module ActionDispatch::Session
end

class ActionDispatch::ShowExceptions
  def call(env); end

  def initialize(app, exceptions_app); end
  FAILSAFE_RESPONSE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ShowExceptions
end

class ActionDispatch::Static
  def call(env); end

  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end
end

class ActionDispatch::Static
end

module ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def assigns(key=T.unsafe(nil)); end

  def cookies(); end

  def flash(); end

  def redirect_to_url(); end

  def session(); end
end

module ActionDispatch::TestProcess::FixtureFile
  def fixture_file_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end
end

module ActionDispatch::TestProcess::FixtureFile
end

module ActionDispatch::TestProcess
end

class ActionDispatch::TestRequest
  def accept=(mime_types); end

  def action=(action_name); end

  def host=(host); end

  def if_modified_since=(last_modified); end

  def if_none_match=(etag); end

  def path=(path); end

  def port=(number); end

  def remote_addr=(addr); end

  def request_method=(method); end

  def request_uri=(uri); end

  def user_agent=(user_agent); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestRequest
  def self.create(env=T.unsafe(nil)); end
end

class ActionDispatch::TestResponse
  def parsed_body(); end

  def response_parser(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

module ActionDispatch
  extend ::ActiveSupport::Autoload
  def self.test_app(); end

  def self.test_app=(obj); end
end

module ActionMailbox
  def incinerate(); end

  def incinerate=(obj); end

  def incinerate_after(); end

  def incinerate_after=(obj); end

  def ingress(); end

  def ingress=(obj); end

  def logger(); end

  def logger=(obj); end

  def queues(); end

  def queues=(obj); end
end

class ActionMailbox::Base
  include ::ActiveSupport::Rescuable
  include ::ActionMailbox::Routing
  include ::ActiveSupport::Callbacks
  include ::ActionMailbox::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _process_callbacks(); end

  def _run_process_callbacks(&block); end

  def bounce_with(message); end

  def bounced!(*args, &block); end

  def delivered!(*args, &block); end

  def finished_processing?(); end

  def inbound_email(); end

  def initialize(inbound_email); end

  def logger(*args, &block); end

  def mail(*args, &block); end

  def perform_processing(); end

  def process(); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def router(); end

  def router=(obj); end
end

class ActionMailbox::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._process_callbacks(); end

  def self._process_callbacks=(value); end

  def self.receive(inbound_email); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.router(); end

  def self.router=(obj); end
end

module ActionMailbox::Callbacks
  TERMINATOR = ::T.let(nil, ::T.untyped)
end

module ActionMailbox::Callbacks
  extend ::ActiveSupport::Concern
end

class ActionMailbox::Engine
end

class ActionMailbox::Engine
end

class ActionMailbox::Router
  def add_route(address, to:); end

  def add_routes(routes); end

  def route(inbound_email); end
end

class ActionMailbox::Router::Route
  def address(); end

  def initialize(address, to:); end

  def mailbox_class(); end

  def mailbox_name(); end

  def match?(inbound_email); end
end

class ActionMailbox::Router::Route
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router
end

module ActionMailbox::Routing
end

module ActionMailbox::Routing
  extend ::ActiveSupport::Concern
end

class ActionMailbox::TestCase
  include ::ActionMailbox::TestHelper
end

class ActionMailbox::TestCase
end

module ActionMailbox::TestHelper
  def create_inbound_email_from_fixture(fixture_name, status: T.unsafe(nil)); end

  def create_inbound_email_from_mail(status: T.unsafe(nil), **mail_options); end

  def create_inbound_email_from_source(source, status: T.unsafe(nil)); end

  def receive_inbound_email_from_fixture(*args); end

  def receive_inbound_email_from_mail(**kwargs); end

  def receive_inbound_email_from_source(*args); end
end

module ActionMailbox::TestHelper
end

module ActionMailbox
  extend ::ActiveSupport::Autoload
  def self.incinerate(); end

  def self.incinerate=(obj); end

  def self.incinerate_after(); end

  def self.incinerate_after=(obj); end

  def self.ingress(); end

  def self.ingress=(obj); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.queues(); end

  def self.queues=(obj); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class ActionMailer::Base
  include ::ActionMailer::DeliveryMethods
  include ::ActiveSupport::Rescuable
  include ::ActionMailer::Rescuable
  include ::ActionMailer::Parameterized
  include ::ActionMailer::Previews
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::AbstractController::Helpers
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(val); end

  def _view_cache_dependencies?(); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def attachments(); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_params(); end

  def default_params=(val); end

  def default_params?(); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def deliver_later_queue_name(); end

  def deliver_later_queue_name=(obj); end

  def delivery_job(); end

  def delivery_job=(val); end

  def delivery_job?(); end

  def delivery_method(); end

  def delivery_method=(val); end

  def delivery_method?(); end

  def delivery_methods(); end

  def delivery_methods=(val); end

  def delivery_methods?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def file_settings(); end

  def file_settings=(val); end

  def file_settings?(); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(val); end

  def fragment_cache_keys?(); end

  def headers(args=T.unsafe(nil)); end

  def initialize(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def logger(); end

  def logger=(value); end

  def mailer_name(); end

  def message(); end

  def message=(message); end

  def params(); end

  def params=(params); end

  def perform_caching(); end

  def perform_caching=(value); end

  def perform_deliveries(); end

  def perform_deliveries=(obj); end

  def preview_interceptors(); end

  def preview_path(); end

  def process(method_name, *args); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(obj); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def sendmail_settings(); end

  def sendmail_settings=(val); end

  def sendmail_settings?(); end

  def show_previews(); end

  def smtp_settings(); end

  def smtp_settings=(val); end

  def smtp_settings?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def test_settings(); end

  def test_settings=(val); end

  def test_settings?(); end
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base::LateAttachmentsProxy
  def []=(_name, _content); end

  def inline(); end
end

class ActionMailer::Base::LateAttachmentsProxy
end

class ActionMailer::Base::NullMail
  def body(); end

  def header(); end

  def method_missing(*args); end

  def respond_to?(string, include_all=T.unsafe(nil)); end
end

class ActionMailer::Base::NullMail
end

class ActionMailer::Base
  extend ::ActionMailer::DeliveryMethods::ClassMethods
  extend ::ActionMailer::Parameterized::ClassMethods
  extend ::ActionMailer::Previews::ClassMethods
  extend ::AbstractController::Helpers::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::AbstractController::UrlFor::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default(value=T.unsafe(nil)); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_options=(value=T.unsafe(nil)); end

  def self.default_params(); end

  def self.default_params=(val); end

  def self.default_params?(); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.deliver_later_queue_name(); end

  def self.deliver_later_queue_name=(obj); end

  def self.deliver_mail(mail); end

  def self.delivery_job(); end

  def self.delivery_job=(val); end

  def self.delivery_job?(); end

  def self.delivery_method(); end

  def self.delivery_method=(val); end

  def self.delivery_method?(); end

  def self.delivery_methods(); end

  def self.delivery_methods=(val); end

  def self.delivery_methods?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.file_settings(); end

  def self.file_settings=(val); end

  def self.file_settings?(); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(val); end

  def self.fragment_cache_keys?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mailer_name(); end

  def self.mailer_name=(mailer_name); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.perform_deliveries(); end

  def self.perform_deliveries=(obj); end

  def self.preview_interceptors(); end

  def self.preview_interceptors=(obj); end

  def self.preview_path(); end

  def self.preview_path=(obj); end

  def self.raise_delivery_errors(); end

  def self.raise_delivery_errors=(obj); end

  def self.receive(raw_mail); end

  def self.register_interceptor(interceptor); end

  def self.register_interceptors(*interceptors); end

  def self.register_observer(observer); end

  def self.register_observers(*observers); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.sendmail_settings(); end

  def self.sendmail_settings=(val); end

  def self.sendmail_settings?(); end

  def self.show_previews(); end

  def self.show_previews=(obj); end

  def self.smtp_settings(); end

  def self.smtp_settings=(val); end

  def self.smtp_settings?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.test_settings(); end

  def self.test_settings=(val); end

  def self.test_settings?(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_interceptors(*interceptors); end

  def self.unregister_observer(observer); end

  def self.unregister_observers(*observers); end
end

class ActionMailer::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime, options=T.unsafe(nil)); end

  def initialize(context, &block); end

  def responses(); end
end

class ActionMailer::Collector
end

class ActionMailer::DeliveryJob
  def perform(mailer, mail_method, delivery_method, *args); end
end

class ActionMailer::DeliveryJob
end

module ActionMailer::DeliveryMethods
  def wrap_delivery_behavior!(*args); end
end

module ActionMailer::DeliveryMethods::ClassMethods
  def add_delivery_method(symbol, klass, default_options=T.unsafe(nil)); end

  def deliveries(*args, &block); end

  def deliveries=(arg); end

  def wrap_delivery_behavior(mail, method=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionMailer::DeliveryMethods::ClassMethods
end

module ActionMailer::DeliveryMethods
  extend ::ActiveSupport::Concern
end

class ActionMailer::InlinePreviewInterceptor
  include ::Base64
  def initialize(message); end

  def transform!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  def self.previewing_email(message); end
end

class ActionMailer::MailDeliveryJob
  def perform(mailer, mail_method, delivery_method, args:, params: T.unsafe(nil)); end
end

class ActionMailer::MailDeliveryJob
end

module ActionMailer::MailHelper
  def attachments(); end

  def block_format(text); end

  def format_paragraph(text, len=T.unsafe(nil), indent=T.unsafe(nil)); end

  def mailer(); end

  def message(); end
end

module ActionMailer::MailHelper
end

class ActionMailer::MessageDelivery
  def __setobj__(mail_message); end

  def deliver_later(options=T.unsafe(nil)); end

  def deliver_later!(options=T.unsafe(nil)); end

  def deliver_now(); end

  def deliver_now!(); end

  def initialize(mailer_class, action, *args); end

  def message(); end

  def processed?(); end
end

class ActionMailer::MessageDelivery
end

class ActionMailer::NonInferrableMailerError
  def initialize(name); end
end

class ActionMailer::NonInferrableMailerError
end

module ActionMailer::Parameterized
end

module ActionMailer::Parameterized::ClassMethods
  def with(params); end
end

module ActionMailer::Parameterized::ClassMethods
end

class ActionMailer::Parameterized::DeliveryJob
  def perform(mailer, mail_method, delivery_method, params, *args); end
end

class ActionMailer::Parameterized::DeliveryJob
end

class ActionMailer::Parameterized::Mailer
  def initialize(mailer, params); end
end

class ActionMailer::Parameterized::Mailer
end

class ActionMailer::Parameterized::MessageDelivery
  def initialize(mailer_class, action, params, *args); end
end

class ActionMailer::Parameterized::MessageDelivery
end

module ActionMailer::Parameterized
  extend ::ActiveSupport::Concern
end

class ActionMailer::Preview
  def initialize(params=T.unsafe(nil)); end

  def params(); end
end

class ActionMailer::Preview
  extend ::ActiveSupport::DescendantsTracker
  def self.all(); end

  def self.call(email, params=T.unsafe(nil)); end

  def self.email_exists?(email); end

  def self.emails(); end

  def self.exists?(preview); end

  def self.find(preview); end

  def self.preview_name(); end
end

module ActionMailer::Previews
end

module ActionMailer::Previews::ClassMethods
  def register_preview_interceptor(interceptor); end

  def register_preview_interceptors(*interceptors); end

  def unregister_preview_interceptor(interceptor); end

  def unregister_preview_interceptors(*interceptors); end
end

module ActionMailer::Previews::ClassMethods
end

module ActionMailer::Previews
  extend ::ActiveSupport::Concern
end

class ActionMailer::Railtie
end

class ActionMailer::Railtie
end

module ActionMailer::Rescuable
  def handle_exceptions(); end
end

module ActionMailer::Rescuable
  extend ::ActiveSupport::Concern
end

class ActionMailer::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  def _mailer_class(); end

  def _mailer_class=(val); end

  def _mailer_class?(); end
end

module ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
end

module ActionMailer::TestCase::Behavior::ClassMethods
  def determine_default_mailer(name); end

  def mailer_class(); end

  def tests(mailer); end
end

module ActionMailer::TestCase::Behavior::ClassMethods
end

module ActionMailer::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

module ActionMailer::TestCase::ClearTestDeliveries
end

module ActionMailer::TestCase::ClearTestDeliveries
  extend ::ActiveSupport::Concern
end

class ActionMailer::TestCase
  extend ::ActionMailer::TestCase::Behavior::ClassMethods
  def self._mailer_class(); end

  def self._mailer_class=(val); end

  def self._mailer_class?(); end
end

module ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  def assert_emails(number, &block); end

  def assert_enqueued_email_with(mailer, method, args: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_enqueued_emails(number, &block); end

  def assert_no_emails(&block); end

  def assert_no_enqueued_emails(&block); end
end

module ActionMailer::TestHelper
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionMailer::VERSION
end

module ActionMailer
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActionPack
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
end

module ActionPack
  def self.gem_version(); end

  def self.version(); end
end

module ActionText
end

module ActionText::Attachable
  def as_json(*_); end

  def attachable_content_type(); end

  def attachable_filename(); end

  def attachable_filesize(); end

  def attachable_metadata(); end

  def attachable_sgid(); end

  def previewable_attachable?(); end

  def to_rich_text_attributes(attributes=T.unsafe(nil)); end

  def to_trix_content_attachment_partial_path(); end
  LOCATOR_NAME = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable::ClassMethods
  def from_attachable_sgid(sgid); end
end

module ActionText::Attachable::ClassMethods
end

module ActionText::Attachable
  extend ::ActiveSupport::Concern
  def self.from_attachable_sgid(sgid, options=T.unsafe(nil)); end

  def self.from_node(node); end
end

module ActionText::Attachables
end

class ActionText::Attachables::ContentAttachment
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachable_plain_text_representation(caption); end

  def model_name(*args, &block); end

  def name(); end

  def name=(name); end

  def to_trix_content_attachment_partial_path(); end

  def validation_context(); end
end

class ActionText::Attachables::ContentAttachment
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.from_node(node); end
end

module ActionText::Attachables::MissingAttachable
  def model_name(*args, &block); end
end

module ActionText::Attachables::MissingAttachable
  extend ::ActiveModel::Naming
  def self.to_partial_path(); end
end

class ActionText::Attachables::RemoteImage
  def attachable_plain_text_representation(caption); end

  def content_type(); end

  def height(); end

  def initialize(attributes=T.unsafe(nil)); end

  def model_name(*args, &block); end

  def to_partial_path(); end

  def url(); end

  def width(); end
end

class ActionText::Attachables::RemoteImage
  extend ::ActiveModel::Naming
  def self.from_node(node); end
end

module ActionText::Attachables
  extend ::ActiveSupport::Autoload
end

class ActionText::Attachment
  include ::ActionText::Attachments::Caching
  include ::ActionText::Attachments::Minification
  include ::ActionText::Attachments::TrixConversion
  def attachable(); end

  def caption(); end

  def full_attributes(); end

  def initialize(node, attachable); end

  def method_missing(method, *args, &block); end

  def node(); end

  def to_html(); end

  def to_param(*args, &block); end

  def to_plain_text(); end

  def with_full_attributes(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::Attachment
  def self.fragment_by_canonicalizing_attachments(content); end

  def self.from_attachable(attachable, attributes=T.unsafe(nil)); end

  def self.from_attachables(attachables); end

  def self.from_attributes(attributes, attachable=T.unsafe(nil)); end

  def self.from_node(node, attachable=T.unsafe(nil)); end
end

class ActionText::AttachmentGallery
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attachments(); end

  def initialize(node); end

  def model_name(*args, &block); end

  def node(); end

  def size(); end

  def validation_context(); end
end

class ActionText::AttachmentGallery
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.find_attachment_gallery_nodes(content); end

  def self.fragment_by_canonicalizing_attachment_galleries(content); end

  def self.fragment_by_replacing_attachment_gallery_nodes(content); end

  def self.from_node(node); end
end

module ActionText::Attachments
end

module ActionText::Attachments::Caching
  def cache_key(*args); end
end

module ActionText::Attachments::Caching
end

module ActionText::Attachments::Minification
end

module ActionText::Attachments::Minification
  extend ::ActiveSupport::Concern
end

module ActionText::Attachments::TrixConversion
  def to_trix_attachment(content=T.unsafe(nil)); end
end

module ActionText::Attachments::TrixConversion
  extend ::ActiveSupport::Concern
end

module ActionText::Attachments
  extend ::ActiveSupport::Autoload
end

module ActionText::Attribute
end

module ActionText::Attribute::ClassMethods
  def has_rich_text(name); end
end

module ActionText::Attribute::ClassMethods
end

module ActionText::Attribute
  extend ::ActiveSupport::Concern
end

class ActionText::Content
  include ::ActionText::Serialization
  def ==(other); end

  def append_attachables(attachables); end

  def as_json(*_); end

  def attachables(); end

  def attachment_galleries(); end

  def attachments(); end

  def blank?(*args, &block); end

  def empty?(*args, &block); end

  def fragment(); end

  def gallery_attachments(); end

  def html_safe(*args, &block); end

  def initialize(content=T.unsafe(nil), options=T.unsafe(nil)); end

  def links(); end

  def present?(*args, &block); end

  def render_attachment_galleries(&block); end

  def render_attachments(**options, &block); end

  def renderer(); end

  def renderer=(obj); end

  def to_html(); end

  def to_plain_text(); end

  def to_rendered_html_with_layout(); end

  def to_trix_html(); end
end

class ActionText::Content
  extend ::ActionText::Serialization::ClassMethods
  def self.fragment_by_canonicalizing_content(content); end

  def self.renderer(); end

  def self.renderer=(obj); end
end

module ActionText::ContentHelper
  def allowed_attributes(); end

  def allowed_attributes=(obj); end

  def allowed_tags(); end

  def allowed_tags=(obj); end

  def render_action_text_attachments(content); end

  def render_action_text_content(content); end

  def sanitize_action_text_content(content); end

  def sanitizer(); end

  def sanitizer=(obj); end

  def scrubber(); end

  def scrubber=(obj); end
end

module ActionText::ContentHelper
  def self.allowed_attributes(); end

  def self.allowed_attributes=(obj); end

  def self.allowed_tags(); end

  def self.allowed_tags=(obj); end

  def self.sanitizer(); end

  def self.sanitizer=(obj); end

  def self.scrubber(); end

  def self.scrubber=(obj); end
end

class ActionText::Engine
end

class ActionText::Engine
end

class ActionText::Fragment
  def find_all(selector); end

  def initialize(source); end

  def replace(selector); end

  def source(); end

  def to_html(); end

  def to_plain_text(); end

  def update(); end
end

class ActionText::Fragment
  def self.from_html(html); end

  def self.wrap(fragment_or_html); end
end

module ActionText::HtmlConversion
  def create_element(tag_name, attributes=T.unsafe(nil)); end

  def fragment_for_html(html); end

  def node_to_html(node); end
end

module ActionText::HtmlConversion
  extend ::ActionText::HtmlConversion
end

module ActionText::PlainTextConversion
  def node_to_plain_text(node); end
end

module ActionText::PlainTextConversion
  extend ::ActionText::PlainTextConversion
end

module ActionText::Serialization
  def _dump(*_); end
end

module ActionText::Serialization::ClassMethods
  def _load(content); end

  def dump(content); end

  def load(content); end
end

module ActionText::Serialization::ClassMethods
end

module ActionText::Serialization
  extend ::ActiveSupport::Concern
end

module ActionText::TagHelper
  def rich_text_area_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionText::TagHelper
  def self.id(); end

  def self.id=(obj); end
end

class ActionText::TrixAttachment
  def attributes(); end

  def initialize(node); end

  def node(); end

  def to_html(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
  COMPOSED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::TrixAttachment
  def self.from_attributes(attributes); end
end

module ActionText
  extend ::ActiveSupport::Autoload
  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer
  def any_templates?(*args, &block); end

  def formats(*args, &block); end

  def initialize(lookup_context); end

  def render(); end

  def template_exists?(*args, &block); end
end

class ActionView::AbstractRenderer::RenderedCollection
  def body(); end

  def format(); end

  def initialize(rendered_templates, spacer); end

  def rendered_templates(); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
  def body(); end

  def format(); end

  def initialize(format); end
end

class ActionView::AbstractRenderer::RenderedCollection::EmptyCollection
end

class ActionView::AbstractRenderer::RenderedCollection
  def self.empty(format); end
end

class ActionView::AbstractRenderer::RenderedTemplate
  def body(); end

  def format(); end

  def initialize(body, layout, template); end

  def layout(); end

  def template(); end
  EMPTY_SPACER = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer::RenderedTemplate
end

class ActionView::AbstractRenderer
end

class ActionView::Base
  include ::ActionView::Context
  include ::ERB::Util
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionCable::Helpers::ActionCableHelper
  include ::Sprockets::Rails::Helper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::Sprockets::Rails::Utils
  def _routes(); end

  def _routes=(val); end

  def _routes?(); end

  def _run(method, template, locals, buffer, &block); end

  def assets_environment(); end

  def assets_environment=(val); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(val); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(val); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def assign(new_assigns); end

  def assigns(); end

  def assigns=(assigns); end

  def automatically_disable_submit_tag(); end

  def automatically_disable_submit_tag=(obj); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(val); end

  def check_precompiled_asset?(); end

  def compiled_method_container(); end

  def config(); end

  def config=(config); end

  def debug_assets(); end

  def debug_assets=(val); end

  def debug_assets?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end

  def default_formats(); end

  def default_formats=(obj); end

  def digest_assets(); end

  def digest_assets=(val); end

  def digest_assets?(); end

  def field_error_proc(); end

  def field_error_proc=(obj); end

  def formats(*args, &block); end

  def formats=(arg); end

  def in_rendering_context(options); end

  def initialize(lookup_context=T.unsafe(nil), assigns=T.unsafe(nil), controller=T.unsafe(nil), formats=T.unsafe(nil)); end

  def locale(*args, &block); end

  def locale=(arg); end

  def logger=(val); end

  def logger?(); end

  def lookup_context(); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(val); end

  def precompiled_asset_checker?(); end

  def prefix_partial_path_with_controller_namespace(); end

  def prefix_partial_path_with_controller_namespace=(obj); end

  def raise_on_missing_translations(); end

  def raise_on_missing_translations=(obj); end

  def resolve_assets_with(); end

  def resolve_assets_with=(val); end

  def resolve_assets_with?(); end

  def streaming_completion_on_exception(); end

  def streaming_completion_on_exception=(obj); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(val); end

  def unknown_asset_fallback?(); end

  def view_paths(*args, &block); end

  def view_paths=(arg); end

  def view_renderer(); end
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  def self._routes(); end

  def self._routes=(val); end

  def self._routes?(); end

  def self.assets_environment(); end

  def self.assets_environment=(val); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(val); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(val); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end

  def self.automatically_disable_submit_tag(); end

  def self.automatically_disable_submit_tag=(obj); end

  def self.build_lookup_context(context); end

  def self.cache_template_loading(); end

  def self.cache_template_loading=(value); end

  def self.changed?(other); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(val); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(val); end

  def self.debug_assets?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end

  def self.default_form_builder(); end

  def self.default_form_builder=(obj); end

  def self.default_formats(); end

  def self.default_formats=(obj); end

  def self.digest_assets(); end

  def self.digest_assets=(val); end

  def self.digest_assets?(); end

  def self.empty(); end

  def self.erb_trim_mode=(arg); end

  def self.field_error_proc(); end

  def self.field_error_proc=(obj); end

  def self.logger(); end

  def self.logger=(val); end

  def self.logger?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(val); end

  def self.precompiled_asset_checker?(); end

  def self.prefix_partial_path_with_controller_namespace(); end

  def self.prefix_partial_path_with_controller_namespace=(obj); end

  def self.raise_on_missing_translations(); end

  def self.raise_on_missing_translations=(obj); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(val); end

  def self.resolve_assets_with?(); end

  def self.streaming_completion_on_exception(); end

  def self.streaming_completion_on_exception=(obj); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(val); end

  def self.unknown_asset_fallback?(); end

  def self.with_context(context, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.with_empty_template_cache(); end

  def self.with_view_paths(view_paths, assigns=T.unsafe(nil), controller=T.unsafe(nil)); end

  def self.xss_safe?(); end
end

class ActionView::CacheExpiry
  def clear_cache(); end

  def clear_cache_if_necessary(); end

  def initialize(watcher:); end
end

class ActionView::CacheExpiry::Executor
  def before(target); end

  def initialize(watcher:); end
end

class ActionView::CacheExpiry::Executor
end

class ActionView::CacheExpiry
end

module ActionView::CollectionCaching
end

module ActionView::CollectionCaching
  extend ::ActiveSupport::Concern
end

module ActionView::Context
  def _layout_for(name=T.unsafe(nil)); end

  def _prepare_context(); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def view_flow(); end

  def view_flow=(view_flow); end
end

module ActionView::Context
end

class ActionView::DependencyTracker
end

class ActionView::DependencyTracker::ERBTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::ERBTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end

  def self.supports_view_paths?(); end
end

class ActionView::DependencyTracker
  def self.find_dependencies(name, template, view_paths=T.unsafe(nil)); end

  def self.register_tracker(extension, tracker); end

  def self.remove_tracker(handler); end
end

class ActionView::Digestor
end

class ActionView::Digestor::Injected
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Injected
end

class ActionView::Digestor::Missing
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Missing
end

class ActionView::Digestor::Node
  def children(); end

  def dependency_digest(finder, stack); end

  def digest(finder, stack=T.unsafe(nil)); end

  def initialize(name, logical_name, template, children=T.unsafe(nil)); end

  def logical_name(); end

  def name(); end

  def template(); end

  def to_dep_map(); end
end

class ActionView::Digestor::Node
  def self.create(name, logical_name, template, partial); end
end

class ActionView::Digestor::NullLogger
end

class ActionView::Digestor::NullLogger
  def self.debug(_); end

  def self.error(_); end
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor
  def self.digest(name:, finder:, format: T.unsafe(nil), dependencies: T.unsafe(nil)); end

  def self.logger(); end

  def self.tree(name, finder, partial=T.unsafe(nil), seen=T.unsafe(nil)); end
end

class ActionView::FallbackFileSystemResolver
  def build_unbound_template(template, _); end
end

class ActionView::FallbackFileSystemResolver
  def self.instances(); end
end

class ActionView::FileSystemResolver
  def ==(resolver); end

  def eql?(resolver); end

  def initialize(path, pattern=T.unsafe(nil)); end

  def path(); end

  def to_path(); end
end

class ActionView::FileSystemResolver
end

module ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def audio_tag(*sources); end

  def auto_discovery_link_tag(type=T.unsafe(nil), url_options=T.unsafe(nil), tag_options=T.unsafe(nil)); end

  def favicon_link_tag(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_tag(source, options=T.unsafe(nil)); end

  def javascript_include_tag(*sources); end

  def preload_link_tag(source, options=T.unsafe(nil)); end

  def stylesheet_link_tag(*sources); end

  def video_tag(*sources); end
end

module ActionView::Helpers::AssetTagHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::AssetUrlHelper
  def asset_path(source, options=T.unsafe(nil)); end

  def asset_url(source, options=T.unsafe(nil)); end

  def audio_path(source, options=T.unsafe(nil)); end

  def audio_url(source, options=T.unsafe(nil)); end

  def compute_asset_extname(source, options=T.unsafe(nil)); end

  def compute_asset_host(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def compute_asset_path(source, options=T.unsafe(nil)); end

  def font_path(source, options=T.unsafe(nil)); end

  def font_url(source, options=T.unsafe(nil)); end

  def image_path(source, options=T.unsafe(nil)); end

  def image_url(source, options=T.unsafe(nil)); end

  def javascript_path(source, options=T.unsafe(nil)); end

  def javascript_url(source, options=T.unsafe(nil)); end

  def path_to_asset(source, options=T.unsafe(nil)); end

  def path_to_audio(source, options=T.unsafe(nil)); end

  def path_to_font(source, options=T.unsafe(nil)); end

  def path_to_image(source, options=T.unsafe(nil)); end

  def path_to_javascript(source, options=T.unsafe(nil)); end

  def path_to_stylesheet(source, options=T.unsafe(nil)); end

  def path_to_video(source, options=T.unsafe(nil)); end

  def public_compute_asset_path(source, options=T.unsafe(nil)); end

  def stylesheet_path(source, options=T.unsafe(nil)); end

  def stylesheet_url(source, options=T.unsafe(nil)); end

  def url_to_asset(source, options=T.unsafe(nil)); end

  def url_to_audio(source, options=T.unsafe(nil)); end

  def url_to_font(source, options=T.unsafe(nil)); end

  def url_to_image(source, options=T.unsafe(nil)); end

  def url_to_javascript(source, options=T.unsafe(nil)); end

  def url_to_stylesheet(source, options=T.unsafe(nil)); end

  def url_to_video(source, options=T.unsafe(nil)); end

  def video_path(source, options=T.unsafe(nil)); end

  def video_url(source, options=T.unsafe(nil)); end
  ASSET_EXTENSIONS = ::T.let(nil, ::T.untyped)
  ASSET_PUBLIC_DIRECTORIES = ::T.let(nil, ::T.untyped)
  URI_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetUrlHelper
end

module ActionView::Helpers::AtomFeedHelper
  def atom_feed(options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::AtomFeedHelper
end

module ActionView::Helpers::CacheHelper
  def cache(name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_fragment_name(name=T.unsafe(nil), skip_digest: T.unsafe(nil), virtual_path: T.unsafe(nil), digest_path: T.unsafe(nil)); end

  def cache_if(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_unless(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def digest_path_from_template(template); end
end

module ActionView::Helpers::CacheHelper
end

module ActionView::Helpers::CaptureHelper
  def capture(*args); end

  def content_for(name, content=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def content_for?(name); end

  def provide(name, content=T.unsafe(nil), &block); end

  def with_output_buffer(buf=T.unsafe(nil)); end
end

module ActionView::Helpers::CaptureHelper
end

module ActionView::Helpers::ControllerHelper
  def action_name(*args, &block); end

  def assign_controller(controller); end

  def controller(); end

  def controller=(controller); end

  def controller_name(*args, &block); end

  def controller_path(*args, &block); end

  def cookies(*args, &block); end

  def flash(*args, &block); end

  def headers(*args, &block); end

  def logger(); end

  def params(*args, &block); end

  def request(); end

  def request=(request); end

  def request_forgery_protection_token(*args, &block); end

  def respond_to?(method_name, include_private=T.unsafe(nil)); end

  def response(*args, &block); end

  def session(*args, &block); end
  CONTROLLER_DELEGATES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::ControllerHelper
end

module ActionView::Helpers::CspHelper
  def csp_meta_tag(**options); end
end

module ActionView::Helpers::CspHelper
end

module ActionView::Helpers::CsrfHelper
  def csrf_meta_tag(); end

  def csrf_meta_tags(); end
end

module ActionView::Helpers::CsrfHelper
end

module ActionView::Helpers::DateHelper
  def date_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def distance_of_time_in_words(from_time, to_time=T.unsafe(nil), options=T.unsafe(nil)); end

  def distance_of_time_in_words_to_now(from_time, options=T.unsafe(nil)); end

  def select_date(date=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_datetime(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_day(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_hour(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_minute(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_month(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_second(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_time(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_year(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_ago_in_words(from_time, options=T.unsafe(nil)); end

  def time_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_tag(date_or_time, *args, &block); end
  MINUTES_IN_QUARTER_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_THREE_QUARTERS_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_YEAR = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::DateHelper
end

module ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def debug(object); end
end

module ActionView::Helpers::DebugHelper
end

module ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def check_box(object_name, method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def color_field(object_name, method, options=T.unsafe(nil)); end

  def date_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_local_field(object_name, method, options=T.unsafe(nil)); end

  def default_form_builder(); end

  def default_form_builder=(default_form_builder); end

  def email_field(object_name, method, options=T.unsafe(nil)); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field(object_name, method, options=T.unsafe(nil)); end

  def form_for(record, options=T.unsafe(nil), &block); end

  def form_with(model: T.unsafe(nil), scope: T.unsafe(nil), url: T.unsafe(nil), format: T.unsafe(nil), **options, &block); end

  def form_with_generates_ids(); end

  def form_with_generates_ids=(obj); end

  def form_with_generates_remote_forms(); end

  def form_with_generates_remote_forms=(obj); end

  def hidden_field(object_name, method, options=T.unsafe(nil)); end

  def label(object_name, method, content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(object_name, method, options=T.unsafe(nil)); end

  def number_field(object_name, method, options=T.unsafe(nil)); end

  def password_field(object_name, method, options=T.unsafe(nil)); end

  def phone_field(object_name, method, options=T.unsafe(nil)); end

  def radio_button(object_name, method, tag_value, options=T.unsafe(nil)); end

  def range_field(object_name, method, options=T.unsafe(nil)); end

  def rich_text_area(object_name, method, options=T.unsafe(nil)); end

  def search_field(object_name, method, options=T.unsafe(nil)); end

  def telephone_field(object_name, method, options=T.unsafe(nil)); end

  def text_area(object_name, method, options=T.unsafe(nil)); end

  def text_field(object_name, method, options=T.unsafe(nil)); end

  def time_field(object_name, method, options=T.unsafe(nil)); end

  def url_field(object_name, method, options=T.unsafe(nil)); end

  def week_field(object_name, method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormHelper
  extend ::ActiveSupport::Concern
  def self.form_with_generates_ids(); end

  def self.form_with_generates_ids=(obj); end

  def self.form_with_generates_remote_forms(); end

  def self.form_with_generates_remote_forms=(obj); end
end

module ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def collection_check_boxes(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_options_for_select(grouped_options, selected_key=T.unsafe(nil), options=T.unsafe(nil)); end

  def option_groups_from_collection_for_select(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key=T.unsafe(nil)); end

  def options_for_select(container, selected=T.unsafe(nil)); end

  def options_from_collection_for_select(collection, value_method, text_method, selected=T.unsafe(nil)); end

  def select(object, method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def time_zone_options_for_select(selected=T.unsafe(nil), priority_zones=T.unsafe(nil), model=T.unsafe(nil)); end

  def time_zone_select(object, method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormOptionsHelper
end

module ActionView::Helpers::FormTagHelper
  def button_tag(content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box_tag(name, value=T.unsafe(nil), checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def color_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def date_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_local_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def default_enforce_utf8(); end

  def default_enforce_utf8=(obj); end

  def email_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def embed_authenticity_token_in_remote_forms(); end

  def embed_authenticity_token_in_remote_forms=(obj); end

  def field_set_tag(legend=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field_tag(name, options=T.unsafe(nil)); end

  def form_tag(url_for_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def hidden_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_submit_tag(source, options=T.unsafe(nil)); end

  def label_tag(name=T.unsafe(nil), content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def number_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def password_field_tag(name=T.unsafe(nil), value=T.unsafe(nil), options=T.unsafe(nil)); end

  def phone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def radio_button_tag(name, value, checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def range_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_tag(name, option_tags=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_tag(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_area_tag(name, content=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def time_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def url_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def utf8_enforcer_tag(); end

  def week_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormTagHelper
  extend ::ActiveSupport::Concern
  def self.default_enforce_utf8(); end

  def self.default_enforce_utf8=(obj); end

  def self.embed_authenticity_token_in_remote_forms(); end

  def self.embed_authenticity_token_in_remote_forms=(obj); end
end

module ActionView::Helpers::JavaScriptHelper
  def escape_javascript(javascript); end

  def j(javascript); end

  def javascript_cdata_section(content); end

  def javascript_tag(content_or_options_with_block=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
  JS_ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::JavaScriptHelper
end

module ActionView::Helpers::NumberHelper
  def number_to_currency(number, options=T.unsafe(nil)); end

  def number_to_human(number, options=T.unsafe(nil)); end

  def number_to_human_size(number, options=T.unsafe(nil)); end

  def number_to_percentage(number, options=T.unsafe(nil)); end

  def number_to_phone(number, options=T.unsafe(nil)); end

  def number_with_delimiter(number, options=T.unsafe(nil)); end

  def number_with_precision(number, options=T.unsafe(nil)); end
end

module ActionView::Helpers::NumberHelper
end

module ActionView::Helpers::OutputSafetyHelper
  def raw(stringish); end

  def safe_join(array, sep=T.unsafe(nil)); end

  def to_sentence(array, options=T.unsafe(nil)); end
end

module ActionView::Helpers::OutputSafetyHelper
end

module ActionView::Helpers::RenderingHelper
  def _layout_for(*args, &block); end

  def render(options=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

module ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::SanitizeHelper
  def sanitize(html, options=T.unsafe(nil)); end

  def sanitize_css(style); end

  def strip_links(html); end

  def strip_tags(html); end
end

module ActionView::Helpers::SanitizeHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def cdata_section(content); end

  def content_tag(name, content_or_options_with_block=T.unsafe(nil), options=T.unsafe(nil), escape=T.unsafe(nil), &block); end

  def escape_once(html); end

  def tag(name=T.unsafe(nil), options=T.unsafe(nil), open=T.unsafe(nil), escape=T.unsafe(nil)); end
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  PRE_CONTENT_STRINGS = ::T.let(nil, ::T.untyped)
  TAG_PREFIXES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def concat(string); end

  def current_cycle(name=T.unsafe(nil)); end

  def cycle(first_value, *values); end

  def excerpt(text, phrase, options=T.unsafe(nil)); end

  def highlight(text, phrases, options=T.unsafe(nil)); end

  def pluralize(count, singular, plural_arg=T.unsafe(nil), plural: T.unsafe(nil), locale: T.unsafe(nil)); end

  def reset_cycle(name=T.unsafe(nil)); end

  def safe_concat(string); end

  def simple_format(text, html_options=T.unsafe(nil), options=T.unsafe(nil)); end

  def truncate(text, options=T.unsafe(nil), &block); end

  def word_wrap(text, line_width: T.unsafe(nil), break_sequence: T.unsafe(nil)); end
end

module ActionView::Helpers::TextHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::TranslationHelper
  def l(*args); end

  def localize(*args); end

  def t(key, options=T.unsafe(nil)); end

  def translate(key, options=T.unsafe(nil)); end
end

module ActionView::Helpers::TranslationHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers::UrlHelper
  def _back_url(); end

  def _filtered_referrer(); end

  def button_to(name=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless(condition, name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless_current(name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def mail_to(email_address, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def url_for(options=T.unsafe(nil)); end
  BUTTON_TAG_METHOD_VERBS = ::T.let(nil, ::T.untyped)
  STRINGIFIED_COMMON_METHODS = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::UrlHelper
  extend ::ActiveSupport::Concern
end

module ActionView::Helpers
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

class ActionView::I18nProxy
  def initialize(original_config, lookup_context); end

  def locale=(value); end

  def lookup_context(); end

  def original_config(); end
end

class ActionView::I18nProxy
end

module ActionView::Layouts
  def _layout_conditions(*args, &block); end

  def _normalize_options(options); end

  def action_has_layout=(action_has_layout); end

  def action_has_layout?(); end

  def initialize(*_); end
end

module ActionView::Layouts::ClassMethods::LayoutConditions
end

module ActionView::Layouts::ClassMethods::LayoutConditions
end

module ActionView::Layouts
  extend ::ActiveSupport::Concern
end

class ActionView::LogSubscriber
  def render_collection(event); end

  def render_partial(event); end

  def render_template(event); end
  EMPTY = ::T.let(nil, ::T.untyped)
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionView::LogSubscriber
end

class ActionView::LookupContext
  include ::ActionView::LookupContext::Accessors
  include ::ActionView::LookupContext::DetailsCache
  include ::ActionView::LookupContext::ViewPaths
  def digest_cache(); end

  def fallbacks(); end

  def fallbacks=(obj); end

  def formats=(values); end

  def initialize(view_paths, details=T.unsafe(nil), prefixes=T.unsafe(nil)); end

  def prefixes(); end

  def prefixes=(prefixes); end

  def registered_details(); end

  def registered_details=(obj); end

  def rendered_format(*args, &block); end

  def rendered_format=(*args, &block); end

  def with_prepended_formats(formats); end
end

module ActionView::LookupContext::Accessors
  def default_formats(); end

  def default_handlers(); end

  def default_locale(); end

  def default_variants(); end

  def formats(); end

  def formats=(value); end

  def handlers(); end

  def handlers=(value); end

  def locale(); end

  def locale=(value); end

  def variants(); end

  def variants=(value); end
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::Accessors
end

module ActionView::LookupContext::DetailsCache
  def cache(); end

  def cache=(cache); end

  def details_key(); end

  def disable_cache(); end
end

module ActionView::LookupContext::DetailsCache
end

class ActionView::LookupContext::DetailsKey
end

class ActionView::LookupContext::DetailsKey
  def self.clear(); end

  def self.details_cache_key(details); end

  def self.digest_cache(details); end

  def self.digest_caches(); end

  def self.view_context_class(klass); end
end

module ActionView::LookupContext::ViewPaths
  def any?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def any_templates?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def find(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_all(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_file(*args, &block); end

  def find_template(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def html_fallback_for_js(); end

  def template_exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def view_paths(); end

  def with_fallbacks(); end
end

module ActionView::LookupContext::ViewPaths
end

class ActionView::LookupContext
  def self.fallbacks(); end

  def self.fallbacks=(obj); end

  def self.register_detail(name, &block); end

  def self.registered_details(); end

  def self.registered_details=(obj); end
end

class ActionView::MissingTemplate
  def initialize(paths, path, prefixes, partial, details, *_); end
end

module ActionView::ModelNaming
  def convert_to_model(object); end

  def model_name_from_record_or_class(record_or_class); end
end

module ActionView::ModelNaming
end

class ActionView::OptimizedFileSystemResolver
  def initialize(path); end
end

class ActionView::OptimizedFileSystemResolver
end

class ActionView::OutputBuffer
  def append=(value); end

  def initialize(*_); end

  def safe_append=(value); end

  def safe_expr_append=(val); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

class ActionView::PartialIteration
  def first?(); end

  def index(); end

  def initialize(size); end

  def iterate!(); end

  def last?(); end

  def size(); end
end

class ActionView::PartialIteration
end

class ActionView::PartialRenderer
  include ::ActionView::CollectionCaching
  include ::ActiveRecord::Railties::CollectionCacheAssociationLoading
  def collection_cache(); end

  def collection_cache=(obj); end

  def initialize(*_); end

  def render(context, options, block); end
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

class ActionView::PartialRenderer
  def self.collection_cache(); end

  def self.collection_cache=(obj); end
end

class ActionView::PathResolver
  def initialize(pattern=T.unsafe(nil)); end
  DEFAULT_PATTERN = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class ActionView::PathResolver
end

class ActionView::PathSet
  include ::Enumerable
  def +(array); end

  def <<(*args); end

  def [](*args, &block); end

  def compact(); end

  def concat(*args); end

  def each(*args, &block); end

  def exists?(path, prefixes, *args); end

  def find(*args); end

  def find_all(path, prefixes=T.unsafe(nil), *args); end

  def find_all_with_query(query); end

  def find_file(*args, &block); end

  def include?(*args, &block); end

  def initialize(paths=T.unsafe(nil)); end

  def insert(*args); end

  def paths(); end

  def pop(*args, &block); end

  def push(*args); end

  def size(*args, &block); end

  def to_ary(); end

  def unshift(*args); end
end

class ActionView::PathSet
end

class ActionView::Railtie
  NULL_OPTION = ::T.let(nil, ::T.untyped)
end

class ActionView::Railtie
end

module ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def dom_class(record_or_class, prefix=T.unsafe(nil)); end

  def dom_id(record, prefix=T.unsafe(nil)); end
  JOIN = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
end

module ActionView::RecordIdentifier
  extend ::ActionView::RecordIdentifier
  extend ::ActionView::ModelNaming
end

class ActionView::Renderer
  def cache_hits(); end

  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_partial_to_object(context, options, &block); end

  def render_template(context, options); end

  def render_template_to_object(context, options); end

  def render_to_object(context, options); end
end

class ActionView::Renderer
end

module ActionView::Rendering
  def initialize(); end

  def process(*_); end

  def render_to_body(options=T.unsafe(nil)); end

  def rendered_format(); end

  def view_context(); end

  def view_context_class(); end

  def view_renderer(); end
end

module ActionView::Rendering
  extend ::ActiveSupport::Concern
end

class ActionView::Resolver
  def caching(); end

  def caching=(obj); end

  def caching?(*args, &block); end

  def clear_cache(); end

  def find_all(name, prefix=T.unsafe(nil), partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end

  def find_all_anywhere(*args, &block); end

  def find_all_with_query(query); end
end

class ActionView::Resolver::Cache
  def cache(key, name, prefix, partial, locals); end

  def cache_query(query); end

  def clear(); end

  def size(); end
  KEY_BLOCK = ::T.let(nil, ::T.untyped)
  NAME_BLOCK = ::T.let(nil, ::T.untyped)
  NO_TEMPLATES = ::T.let(nil, ::T.untyped)
  PARTIAL_BLOCK = ::T.let(nil, ::T.untyped)
  PREFIX_BLOCK = ::T.let(nil, ::T.untyped)
end

class ActionView::Resolver::Cache::SmallCache
  def initialize(options=T.unsafe(nil)); end
end

class ActionView::Resolver::Cache::SmallCache
end

class ActionView::Resolver::Cache
end

class ActionView::Resolver::Path
  def initialize(name, prefix, partial, virtual); end

  def name(); end

  def partial(); end

  def partial?(); end

  def prefix(); end

  def to_str(); end

  def virtual(); end
end

class ActionView::Resolver::Path
  def self.build(name, prefix, partial); end
end

class ActionView::Resolver
  def self.caching(); end

  def self.caching=(obj); end

  def self.caching?(); end
end

module ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def default_url_options=(obj); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionView::RoutingUrlFor
  def self.default_url_options=(obj); end
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
  def render_template(view, template, layout_name=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::StreamingTemplateRenderer::Body
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::SyntaxErrorInTemplate
  def initialize(template, offending_code_string); end
end

class ActionView::Template
  def encode!(); end

  def format(); end

  def formats(*args, &block); end

  def formats=(*args, &block); end

  def handler(); end

  def identifier(); end

  def initialize(source, identifier, handler, format: T.unsafe(nil), variant: T.unsafe(nil), locals: T.unsafe(nil), virtual_path: T.unsafe(nil), updated_at: T.unsafe(nil)); end

  def locals(); end

  def locals=(*args, &block); end

  def marshal_dump(); end

  def marshal_load(array); end

  def original_encoding(*args, &block); end

  def refresh(*args, &block); end

  def render(view, locals, buffer=T.unsafe(nil), &block); end

  def short_identifier(); end

  def source(); end

  def supports_streaming?(); end

  def type(); end

  def updated_at(*args, &block); end

  def variable(); end

  def variant(); end

  def variants(*args, &block); end

  def variants=(*args, &block); end

  def virtual_path(); end

  def virtual_path=(*args, &block); end
end

class ActionView::Template::Error
  def annotated_source_code(); end

  def file_name(); end

  def initialize(template); end

  def line_number(); end

  def source_extract(indentation=T.unsafe(nil), output=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::HTML
  def format(); end

  def formats(*args, &block); end

  def identifier(); end

  def initialize(string, type=T.unsafe(nil)); end

  def render(*args); end

  def to_str(); end

  def type(); end
end

class ActionView::Template::HTML
end

module ActionView::Template::Handlers
  def handler_for_extension(extension); end

  def register_default_template_handler(extension, klass); end

  def register_template_handler(*extensions, handler); end

  def registered_template_handler(extension); end

  def template_handler_extensions(); end

  def unregister_template_handler(*extensions); end
end

class ActionView::Template::Handlers::Builder
  def call(template, source); end

  def default_format(); end

  def default_format=(val); end

  def default_format?(); end
end

class ActionView::Template::Handlers::Builder
  def self.default_format(); end

  def self.default_format=(val); end

  def self.default_format?(); end
end

class ActionView::Template::Handlers::ERB
  def call(template, source); end

  def erb_implementation(); end

  def erb_implementation=(val); end

  def erb_implementation?(); end

  def erb_trim_mode(); end

  def erb_trim_mode=(val); end

  def erb_trim_mode?(); end

  def escape_ignore_list(); end

  def escape_ignore_list=(val); end

  def escape_ignore_list?(); end

  def escape_whitelist(*args, &block); end

  def escape_whitelist=(*args, &block); end

  def handles_encoding?(); end

  def supports_streaming?(); end
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  def evaluate(action_view_erb_handler_context); end
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
end

class ActionView::Template::Handlers::ERB
  def self.call(template, source); end

  def self.erb_implementation(); end

  def self.erb_implementation=(val); end

  def self.erb_implementation?(); end

  def self.erb_trim_mode(); end

  def self.erb_trim_mode=(val); end

  def self.erb_trim_mode?(); end

  def self.escape_ignore_list(); end

  def self.escape_ignore_list=(val); end

  def self.escape_ignore_list?(); end

  def self.escape_whitelist(*args, &block); end

  def self.escape_whitelist=(*args, &block); end
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::LegacyHandlerWrapper
  def call(view, source); end
end

class ActionView::Template::Handlers::LegacyHandlerWrapper
end

class ActionView::Template::Handlers::Raw
  def call(template, source); end
end

class ActionView::Template::Handlers::Raw
end

module ActionView::Template::Handlers
  def self.extended(base); end

  def self.extensions(); end
end

class ActionView::Template::Inline
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Inline
end

class ActionView::Template::LegacyTemplate
  def initialize(template, source); end

  def source(); end
end

class ActionView::Template::LegacyTemplate
end

class ActionView::Template::RawFile
  def format(); end

  def format=(format); end

  def formats(*args, &block); end

  def identifier(); end

  def initialize(filename); end

  def render(*args); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::RawFile
end

module ActionView::Template::Sources
end

class ActionView::Template::Sources::File
  def initialize(filename); end
end

class ActionView::Template::Sources::File
end

module ActionView::Template::Sources
  extend ::ActiveSupport::Autoload
end

class ActionView::Template::Text
  def format(); end

  def formats(*args, &block); end

  def identifier(); end

  def initialize(string); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Text
end

class ActionView::Template::Types
  def type_klass(); end

  def type_klass=(obj); end
end

class ActionView::Template::Types::Type
  def ==(type); end

  def initialize(symbol); end

  def ref(); end

  def symbol(); end

  def to_str(); end

  def to_sym(); end
  SET = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Types::Type
  def self.[](type); end
end

class ActionView::Template::Types
  def self.[](type); end

  def self.delegate_to(klass); end

  def self.symbols(); end

  def self.type_klass(); end

  def self.type_klass=(obj); end
end

class ActionView::Template
  extend ::ActiveSupport::Autoload
  extend ::ActionView::Template::Handlers
  def self.finalize_compiled_template_methods(); end

  def self.finalize_compiled_template_methods=(_); end
end

class ActionView::TemplateRenderer
  def render(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::TestCase
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::AbstractController::Helpers
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::Rails::Controller::Testing::TemplateAssertions
  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def config(); end

  def controller(); end

  def controller=(controller); end

  def lookup_context(*args, &block); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def rendered(); end

  def rendered=(rendered); end

  def rendered_views(); end

  def setup_with_controller(); end
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::TestCase::Behavior::ClassMethods
  def determine_default_helper_class(name); end

  def helper_class(); end

  def helper_class=(helper_class); end

  def helper_method(*methods); end

  def new(*_); end

  def tests(helper_class); end
end

module ActionView::TestCase::Behavior::ClassMethods
end

module ActionView::TestCase::Behavior::Locals
  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil)); end

  def rendered_views(); end

  def rendered_views=(rendered_views); end
end

module ActionView::TestCase::Behavior::Locals
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
  def add(view, locals); end

  def locals_for(view); end

  def rendered_views(); end

  def view_rendered?(view, expected_locals); end
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
end

module ActionView::TestCase::Behavior
  extend ::ActiveSupport::Concern
end

class ActionView::TestCase::TestController
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def controller_path=(path); end

  def initialize(); end

  def params=(params); end
end

class ActionView::TestCase::TestController
  def self.controller_path=(controller_path); end
end

class ActionView::TestCase
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionView::TestCase::Behavior::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end
end

class ActionView::UnboundTemplate
  def bind_locals(locals); end

  def initialize(source, identifer, handler, options); end
end

class ActionView::UnboundTemplate
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView::VERSION
end

module ActionView::ViewPaths
  def _prefixes(); end

  def any_templates?(*args, &block); end

  def append_view_path(path); end

  def details_for_lookup(); end

  def formats(*args, &block); end

  def formats=(arg); end

  def locale(*args, &block); end

  def locale=(arg); end

  def lookup_context(); end

  def prepend_view_path(path); end

  def template_exists?(*args, &block); end

  def view_paths(*args, &block); end
end

module ActionView::ViewPaths
  extend ::ActiveSupport::Concern
  def self.all_view_paths(); end

  def self.get_view_paths(klass); end

  def self.set_view_paths(klass, paths); end
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

module ActionView
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveJob
end

module ActiveJob::Arguments
  def deserialize(arguments); end

  def serialize(arguments); end
  OBJECT_SERIALIZER_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Arguments
  extend ::ActiveJob::Arguments
end

class ActiveJob::Base
  include ::ActiveJob::Core
  include ::ActiveJob::QueueAdapter
  include ::ActiveJob::QueueName
  include ::ActiveJob::QueuePriority
  include ::ActiveJob::Enqueuing
  include ::ActiveSupport::Rescuable
  include ::ActiveJob::Execution
  include ::ActiveSupport::Callbacks
  include ::ActiveJob::Callbacks
  include ::ActiveJob::Exceptions
  include ::ActiveJob::Logging
  include ::ActiveJob::Timezones
  include ::ActiveJob::Translation
  include ::ActiveJob::TestHelper::TestQueueAdapter
  def __callbacks(); end

  def __callbacks?(); end

  def _enqueue_callbacks(); end

  def _perform_callbacks(); end

  def _run_enqueue_callbacks(&block); end

  def _run_perform_callbacks(&block); end

  def logger(); end

  def logger=(obj); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end
end

class ActiveJob::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._enqueue_callbacks(); end

  def self._enqueue_callbacks=(value); end

  def self._perform_callbacks(); end

  def self._perform_callbacks=(value); end

  def self._queue_adapter(); end

  def self._queue_adapter=(val); end

  def self._queue_adapter_name(); end

  def self._queue_adapter_name=(val); end

  def self._test_adapter(); end

  def self._test_adapter=(val); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.priority(); end

  def self.priority=(val); end

  def self.priority?(); end

  def self.queue_name(); end

  def self.queue_name=(val); end

  def self.queue_name?(); end

  def self.queue_name_delimiter(); end

  def self.queue_name_delimiter=(val); end

  def self.queue_name_delimiter?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.return_false_on_aborted_enqueue(); end

  def self.return_false_on_aborted_enqueue=(val); end
end

module ActiveJob::Callbacks
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Callbacks
  def self.__callbacks(); end

  def self.__callbacks?(); end

  def self._execute_callbacks(); end

  def self._run_execute_callbacks(&block); end
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_later(*args); end

  def perform_now(*args); end
end

class ActiveJob::ConfiguredJob
end

module ActiveJob::Core
  def arguments(); end

  def arguments=(arguments); end

  def deserialize(job_data); end

  def enqueued_at(); end

  def enqueued_at=(enqueued_at); end

  def exception_executions(); end

  def exception_executions=(exception_executions); end

  def executions(); end

  def executions=(executions); end

  def initialize(*arguments); end

  def job_id(); end

  def job_id=(job_id); end

  def locale(); end

  def locale=(locale); end

  def priority=(priority); end

  def provider_job_id(); end

  def provider_job_id=(provider_job_id); end

  def queue_name=(queue_name); end

  def scheduled_at(); end

  def scheduled_at=(scheduled_at); end

  def serialize(); end

  def serialized_arguments=(serialized_arguments); end

  def timezone(); end

  def timezone=(timezone); end
end

module ActiveJob::Core
  extend ::ActiveSupport::Concern
end

class ActiveJob::DeserializationError
  def initialize(); end
end

class ActiveJob::DeserializationError
end

module ActiveJob::Enqueuing
  def enqueue(options=T.unsafe(nil)); end
end

module ActiveJob::Enqueuing
  extend ::ActiveSupport::Concern
end

module ActiveJob::Exceptions
  def retry_job(options=T.unsafe(nil)); end
end

module ActiveJob::Exceptions
  extend ::ActiveSupport::Concern
end

module ActiveJob::Execution
  def perform(*_); end

  def perform_now(); end
end

module ActiveJob::Execution
  extend ::ActiveSupport::Concern
end

module ActiveJob::Logging
end

module ActiveJob::Logging
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueueAdapter
end

module ActiveJob::QueueAdapter
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueueAdapters
end

class ActiveJob::QueueAdapters::AsyncAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def immediate=(immediate); end

  def initialize(**executor_options); end

  def shutdown(wait: T.unsafe(nil)); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
  def initialize(job); end

  def perform(); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
  def enqueue(job, queue_name:); end

  def enqueue_at(job, timestamp, queue_name:); end

  def executor(); end

  def immediate(); end

  def immediate=(immediate); end

  def initialize(**options); end

  def shutdown(wait: T.unsafe(nil)); end
  DEFAULT_EXECUTOR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
end

class ActiveJob::QueueAdapters::AsyncAdapter
end

class ActiveJob::QueueAdapters::InlineAdapter
  def enqueue(job); end

  def enqueue_at(*_); end
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::TestAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def filter(); end

  def filter=(filter); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end

  def queue(); end

  def queue=(queue); end

  def reject(); end

  def reject=(reject); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

module ActiveJob::QueueAdapters
  extend ::ActiveSupport::Autoload
  def self.lookup(name); end
end

module ActiveJob::QueueName
  def queue_name(); end
end

module ActiveJob::QueueName
  extend ::ActiveSupport::Concern
end

module ActiveJob::QueuePriority
  def priority(); end
end

module ActiveJob::QueuePriority
  extend ::ActiveSupport::Concern
end

class ActiveJob::Railtie
end

class ActiveJob::Railtie
end

class ActiveJob::SerializationError
end

class ActiveJob::SerializationError
end

module ActiveJob::Serializers
  def _additional_serializers(); end

  def _additional_serializers=(obj); end
end

class ActiveJob::Serializers::DateSerializer
  def deserialize(hash); end

  def serialize(date); end
end

class ActiveJob::Serializers::DateSerializer
end

class ActiveJob::Serializers::DateTimeSerializer
  def deserialize(hash); end

  def serialize(time); end
end

class ActiveJob::Serializers::DateTimeSerializer
end

class ActiveJob::Serializers::DurationSerializer
  def deserialize(hash); end

  def serialize(duration); end
end

class ActiveJob::Serializers::DurationSerializer
end

class ActiveJob::Serializers::ObjectSerializer
  include ::Singleton
  def deserialize(_argument); end

  def serialize(hash); end

  def serialize?(argument); end
end

class ActiveJob::Serializers::ObjectSerializer
  extend ::Singleton::SingletonClassMethods
  def self.deserialize(*args, &block); end

  def self.instance(); end

  def self.serialize(*args, &block); end

  def self.serialize?(*args, &block); end
end

class ActiveJob::Serializers::SymbolSerializer
  def deserialize(argument); end

  def serialize(argument); end
end

class ActiveJob::Serializers::SymbolSerializer
end

class ActiveJob::Serializers::TimeSerializer
  def deserialize(hash); end

  def serialize(time); end
end

class ActiveJob::Serializers::TimeSerializer
end

class ActiveJob::Serializers::TimeWithZoneSerializer
  def deserialize(hash); end

  def serialize(time); end
end

class ActiveJob::Serializers::TimeWithZoneSerializer
end

module ActiveJob::Serializers
  extend ::ActiveSupport::Autoload
  def self._additional_serializers(); end

  def self._additional_serializers=(obj); end

  def self.add_serializers(*new_serializers); end

  def self.deserialize(argument); end

  def self.serialize(argument); end

  def self.serializers(); end
end

class ActiveJob::TestCase
  include ::ActiveJob::TestHelper
end

class ActiveJob::TestCase
end

module ActiveJob::TestHelper
  def after_teardown(); end

  def assert_enqueued_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil)); end

  def assert_enqueued_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil)); end

  def assert_no_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_no_performed_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_performed_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def before_setup(); end

  def enqueued_jobs(*args, &block); end

  def enqueued_jobs=(arg); end

  def perform_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil)); end

  def performed_jobs(*args, &block); end

  def performed_jobs=(arg); end

  def queue_adapter(); end

  def queue_adapter_for_test(); end
end

module ActiveJob::TestHelper::TestQueueAdapter
end

module ActiveJob::TestHelper::TestQueueAdapter
  extend ::ActiveSupport::Concern
end

module ActiveJob::TestHelper
end

module ActiveJob::Timezones
end

module ActiveJob::Timezones
  extend ::ActiveSupport::Concern
end

module ActiveJob::Translation
end

module ActiveJob::Translation
  extend ::ActiveSupport::Concern
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::VERSION
end

module ActiveJob
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

class ActiveModel::Attribute
  def ==(other); end

  def came_from_user?(); end

  def changed?(); end

  def changed_in_place?(); end

  def encode_with(coder); end

  def eql?(other); end

  def forgetting_assignment(); end

  def has_been_read?(); end

  def init_with(coder); end

  def initialize(name, value_before_type_cast, type, original_attribute=T.unsafe(nil)); end

  def initialized?(); end

  def name(); end

  def original_value(); end

  def original_value_for_database(); end

  def type(); end

  def type_cast(*_); end

  def value(); end

  def value_before_type_cast(); end

  def value_for_database(); end

  def with_cast_value(value); end

  def with_type(type); end

  def with_value_from_database(value); end

  def with_value_from_user(value); end
end

class ActiveModel::Attribute::FromUser
  def type_cast(value); end
end

class ActiveModel::Attribute::FromUser
end

class ActiveModel::Attribute::UserProvidedDefault
  def initialize(name, value, type, database_default); end

  def marshal_dump(); end

  def marshal_load(values); end
end

class ActiveModel::Attribute::UserProvidedDefault
end

class ActiveModel::Attribute
  def self.from_database(name, value, type); end

  def self.from_user(name, value, type, original_attribute=T.unsafe(nil)); end

  def self.null(name); end

  def self.uninitialized(name, type); end

  def self.with_cast_value(name, value, type); end
end

module ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def assign_attributes(new_attributes); end

  def attributes=(new_attributes); end
end

module ActiveModel::AttributeAssignment
end

module ActiveModel::AttributeMethods
  def attribute_missing(match, *args, &block); end

  def method_missing(method, *args, &block); end

  def respond_to?(method, include_private_methods=T.unsafe(nil)); end

  def respond_to_without_attributes?(*_); end
  CALL_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
  NAME_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActiveModel::AttributeMethods::AttrNames
  DEF_SAFE_NAME = ::T.let(nil, ::T.untyped)
end

module ActiveModel::AttributeMethods::AttrNames
  def self.define_attribute_accessor_method(mod, attr_name, writer: T.unsafe(nil)); end
end

module ActiveModel::AttributeMethods::ClassMethods
  def alias_attribute(new_name, old_name); end

  def attribute_alias(name); end

  def attribute_alias?(new_name); end

  def attribute_method_affix(*affixes); end

  def attribute_method_prefix(*prefixes); end

  def attribute_method_suffix(*suffixes); end

  def define_attribute_method(attr_name); end

  def define_attribute_methods(*attr_names); end

  def undefine_attribute_methods(); end
end

class ActiveModel::AttributeMethods::ClassMethods::AttributeMethodMatcher
  def initialize(options=T.unsafe(nil)); end

  def match(method_name); end

  def method_name(attr_name); end

  def plain?(); end

  def prefix(); end

  def suffix(); end

  def target(); end
end

class ActiveModel::AttributeMethods::ClassMethods::AttributeMethodMatcher::AttributeMethodMatch
  def attr_name(); end

  def attr_name=(_); end

  def target(); end

  def target=(_); end
end

class ActiveModel::AttributeMethods::ClassMethods::AttributeMethodMatcher::AttributeMethodMatch
  def self.[](*_); end

  def self.members(); end
end

class ActiveModel::AttributeMethods::ClassMethods::AttributeMethodMatcher
end

module ActiveModel::AttributeMethods::ClassMethods
end

module ActiveModel::AttributeMethods
  extend ::ActiveSupport::Concern
end

class ActiveModel::AttributeMutationTracker
  def any_changes?(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, from: T.unsafe(nil), to: T.unsafe(nil)); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def force_change(attr_name); end

  def forget_change(attr_name); end

  def initialize(attributes, forced_changes=T.unsafe(nil)); end

  def original_value(attr_name); end
  OPTION_NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

class ActiveModel::AttributeMutationTracker
end

class ActiveModel::AttributeSet
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def accessed(); end

  def attributes(); end

  def each_value(*args, &block); end

  def except(*args, &block); end

  def fetch(*args, &block); end

  def fetch_value(name, &block); end

  def initialize(attributes); end

  def key?(name); end

  def keys(); end

  def map(&block); end

  def reset(key); end

  def to_h(); end

  def to_hash(); end

  def values_before_type_cast(); end

  def write_cast_value(name, value); end

  def write_from_database(name, value); end

  def write_from_user(name, value); end
end

class ActiveModel::AttributeSet::Builder
  def build_from_database(values=T.unsafe(nil), additional_types=T.unsafe(nil)); end

  def default_attributes(); end

  def initialize(types, default_attributes=T.unsafe(nil)); end

  def types(); end
end

class ActiveModel::AttributeSet::Builder
end

class ActiveModel::AttributeSet::YAMLEncoder
  def decode(coder); end

  def encode(attribute_set, coder); end

  def initialize(default_types); end
end

class ActiveModel::AttributeSet::YAMLEncoder
end

class ActiveModel::AttributeSet
end

module ActiveModel::Attributes
  def attribute_names(); end

  def attributes(); end

  def initialize(*_); end
end

module ActiveModel::Attributes::ClassMethods
  def attribute(name, type=T.unsafe(nil), **options); end

  def attribute_names(); end
end

module ActiveModel::Attributes::ClassMethods
end

module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
end

class ActiveModel::BlockValidator
  def initialize(options, &block); end
end

class ActiveModel::BlockValidator
end

module ActiveModel::Callbacks
  def define_model_callbacks(*callbacks); end
end

module ActiveModel::Callbacks
  def self.extended(base); end
end

module ActiveModel::Conversion
  def to_key(); end

  def to_model(); end

  def to_param(); end

  def to_partial_path(); end
end

module ActiveModel::Conversion
  extend ::ActiveSupport::Concern
end

module ActiveModel::Dirty
  def attribute_was(attr_name); end

  def changed(); end

  def changed_attributes(); end

  def changes(); end

  def changes_applied(); end

  def clear_attribute_changes(attr_names); end

  def clear_changes_information(); end

  def previous_changes(); end

  def restore_attributes(attr_names=T.unsafe(nil)); end
end

module ActiveModel::Dirty
  extend ::ActiveSupport::Concern
end

class ActiveModel::EachValidator
  def attributes(); end

  def check_validity!(); end

  def initialize(options); end

  def validate_each(record, attribute, value); end
end

class ActiveModel::EachValidator
end

class ActiveModel::Errors
  include ::Enumerable
  def [](attribute); end

  def clear(); end

  def copy!(other); end

  def count(); end

  def delete(key); end

  def details(); end

  def each(&blk); end

  def empty?(); end

  def full_message(attribute, message); end

  def full_messages_for(attribute); end

  def generate_message(attribute, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def has_key?(attribute); end

  def include?(attribute); end

  def init_with(coder); end

  def initialize(base); end

  def key?(attribute); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(array); end

  def merge!(other); end

  def messages(); end

  def size(); end

  def slice!(*keys); end

  def to_a(); end

  def to_hash(full_messages=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def values(); end
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
  MESSAGE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Errors
  def self.i18n_customize_full_message(); end

  def self.i18n_customize_full_message=(i18n_customize_full_message); end
end

class ActiveModel::ForbiddenAttributesError
end

class ActiveModel::ForbiddenAttributesError
end

module ActiveModel::ForbiddenAttributesProtection
end

module ActiveModel::ForbiddenAttributesProtection
end

class ActiveModel::ForcedMutationTracker
  def finalize_changes(); end
end

class ActiveModel::ForcedMutationTracker
end

class ActiveModel::LazyAttributeHash
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def each_key(*args, &block); end

  def each_value(*args, &block); end

  def except(*args, &block); end

  def fetch(*args, &block); end

  def initialize(types, values, additional_types, default_attributes, delegate_hash=T.unsafe(nil)); end

  def key?(key); end

  def marshal_dump(); end

  def marshal_load(values); end

  def materialize(); end

  def select(); end

  def transform_values(*args, &block); end
end

class ActiveModel::LazyAttributeHash
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
end

module ActiveModel::Lint
end

class ActiveModel::MissingAttributeError
end

class ActiveModel::MissingAttributeError
end

module ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(attributes=T.unsafe(nil)); end

  def persisted?(); end
end

module ActiveModel::Model
  extend ::ActiveSupport::Concern
end

class ActiveModel::Name
  include ::Comparable
  def !~(*args, &block); end

  def ==(arg); end

  def ===(arg); end

  def =~(*args, &block); end

  def as_json(*args, &block); end

  def cache_key(); end

  def collection(); end

  def element(); end

  def eql?(*args, &block); end

  def human(options=T.unsafe(nil)); end

  def i18n_key(); end

  def initialize(klass, namespace=T.unsafe(nil), name=T.unsafe(nil)); end

  def match?(*args, &block); end

  def name(); end

  def param_key(); end

  def plural(); end

  def route_key(); end

  def singular(); end

  def singular_route_key(); end

  def to_s(*args, &block); end

  def to_str(*args, &block); end
end

class ActiveModel::Name
end

module ActiveModel::Naming
  def model_name(); end
end

module ActiveModel::Naming
  def self.extended(base); end

  def self.param_key(record_or_class); end

  def self.plural(record_or_class); end

  def self.route_key(record_or_class); end

  def self.singular(record_or_class); end

  def self.singular_route_key(record_or_class); end

  def self.uncountable?(record_or_class); end
end

class ActiveModel::NullMutationTracker
  include ::Singleton
  def any_changes?(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, **_); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def original_value(attr_name); end
end

class ActiveModel::NullMutationTracker
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class ActiveModel::Railtie
end

class ActiveModel::Railtie
end

class ActiveModel::RangeError
end

class ActiveModel::RangeError
end

module ActiveModel::SecurePassword
  MAX_PASSWORD_LENGTH_ALLOWED = ::T.let(nil, ::T.untyped)
end

module ActiveModel::SecurePassword::ClassMethods
  def has_secure_password(attribute=T.unsafe(nil), validations: T.unsafe(nil)); end
end

module ActiveModel::SecurePassword::ClassMethods
end

class ActiveModel::SecurePassword::InstanceMethodsOnActivation
  def initialize(attribute); end
end

class ActiveModel::SecurePassword::InstanceMethodsOnActivation
end

module ActiveModel::SecurePassword
  extend ::ActiveSupport::Concern
  def self.min_cost(); end

  def self.min_cost=(min_cost); end
end

module ActiveModel::Serialization
  def read_attribute_for_serialization(*_); end

  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveModel::Serialization
end

module ActiveModel::Serializers
end

module ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  def as_json(options=T.unsafe(nil)); end

  def from_json(json, include_root=T.unsafe(nil)); end
end

module ActiveModel::Serializers::JSON
  extend ::ActiveSupport::Concern
end

module ActiveModel::Serializers::Xml
  include ::ActiveModel::Serialization
  def from_xml(xml); end

  def to_xml(options=T.unsafe(nil), &block); end
end

class ActiveModel::Serializers::Xml::Serializer
  def initialize(serializable, options=T.unsafe(nil)); end

  def options(); end

  def serializable_collection(); end

  def serializable_hash(); end

  def serialize(); end
end

class ActiveModel::Serializers::Xml::Serializer::Attribute
  def compute_type(); end

  def decorations(); end

  def initialize(name, serializable, value); end

  def name(); end

  def type(); end

  def value(); end
end

class ActiveModel::Serializers::Xml::Serializer::Attribute
end

class ActiveModel::Serializers::Xml::Serializer::MethodAttribute
end

class ActiveModel::Serializers::Xml::Serializer::MethodAttribute
end

class ActiveModel::Serializers::Xml::Serializer
end

module ActiveModel::Serializers::Xml
  extend ::ActiveSupport::Concern
end

module ActiveModel::Serializers
  extend ::ActiveSupport::Autoload
end

class ActiveModel::StrictValidationFailed
end

class ActiveModel::StrictValidationFailed
end

module ActiveModel::Translation
  include ::ActiveModel::Naming
  def human_attribute_name(attribute, options=T.unsafe(nil)); end

  def i18n_scope(); end

  def lookup_ancestors(); end
end

module ActiveModel::Translation
end

class ActiveModel::Type::BigInteger
end

class ActiveModel::Type::BigInteger
end

class ActiveModel::Type::Binary
  def changed_in_place?(raw_old_value, value); end
end

class ActiveModel::Type::Binary::Data
  def ==(other); end

  def hex(); end

  def initialize(value); end

  def to_str(); end
end

class ActiveModel::Type::Binary::Data
end

class ActiveModel::Type::Binary
end

class ActiveModel::Type::Boolean
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
  include ::ActiveModel::Type::Helpers::Timezone
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
end

class ActiveModel::Type::DateTime
  include ::ActiveModel::Type::Helpers::Timezone
  include ::ActiveModel::Type::Helpers::TimeValue
end

class ActiveModel::Type::DateTime
end

class ActiveModel::Type::Decimal
  include ::ActiveModel::Type::Helpers::Numeric
  BIGDECIMAL_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Decimal
end

class ActiveModel::Type::Float
  include ::ActiveModel::Type::Helpers::Numeric
end

class ActiveModel::Type::Float
end

module ActiveModel::Type::Helpers
end

class ActiveModel::Type::Helpers::AcceptsMultiparameterTime
  def initialize(defaults: T.unsafe(nil)); end
end

class ActiveModel::Type::Helpers::AcceptsMultiparameterTime
end

module ActiveModel::Type::Helpers::Mutable
  def cast(value); end

  def changed_in_place?(raw_old_value, new_value); end
end

module ActiveModel::Type::Helpers::Mutable
end

module ActiveModel::Type::Helpers::Numeric
  def cast(value); end

  def changed?(old_value, _new_value, new_value_before_type_cast); end

  def serialize(value); end
end

module ActiveModel::Type::Helpers::Numeric
end

module ActiveModel::Type::Helpers::TimeValue
  def apply_seconds_precision(value); end

  def serialize(value); end

  def type_cast_for_schema(value); end

  def user_input_in_time_zone(value); end
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::TimeValue
end

module ActiveModel::Type::Helpers::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

module ActiveModel::Type::Helpers::Timezone
end

module ActiveModel::Type::Helpers
end

class ActiveModel::Type::Integer
  include ::ActiveModel::Type::Helpers::Numeric
  def initialize(*_); end
  DEFAULT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Integer
end

class ActiveModel::Type::Registration
  def call(_registry, *args, **kwargs); end

  def initialize(name, block, **_); end

  def matches?(type_name, *args, **kwargs); end
end

class ActiveModel::Type::Registration
end

class ActiveModel::Type::Registry
  def lookup(symbol, *args); end

  def register(type_name, klass=T.unsafe(nil), **options, &block); end
end

class ActiveModel::Type::Registry
end

class ActiveModel::Type::Time
  include ::ActiveModel::Type::Helpers::Timezone
  include ::ActiveModel::Type::Helpers::TimeValue
end

class ActiveModel::Type::Time
end

class ActiveModel::Type::Value
  def ==(other); end

  def assert_valid_value(*_); end

  def binary?(); end

  def changed?(old_value, new_value, _new_value_before_type_cast); end

  def changed_in_place?(raw_old_value, new_value); end

  def deserialize(value); end

  def eql?(other); end

  def force_equality?(_value); end

  def limit(); end

  def map(value); end

  def precision(); end

  def scale(); end

  def serialize(value); end

  def type(); end

  def type_cast_for_schema(value); end

  def value_constructed_by_mass_assignment?(_value); end
end

module ActiveModel::Type
  def self.default_value(); end

  def self.lookup(*args, **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

class ActiveModel::UnknownAttributeError
  def attribute(); end

  def initialize(record, attribute); end

  def record(); end
end

class ActiveModel::UnknownAttributeError
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::VERSION
end

class ActiveModel::ValidationError
  def initialize(model); end

  def model(); end
end

class ActiveModel::ValidationError
end

module ActiveModel::Validations
  def invalid?(context=T.unsafe(nil)); end

  def read_attribute_for_validation(*_); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end

  def validate!(context=T.unsafe(nil)); end

  def validates_with(*args, &block); end
end

class ActiveModel::Validations::AbsenceValidator
  def validate_each(record, attr_name, value); end
end

class ActiveModel::Validations::AbsenceValidator
end

module ActiveModel::Validations::Callbacks
end

module ActiveModel::Validations::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveModel::Validations::HelperMethods
  def validates_absence_of(*attr_names); end

  def validates_acceptance_of(*attr_names); end

  def validates_confirmation_of(*attr_names); end

  def validates_exclusion_of(*attr_names); end

  def validates_format_of(*attr_names); end

  def validates_inclusion_of(*attr_names); end

  def validates_length_of(*attr_names); end

  def validates_numericality_of(*attr_names); end

  def validates_presence_of(*attr_names); end

  def validates_size_of(*attr_names); end
end

class ActiveModel::Validations::LengthValidator
  CHECKS = ::T.let(nil, ::T.untyped)
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Validations::LengthValidator
end

class ActiveModel::Validations::PresenceValidator
  def validate_each(record, attr_name, value); end
end

class ActiveModel::Validations::PresenceValidator
end

module ActiveModel::Validations
  extend ::ActiveSupport::Concern
end

class ActiveModel::Validator
  def initialize(options=T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def validate(record); end
end

class ActiveModel::Validator
  def self.kind(); end
end

module ActiveModel
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveRecord::Aggregations
  def reload(*_); end
end

module ActiveRecord::Aggregations::ClassMethods
  def composed_of(part_id, options=T.unsafe(nil)); end
end

module ActiveRecord::Aggregations::ClassMethods
end

module ActiveRecord::Aggregations
end

class ActiveRecord::AmbiguousSourceReflectionForThroughAssociation
  def initialize(klass, macro, association_name, options, possible_sources); end
end

class ActiveRecord::AssociationNotFoundError
  def initialize(record=T.unsafe(nil), association_name=T.unsafe(nil)); end
end

class ActiveRecord::AssociationRelation
  def initialize(klass, association); end

  def proxy_association(); end
end

class ActiveRecord::AssociationRelation
end

module ActiveRecord::Associations
  def association(name); end

  def association_cached?(name); end

  def reload(*_); end
end

class ActiveRecord::Associations::AliasTracker
  def aliased_table_for(table_name, aliased_name, type_caster); end

  def aliases(); end

  def initialize(connection, aliases); end
end

class ActiveRecord::Associations::AliasTracker
  def self.create(connection, initial_table, joins); end

  def self.initial_count_for(connection, name, table_joins); end
end

class ActiveRecord::Associations::Association
  def create(attributes=T.unsafe(nil), &block); end

  def create!(attributes=T.unsafe(nil), &block); end

  def extensions(); end

  def initialize(owner, reflection); end

  def initialize_attributes(record, except_from_scope_attributes=T.unsafe(nil)); end

  def inversed_from(record); end

  def inversed_from_queries(record); end

  def klass(); end

  def load_target(); end

  def loaded!(); end

  def loaded?(); end

  def marshal_dump(); end

  def marshal_load(data); end

  def options(*args, &block); end

  def owner(); end

  def reflection(); end

  def reload(force=T.unsafe(nil)); end

  def remove_inverse_instance(record); end

  def reset(); end

  def reset_scope(); end

  def scope(); end

  def scoping(relation, &block); end

  def set_inverse_instance(record); end

  def set_inverse_instance_from_queries(record); end

  def stale_target?(); end

  def target(); end

  def target=(target); end
end

class ActiveRecord::Associations::Association
end

class ActiveRecord::Associations::AssociationScope
  def initialize(value_transformation); end

  def scope(association); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::AssociationScope::ReflectionProxy
  def aliased_table(); end

  def all_includes(); end

  def initialize(reflection, aliased_table); end
end

class ActiveRecord::Associations::AssociationScope::ReflectionProxy
end

class ActiveRecord::Associations::AssociationScope
  def self.create(&block); end

  def self.get_bind_values(owner, chain); end

  def self.scope(association); end
end

class ActiveRecord::Associations::BelongsToAssociation
  def decrement_counters(); end

  def decrement_counters_before_last_save(); end

  def default(&block); end

  def handle_dependency(); end

  def increment_counters(); end

  def target_changed?(); end

  def updated?(); end
end

class ActiveRecord::Associations::BelongsToAssociation
end

class ActiveRecord::Associations::BelongsToPolymorphicAssociation
end

class ActiveRecord::Associations::BelongsToPolymorphicAssociation
end

module ActiveRecord::Associations::Builder
end

class ActiveRecord::Associations::Builder::Association
  VALID_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::Builder::Association
  def self.build(model, name, scope, options, &block); end

  def self.create_reflection(model, name, scope, options, &block); end

  def self.extensions(); end

  def self.extensions=(extensions); end
end

class ActiveRecord::Associations::Builder::BelongsTo
end

class ActiveRecord::Associations::Builder::BelongsTo
  def self.touch_record(o, changes, foreign_key, name, touch, touch_method); end
end

class ActiveRecord::Associations::Builder::CollectionAssociation
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::Builder::CollectionAssociation
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany
  def association_name(); end

  def initialize(association_name, lhs_model, options); end

  def lhs_model(); end

  def middle_reflection(join_model); end

  def options(); end

  def through_model(); end
end

class ActiveRecord::Associations::Builder::HasAndBelongsToMany
end

class ActiveRecord::Associations::Builder::HasMany
end

class ActiveRecord::Associations::Builder::HasMany
end

class ActiveRecord::Associations::Builder::HasOne
end

class ActiveRecord::Associations::Builder::HasOne
  def self.touch_record(o, name, touch); end
end

class ActiveRecord::Associations::Builder::SingularAssociation
end

class ActiveRecord::Associations::Builder::SingularAssociation
end

module ActiveRecord::Associations::Builder
end

class ActiveRecord::Associations::CollectionAssociation
  def add_to_target(record, skip_callbacks=T.unsafe(nil), &block); end

  def build(attributes=T.unsafe(nil), &block); end

  def concat(*records); end

  def delete(*records); end

  def delete_all(dependent=T.unsafe(nil)); end

  def destroy(*records); end

  def destroy_all(); end

  def empty?(); end

  def find(*args); end

  def find_from_target?(); end

  def ids_reader(); end

  def ids_writer(ids); end

  def include?(record); end

  def null_scope?(); end

  def reader(); end

  def replace(other_array); end

  def size(); end

  def transaction(*args); end

  def writer(records); end
end

class ActiveRecord::Associations::CollectionAssociation
end

class ActiveRecord::Associations::CollectionProxy
  def <<(*records); end

  def _select!(*args, &block); end

  def annotate(*args, &block); end

  def annotate!(*args, &block); end

  def annotate_values(*args, &block); end

  def annotate_values=(arg); end

  def append(*records); end

  def arel(*args, &block); end

  def clear(); end

  def concat(*records); end

  def construct_join_dependency(*args, &block); end

  def create_with(*args, &block); end

  def create_with!(*args, &block); end

  def create_with_value(*args, &block); end

  def create_with_value=(arg); end

  def delete(*records); end

  def delete_all(dependent=T.unsafe(nil)); end

  def destroy(*records); end

  def distinct(*args, &block); end

  def distinct!(*args, &block); end

  def distinct_value(*args, &block); end

  def distinct_value=(arg); end

  def eager_load(*args, &block); end

  def eager_load!(*args, &block); end

  def eager_load_values(*args, &block); end

  def eager_load_values=(arg); end

  def except(*args, &block); end

  def extending(*args, &block); end

  def extending!(*args, &block); end

  def extending_values(*args, &block); end

  def extending_values=(arg); end

  def extensions(*args, &block); end

  def extract_associated(*args, &block); end

  def from(*args, &block); end

  def from!(*args, &block); end

  def from_clause(*args, &block); end

  def from_clause=(arg); end

  def group(*args, &block); end

  def group!(*args, &block); end

  def group_values(*args, &block); end

  def group_values=(arg); end

  def having(*args, &block); end

  def having!(*args, &block); end

  def having_clause(*args, &block); end

  def having_clause=(arg); end

  def include?(record); end

  def includes(*args, &block); end

  def includes!(*args, &block); end

  def includes_values(*args, &block); end

  def includes_values=(arg); end

  def initialize(klass, association); end

  def joins(*args, &block); end

  def joins!(*args, &block); end

  def joins_values(*args, &block); end

  def joins_values=(arg); end

  def left_joins(*args, &block); end

  def left_outer_joins(*args, &block); end

  def left_outer_joins!(*args, &block); end

  def left_outer_joins_values(*args, &block); end

  def left_outer_joins_values=(arg); end

  def limit(*args, &block); end

  def limit!(*args, &block); end

  def limit_value(*args, &block); end

  def limit_value=(arg); end

  def load_target(); end

  def lock(*args, &block); end

  def lock!(*args, &block); end

  def lock_value(*args, &block); end

  def lock_value=(arg); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def none(*args, &block); end

  def none!(*args, &block); end

  def offset(*args, &block); end

  def offset!(*args, &block); end

  def offset_value(*args, &block); end

  def offset_value=(arg); end

  def only(*args, &block); end

  def optimizer_hints(*args, &block); end

  def optimizer_hints!(*args, &block); end

  def optimizer_hints_values(*args, &block); end

  def optimizer_hints_values=(arg); end

  def or(*args, &block); end

  def or!(*args, &block); end

  def order(*args, &block); end

  def order!(*args, &block); end

  def order_values(*args, &block); end

  def order_values=(arg); end

  def preload(*args, &block); end

  def preload!(*args, &block); end

  def preload_values(*args, &block); end

  def preload_values=(arg); end

  def prepend(*args); end

  def proxy_association(); end

  def push(*records); end

  def readonly(*args, &block); end

  def readonly!(*args, &block); end

  def readonly_value(*args, &block); end

  def readonly_value=(arg); end

  def references(*args, &block); end

  def references!(*args, &block); end

  def references_values(*args, &block); end

  def references_values=(arg); end

  def reorder(*args, &block); end

  def reorder!(*args, &block); end

  def reordering_value(*args, &block); end

  def reordering_value=(arg); end

  def replace(other_array); end

  def reselect(*args, &block); end

  def reselect!(*args, &block); end

  def reset_scope(); end

  def reverse_order(*args, &block); end

  def reverse_order!(*args, &block); end

  def reverse_order_value(*args, &block); end

  def reverse_order_value=(arg); end

  def rewhere(*args, &block); end

  def scope(); end

  def scoping(*args, &block); end

  def select_values(*args, &block); end

  def select_values=(arg); end

  def skip_preloading!(*args, &block); end

  def skip_query_cache!(*args, &block); end

  def skip_query_cache_value(*args, &block); end

  def skip_query_cache_value=(arg); end

  def spawn(*args, &block); end

  def target(); end

  def unscope(*args, &block); end

  def unscope!(*args, &block); end

  def unscope_values(*args, &block); end

  def unscope_values=(arg); end

  def values(*args, &block); end

  def where(*args, &block); end

  def where!(*args, &block); end

  def where_clause(*args, &block); end

  def where_clause=(arg); end
end

class ActiveRecord::Associations::CollectionProxy
end

module ActiveRecord::Associations::ForeignAssociation
  def foreign_key_present?(); end

  def nullified_owner_attributes(); end
end

module ActiveRecord::Associations::ForeignAssociation
end

class ActiveRecord::Associations::HasManyAssociation
  include ::ActiveRecord::Associations::ForeignAssociation
  def handle_dependency(); end

  def insert_record(record, validate=T.unsafe(nil), raise=T.unsafe(nil)); end
end

class ActiveRecord::Associations::HasManyAssociation
end

class ActiveRecord::Associations::HasManyThroughAssociation
  include ::ActiveRecord::Associations::ThroughAssociation
end

class ActiveRecord::Associations::HasManyThroughAssociation
end

class ActiveRecord::Associations::HasOneAssociation
  include ::ActiveRecord::Associations::ForeignAssociation
  def delete(method=T.unsafe(nil)); end

  def handle_dependency(); end
end

class ActiveRecord::Associations::HasOneAssociation
end

class ActiveRecord::Associations::HasOneThroughAssociation
  include ::ActiveRecord::Associations::ThroughAssociation
end

class ActiveRecord::Associations::HasOneThroughAssociation
end

class ActiveRecord::Associations::JoinDependency
  def apply_column_aliases(relation); end

  def base_klass(); end

  def initialize(base, table, associations, join_type); end

  def instantiate(result_set, &block); end

  def join_constraints(joins_to_add, alias_tracker); end

  def join_root(); end

  def join_type(); end

  def reflections(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases
  def column_alias(node, column); end

  def column_aliases(node); end

  def columns(); end

  def initialize(tables); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column
  def alias(); end

  def alias=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table
  def column_aliases(); end

  def columns(); end

  def columns=(_); end

  def node(); end

  def node=(_); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation
  def initialize(reflection, children); end

  def join_constraints(foreign_table, foreign_klass, join_type, alias_tracker); end

  def readonly?(); end

  def reflection(); end

  def table=(table); end

  def tables(); end

  def tables=(tables); end
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation
end

class ActiveRecord::Associations::JoinDependency::JoinBase
  def initialize(base_klass, table, children); end
end

class ActiveRecord::Associations::JoinDependency::JoinBase
end

class ActiveRecord::Associations::JoinDependency::JoinPart
  include ::Enumerable
  def base_klass(); end

  def children(); end

  def column_names(*args, &block); end

  def each(&block); end

  def each_children(&block); end

  def extract_record(row, column_names_with_alias); end

  def initialize(base_klass, children); end

  def instantiate(row, aliases, &block); end

  def match?(other); end

  def primary_key(*args, &block); end

  def table(); end

  def table_name(*args, &block); end
end

class ActiveRecord::Associations::JoinDependency::JoinPart
end

class ActiveRecord::Associations::JoinDependency
  def self.make_tree(associations); end

  def self.walk_tree(associations, hash); end
end

class ActiveRecord::Associations::Preloader
  def preload(records, associations, preload_scope=T.unsafe(nil)); end
end

class ActiveRecord::Associations::Preloader::AlreadyLoaded
  def initialize(klass, owners, reflection, preload_scope); end

  def preloaded_records(); end

  def records_by_owner(); end

  def run(); end
end

class ActiveRecord::Associations::Preloader::AlreadyLoaded
end

class ActiveRecord::Associations::Preloader::Association
  def initialize(klass, owners, reflection, preload_scope); end

  def preloaded_records(); end

  def records_by_owner(); end

  def run(); end
end

class ActiveRecord::Associations::Preloader::Association
end

class ActiveRecord::Associations::Preloader::ThroughAssociation
  def initialize(*_); end
  PRELOADER = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Associations::Preloader::ThroughAssociation
end

class ActiveRecord::Associations::Preloader
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Associations::SingularAssociation
  def build(attributes=T.unsafe(nil), &block); end

  def force_reload_reader(); end

  def reader(); end

  def writer(record); end
end

class ActiveRecord::Associations::SingularAssociation
end

module ActiveRecord::Associations::ThroughAssociation
  def source_reflection(*args, &block); end
end

module ActiveRecord::Associations::ThroughAssociation
end

module ActiveRecord::Associations
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeAssignment
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
end

module ActiveRecord::AttributeAssignment
end

class ActiveRecord::AttributeAssignmentError
  def attribute(); end

  def exception(); end

  def initialize(message=T.unsafe(nil), exception=T.unsafe(nil), attribute=T.unsafe(nil)); end
end

module ActiveRecord::AttributeDecorators
end

module ActiveRecord::AttributeDecorators::ClassMethods
  def decorate_attribute_type(column_name, decorator_name, &block); end

  def decorate_matching_attribute_types(matcher, decorator_name, &block); end
end

module ActiveRecord::AttributeDecorators::ClassMethods
end

class ActiveRecord::AttributeDecorators::TypeDecorator
  def apply(name, type); end

  def clear(*args, &block); end

  def initialize(decorations=T.unsafe(nil)); end

  def merge(*args); end
end

class ActiveRecord::AttributeDecorators::TypeDecorator
end

module ActiveRecord::AttributeDecorators
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  def [](attr_name); end

  def []=(attr_name, value); end

  def accessed_fields(); end

  def attribute_for_inspect(attr_name); end

  def attribute_names(); end

  def attribute_present?(attribute); end

  def attributes(); end

  def has_attribute?(attr_name); end

  def respond_to?(name, include_private=T.unsafe(nil)); end
  RESTRICTED_CLASS_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  def attributes_before_type_cast(); end

  def read_attribute_before_type_cast(attr_name); end
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::ClassMethods
  def attribute_method?(attribute); end

  def attribute_names(); end

  def class_method_defined_within?(name, klass, superklass=T.unsafe(nil)); end

  def column_for_attribute(name); end

  def dangerous_attribute_method?(name); end

  def dangerous_class_method?(method_name); end

  def define_attribute_methods(); end

  def has_attribute?(attr_name); end

  def inherited(child_class); end

  def initialize_generated_modules(); end

  def instance_method_already_implemented?(method_name); end

  def method_defined_within?(name, klass, superklass=T.unsafe(nil)); end

  def undefine_attribute_methods(); end
end

module ActiveRecord::AttributeMethods::ClassMethods
end

module ActiveRecord::AttributeMethods::Dirty
  def attribute_before_last_save(attr_name); end

  def attribute_change_to_be_saved(attr_name); end

  def attribute_in_database(attr_name); end

  def attributes_in_database(); end

  def changed_attribute_names_to_save(); end

  def changes_to_save(); end

  def has_changes_to_save?(); end

  def reload(*_); end

  def saved_change_to_attribute(attr_name); end

  def saved_changes(); end

  def saved_changes?(); end

  def will_save_change_to_attribute?(attr_name, **options); end
end

module ActiveRecord::AttributeMethods::Dirty
  extend ::ActiveSupport::Concern
end

class ActiveRecord::AttributeMethods::GeneratedAttributeMethods
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActiveRecord::AttributeMethods::GeneratedAttributeMethods
end

module ActiveRecord::AttributeMethods::PrimaryKey
  def id(); end

  def id=(value); end

  def id?(); end

  def id_before_type_cast(); end

  def id_in_database(); end

  def id_was(); end

  def to_key(); end
end

module ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  def dangerous_attribute_method?(method_name); end

  def get_primary_key(base_name); end

  def instance_method_already_implemented?(method_name); end

  def primary_key(); end

  def primary_key=(value); end

  def quoted_primary_key(); end

  def reset_primary_key(); end
  ID_ATTRIBUTE_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
end

module ActiveRecord::AttributeMethods::PrimaryKey
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Query
  def query_attribute(attr_name); end
end

module ActiveRecord::AttributeMethods::Query
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Read
  def _read_attribute(attr_name, &block); end

  def read_attribute(attr_name, &block); end
end

module ActiveRecord::AttributeMethods::Read::ClassMethods
end

module ActiveRecord::AttributeMethods::Read::ClassMethods
end

module ActiveRecord::AttributeMethods::Read
  extend ::ActiveSupport::Concern
end

class ActiveRecord::AttributeMethods::Serialization::ColumnNotSerializableError
  def initialize(name, type); end
end

class ActiveRecord::AttributeMethods::Serialization::ColumnNotSerializableError
end

module ActiveRecord::AttributeMethods::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
end

module ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
end

module ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
end

class ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter
  def cast(value); end

  def deserialize(value); end
end

class ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods::Write
  def _write_attribute(attr_name, value); end

  def write_attribute(attr_name, value); end
end

module ActiveRecord::AttributeMethods::Write::ClassMethods
end

module ActiveRecord::AttributeMethods::Write::ClassMethods
end

module ActiveRecord::AttributeMethods::Write
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::Attributes
end

module ActiveRecord::Attributes::ClassMethods
  def attribute(name, cast_type=T.unsafe(nil), **options); end

  def define_attribute(name, cast_type, default: T.unsafe(nil), user_provided_default: T.unsafe(nil)); end

  def load_schema!(); end
end

module ActiveRecord::Attributes::ClassMethods
end

module ActiveRecord::Attributes
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AutosaveAssociation
  def changed_for_autosave?(); end

  def destroyed_by_association(); end

  def destroyed_by_association=(reflection); end

  def mark_for_destruction(); end

  def marked_for_destruction?(); end

  def reload(options=T.unsafe(nil)); end
end

module ActiveRecord::AutosaveAssociation::AssociationBuilderExtension
end

module ActiveRecord::AutosaveAssociation::AssociationBuilderExtension
  def self.build(model, reflection); end

  def self.valid_options(); end
end

module ActiveRecord::AutosaveAssociation::ClassMethods
end

module ActiveRecord::AutosaveAssociation::ClassMethods
end

module ActiveRecord::AutosaveAssociation
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Base
  include ::ActiveRecord::Core
  include ::ActiveRecord::ReadonlyAttributes
  include ::ActiveRecord::ModelSchema
  include ::ActiveRecord::Sanitization
  include ::ActiveRecord::AttributeAssignment
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::Conversion
  include ::ActiveRecord::Integration
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::Validations
  include ::ActiveRecord::CounterCache
  include ::ActiveRecord::Attributes
  include ::ActiveRecord::AttributeDecorators
  include ::ActiveRecord::Locking::Optimistic
  include ::ActiveRecord::DefineCallbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::Base::GeneratedAttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::Callbacks
  include ::ActiveRecord::Timestamp
  include ::ActiveModel::SecurePassword
  include ::ActiveRecord::AutosaveAssociation
  include ::ActiveRecord::TouchLater
  include ::ActiveRecord::NoTouching
  include ::ActiveRecord::Reflection
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  include ::ActiveRecord::Serialization
  include ::ActiveRecord::Store
  include ::ActiveRecord::SecureToken
  include ::ActiveRecord::Suppressor
  include ::GlobalID::Identification
  include ::ActiveStorage::Attached::Model
  include ::ActiveStorage::Reflection::ActiveRecordExtensions
  include ::ActionText::Attribute
  def __callbacks(); end

  def __callbacks?(); end

  def _before_commit_callbacks(); end

  def _before_commit_without_transaction_enrollment_callbacks(); end

  def _commit_callbacks(); end

  def _commit_without_transaction_enrollment_callbacks(); end

  def _create_callbacks(); end

  def _destroy_callbacks(); end

  def _find_callbacks(); end

  def _initialize_callbacks(); end

  def _reflections(); end

  def _reflections?(); end

  def _rollback_callbacks(); end

  def _rollback_without_transaction_enrollment_callbacks(); end

  def _run_before_commit_callbacks(&block); end

  def _run_before_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_commit_callbacks(&block); end

  def _run_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_rollback_callbacks(&block); end

  def _run_rollback_without_transaction_enrollment_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _touch_callbacks(); end

  def _update_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def aggregate_reflections(); end

  def aggregate_reflections?(); end

  def allow_unsafe_raw_sql(); end

  def attachment_reflections(); end

  def attachment_reflections?(); end

  def attribute_aliases(); end

  def attribute_aliases?(); end

  def attribute_method_matchers(); end

  def attribute_method_matchers?(); end

  def cache_timestamp_format(); end

  def cache_timestamp_format?(); end

  def cache_versioning(); end

  def cache_versioning?(); end

  def collection_cache_versioning(); end

  def collection_cache_versioning?(); end

  def column_for_attribute(*args, &block); end

  def default_connection_handler(); end

  def default_connection_handler?(); end

  def default_scope_override(); end

  def default_scopes(); end

  def default_timezone(); end

  def defined_enums(); end

  def defined_enums?(); end

  def dump_schema_after_migration(); end

  def dump_schemas(); end

  def error_on_ignored_order(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def index_nested_attribute_errors(); end

  def lock_optimistically(); end

  def lock_optimistically?(); end

  def logger(); end

  def model_name(*args, &block); end

  def nested_attributes_options(); end

  def nested_attributes_options?(); end

  def partial_writes(); end

  def partial_writes?(); end

  def pluralize_table_names(); end

  def pluralize_table_names?(); end

  def primary_key_prefix_type(); end

  def record_timestamps(); end

  def record_timestamps=(val); end

  def record_timestamps?(); end

  def schema_format(); end

  def skip_time_zone_conversion_for_attributes(); end

  def skip_time_zone_conversion_for_attributes?(); end

  def store_full_sti_class(); end

  def store_full_sti_class?(); end

  def table_name_prefix(); end

  def table_name_prefix?(); end

  def table_name_suffix(); end

  def table_name_suffix?(); end

  def time_zone_aware_attributes(); end

  def time_zone_aware_types(); end

  def time_zone_aware_types?(); end

  def timestamped_migrations(); end

  def type_for_attribute(*args, &block); end

  def validation_context(); end

  def verbose_query_logs(); end

  def warn_on_records_fetched_greater_than(); end
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::Base
  extend ::ActiveSupport::Benchmarkable
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveRecord::ConnectionHandling
  extend ::ActiveRecord::QueryCache::ClassMethods
  extend ::ActiveRecord::Querying
  extend ::ActiveRecord::Translation
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveRecord::DynamicMatchers
  extend ::ActiveRecord::Explain
  extend ::ActiveRecord::Enum
  extend ::ActiveRecord::Delegation::DelegateCache
  extend ::ActiveRecord::Aggregations::ClassMethods
  extend ::ActiveRecord::Core::ClassMethods
  extend ::ActiveRecord::ReadonlyAttributes::ClassMethods
  extend ::ActiveRecord::ModelSchema::ClassMethods
  extend ::ActiveRecord::Scoping::ClassMethods
  extend ::ActiveRecord::Sanitization::ClassMethods
  extend ::ActiveRecord::Integration::ClassMethods
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveRecord::Validations::ClassMethods
  extend ::ActiveRecord::CounterCache::ClassMethods
  extend ::ActiveRecord::Attributes::ClassMethods
  extend ::ActiveRecord::AttributeDecorators::ClassMethods
  extend ::ActiveRecord::DefineCallbacks::ClassMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveModel::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Read::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Write::ClassMethods
  extend ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  extend ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  extend ::ActiveRecord::Timestamp::ClassMethods
  extend ::ActiveModel::SecurePassword::ClassMethods
  extend ::ActiveRecord::AutosaveAssociation::ClassMethods
  extend ::ActiveRecord::NoTouching::ClassMethods
  extend ::ActiveRecord::Reflection::ClassMethods
  extend ::ActiveRecord::Store::ClassMethods
  extend ::ActiveRecord::SecureToken::ClassMethods
  extend ::ActiveRecord::Suppressor::ClassMethods
  extend ::ActionText::Attribute::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._attr_readonly(); end

  def self._attr_readonly=(val); end

  def self._attr_readonly?(); end

  def self._before_commit_callbacks(); end

  def self._before_commit_callbacks=(value); end

  def self._before_commit_without_transaction_enrollment_callbacks(); end

  def self._before_commit_without_transaction_enrollment_callbacks=(value); end

  def self._commit_callbacks(); end

  def self._commit_callbacks=(value); end

  def self._commit_without_transaction_enrollment_callbacks(); end

  def self._commit_without_transaction_enrollment_callbacks=(value); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._reflections(); end

  def self._reflections=(val); end

  def self._reflections?(); end

  def self._rollback_callbacks(); end

  def self._rollback_callbacks=(value); end

  def self._rollback_without_transaction_enrollment_callbacks(); end

  def self._rollback_without_transaction_enrollment_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.after_find(*args, **options, &block); end

  def self.after_initialize(*args, **options, &block); end

  def self.after_touch(*args, **options, &block); end

  def self.aggregate_reflections(); end

  def self.aggregate_reflections=(val); end

  def self.aggregate_reflections?(); end

  def self.allow_unsafe_raw_sql(); end

  def self.allow_unsafe_raw_sql=(obj); end

  def self.attachment_reflections(); end

  def self.attachment_reflections=(val); end

  def self.attachment_reflections?(); end

  def self.attribute_aliases(); end

  def self.attribute_aliases=(val); end

  def self.attribute_aliases?(); end

  def self.attribute_method_matchers(); end

  def self.attribute_method_matchers=(val); end

  def self.attribute_method_matchers?(); end

  def self.attribute_type_decorations(); end

  def self.attribute_type_decorations=(val); end

  def self.attribute_type_decorations?(); end

  def self.attributes_to_define_after_schema_loads(); end

  def self.attributes_to_define_after_schema_loads=(val); end

  def self.attributes_to_define_after_schema_loads?(); end

  def self.belongs_to_required_by_default(); end

  def self.belongs_to_required_by_default=(obj); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(val); end

  def self.cache_timestamp_format?(); end

  def self.cache_versioning(); end

  def self.cache_versioning=(val); end

  def self.cache_versioning?(); end

  def self.collection_cache_versioning(); end

  def self.collection_cache_versioning=(val); end

  def self.collection_cache_versioning?(); end

  def self.configurations(); end

  def self.configurations=(config); end

  def self.connection_handler(); end

  def self.connection_handler=(handler); end

  def self.connection_handlers(); end

  def self.connection_handlers=(obj); end

  def self.default_connection_handler(); end

  def self.default_connection_handler=(val); end

  def self.default_connection_handler?(); end

  def self.default_scope_override(); end

  def self.default_scope_override=(val); end

  def self.default_scopes(); end

  def self.default_scopes=(val); end

  def self.default_timezone(); end

  def self.default_timezone=(obj); end

  def self.defined_enums(); end

  def self.defined_enums=(val); end

  def self.defined_enums?(); end

  def self.dump_schema_after_migration(); end

  def self.dump_schema_after_migration=(obj); end

  def self.dump_schemas(); end

  def self.dump_schemas=(obj); end

  def self.error_on_ignored_order(); end

  def self.error_on_ignored_order=(obj); end

  def self.implicit_order_column(); end

  def self.implicit_order_column=(val); end

  def self.implicit_order_column?(); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(val); end

  def self.include_root_in_json?(); end

  def self.index_nested_attribute_errors(); end

  def self.index_nested_attribute_errors=(obj); end

  def self.internal_metadata_table_name(); end

  def self.internal_metadata_table_name=(val); end

  def self.internal_metadata_table_name?(); end

  def self.local_stored_attributes(); end

  def self.local_stored_attributes=(local_stored_attributes); end

  def self.lock_optimistically(); end

  def self.lock_optimistically=(val); end

  def self.lock_optimistically?(); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.maintain_test_schema(); end

  def self.maintain_test_schema=(obj); end

  def self.nested_attributes_options(); end

  def self.nested_attributes_options=(val); end

  def self.nested_attributes_options?(); end

  def self.partial_writes(); end

  def self.partial_writes=(val); end

  def self.partial_writes?(); end

  def self.pluralize_table_names(); end

  def self.pluralize_table_names=(val); end

  def self.pluralize_table_names?(); end

  def self.primary_key_prefix_type(); end

  def self.primary_key_prefix_type=(obj); end

  def self.reading_role(); end

  def self.reading_role=(obj); end

  def self.record_timestamps(); end

  def self.record_timestamps=(val); end

  def self.record_timestamps?(); end

  def self.schema_format(); end

  def self.schema_format=(obj); end

  def self.schema_migrations_table_name(); end

  def self.schema_migrations_table_name=(val); end

  def self.schema_migrations_table_name?(); end

  def self.skip_time_zone_conversion_for_attributes(); end

  def self.skip_time_zone_conversion_for_attributes=(val); end

  def self.skip_time_zone_conversion_for_attributes?(); end

  def self.store_full_sti_class(); end

  def self.store_full_sti_class=(val); end

  def self.store_full_sti_class?(); end

  def self.table_name_prefix(); end

  def self.table_name_prefix=(val); end

  def self.table_name_prefix?(); end

  def self.table_name_suffix(); end

  def self.table_name_suffix=(val); end

  def self.table_name_suffix?(); end

  def self.time_zone_aware_attributes(); end

  def self.time_zone_aware_attributes=(obj); end

  def self.time_zone_aware_types(); end

  def self.time_zone_aware_types=(val); end

  def self.time_zone_aware_types?(); end

  def self.timestamped_migrations(); end

  def self.timestamped_migrations=(obj); end

  def self.verbose_query_logs(); end

  def self.verbose_query_logs=(obj); end

  def self.warn_on_records_fetched_greater_than(); end

  def self.warn_on_records_fetched_greater_than=(obj); end

  def self.writing_role(); end

  def self.writing_role=(obj); end
end

module ActiveRecord::Batches
  def find_each(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  def find_in_batches(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  def in_batches(of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), load: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Batches::BatchEnumerator
  include ::Enumerable
  def delete_all(*args, &block); end

  def destroy_all(*args, &block); end

  def each(&blk); end

  def each_record(); end

  def initialize(relation:, of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil)); end

  def update_all(*args, &block); end
end

class ActiveRecord::Batches::BatchEnumerator
end

module ActiveRecord::Batches
end

module ActiveRecord::Calculations
  def average(column_name); end

  def calculate(operation, column_name); end

  def count(column_name=T.unsafe(nil)); end

  def ids(); end

  def maximum(column_name); end

  def minimum(column_name); end

  def pick(*column_names); end

  def pluck(*column_names); end

  def sum(column_name=T.unsafe(nil)); end
end

module ActiveRecord::Calculations
end

module ActiveRecord::Callbacks
  def destroy(); end

  def increment!(attribute, by=T.unsafe(nil), touch: T.unsafe(nil)); end

  def touch(*_); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Coders
end

class ActiveRecord::Coders::JSON
end

class ActiveRecord::Coders::JSON
  def self.dump(obj); end

  def self.load(json); end
end

class ActiveRecord::Coders::YAMLColumn
  def assert_valid_value(obj, action:); end

  def dump(obj); end

  def initialize(attr_name, object_class=T.unsafe(nil)); end

  def load(yaml); end

  def object_class(); end

  def object_class=(object_class); end
end

class ActiveRecord::Coders::YAMLColumn
end

module ActiveRecord::Coders
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  def __callbacks(); end

  def __callbacks?(); end

  def _checkin_callbacks(); end

  def _checkout_callbacks(); end

  def _run_checkin_callbacks(&block); end

  def _run_checkout_callbacks(&block); end

  def active?(); end

  def adapter_name(); end

  def advisory_locks_enabled?(); end

  def build_insert_sql(insert); end

  def case_insensitive_comparison(attribute, value); end

  def case_sensitive_comparison(attribute, value); end

  def check_version(); end

  def clear_cache!(); end

  def close(); end

  def column_name_for_operation(operation, node); end

  def database_version(); end

  def default_index_type?(index); end

  def default_uniqueness_comparison(attribute, value, klass); end

  def delete(*_); end

  def disable_extension(name); end

  def disable_referential_integrity(); end

  def discard!(); end

  def disconnect!(); end

  def enable_extension(name); end

  def exec_insert_all(*_); end

  def expire(); end

  def extensions(); end

  def get_advisory_lock(lock_id); end

  def get_database_version(); end

  def in_use?(); end

  def index_algorithms(); end

  def initialize(connection, logger=T.unsafe(nil), config=T.unsafe(nil)); end

  def insert(*_); end

  def lease(); end

  def lock(); end

  def logger(); end

  def migration_context(); end

  def migrations_paths(); end

  def owner(); end

  def pool(); end

  def pool=(pool); end

  def prefetch_primary_key?(table_name=T.unsafe(nil)); end

  def prepared_statements(); end

  def prepared_statements_disabled_cache(); end

  def preventing_writes?(); end

  def raw_connection(); end

  def reconnect!(); end

  def release_advisory_lock(lock_id); end

  def replica?(); end

  def requires_reloading?(); end

  def reset!(); end

  def rollback_db_transaction(*_); end

  def rollback_to_savepoint(*_); end

  def schema_cache(); end

  def schema_cache=(cache); end

  def schema_migration(); end

  def seconds_idle(); end

  def steal!(); end

  def supports_advisory_locks?(); end

  def supports_bulk_alter?(); end

  def supports_comments?(); end

  def supports_comments_in_create?(); end

  def supports_common_table_expressions?(); end

  def supports_datetime_with_precision?(); end

  def supports_ddl_transactions?(); end

  def supports_explain?(); end

  def supports_expression_index?(); end

  def supports_extensions?(); end

  def supports_foreign_keys?(); end

  def supports_foreign_keys_in_create?(*args, &block); end

  def supports_foreign_tables?(); end

  def supports_index_sort_order?(); end

  def supports_indexes_in_create?(); end

  def supports_insert_conflict_target?(); end

  def supports_insert_on_duplicate_skip?(); end

  def supports_insert_on_duplicate_update?(); end

  def supports_insert_returning?(); end

  def supports_json?(); end

  def supports_lazy_transactions?(); end

  def supports_materialized_views?(); end

  def supports_multi_insert?(*args, &block); end

  def supports_optimizer_hints?(); end

  def supports_partial_index?(); end

  def supports_savepoints?(); end

  def supports_transaction_isolation?(); end

  def supports_validate_constraints?(); end

  def supports_views?(); end

  def supports_virtual_columns?(); end

  def truncate(*_); end

  def truncate_tables(*_); end

  def unprepared_statement(); end

  def update(*_); end

  def valid_type?(type); end

  def verify!(); end

  def visitor(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
  def accept(o); end

  def initialize(conn); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable
  def full_version_string(); end

  def initialize(version_string, full_version_string=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._checkin_callbacks(); end

  def self._checkin_callbacks=(value); end

  def self._checkout_callbacks(); end

  def self._checkout_callbacks=(value); end

  def self.build_read_query_regexp(*parts); end

  def self.database_exists?(config); end

  def self.quoted_column_names(); end

  def self.quoted_table_names(); end

  def self.type_cast_config_to_boolean(config); end

  def self.type_cast_config_to_integer(config); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
  def get_schema_cache(connection); end

  def set_schema_cache(cache); end
end

module ActiveRecord::ConnectionAdapters::AbstractPool
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def column(); end

  def column=(_); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
  def add_column(name, type, options); end

  def add_foreign_key(to_table, options); end

  def adds(); end

  def drop_foreign_key(name); end

  def foreign_key_adds(); end

  def foreign_key_drops(); end

  def initialize(td); end

  def name(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def column(); end

  def column=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::Column
  def ==(other); end

  def bigint?(); end

  def collation(); end

  def comment(); end

  def default(); end

  def default_function(); end

  def encode_with(coder); end

  def eql?(other); end

  def has_default?(); end

  def human_name(); end

  def init_with(coder); end

  def initialize(name, default, sql_type_metadata=T.unsafe(nil), null=T.unsafe(nil), default_function=T.unsafe(nil), collation: T.unsafe(nil), comment: T.unsafe(nil), **_); end

  def limit(*args, &block); end

  def name(); end

  def null(); end

  def precision(*args, &block); end

  def scale(*args, &block); end

  def sql_type(*args, &block); end

  def sql_type_metadata(); end

  def type(*args, &block); end
end

class ActiveRecord::ConnectionAdapters::Column
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def collation(); end

  def collation=(value); end

  def comment(); end

  def comment=(value); end

  def default(); end

  def default=(value); end

  def limit(); end

  def limit=(value); end

  def name(); end

  def name=(_); end

  def null(); end

  def null=(value); end

  def options(); end

  def options=(_); end

  def precision(); end

  def precision=(value); end

  def primary_key?(); end

  def scale(); end

  def scale=(value); end

  def sql_type(); end

  def sql_type=(_); end

  def type(); end

  def type=(_); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def active_connections?(); end

  def clear_active_connections!(); end

  def clear_all_connections!(); end

  def clear_reloadable_connections!(); end

  def connected?(spec_name); end

  def connection_pool_list(); end

  def connection_pools(); end

  def establish_connection(config); end

  def flush_idle_connections!(); end

  def prevent_writes(); end

  def prevent_writes=(prevent_writes); end

  def remove_connection(spec_name); end

  def retrieve_connection(spec_name); end

  def retrieve_connection_pool(spec_name); end

  def while_preventing_writes(enabled=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def self.create_owner_to_pool(); end

  def self.discard_unowned_pools(pid_map); end

  def self.unowned_pool_finalizer(pid_map); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
  include ::MonitorMixin
  include ::ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  include ::ActiveRecord::ConnectionAdapters::AbstractPool
  def active_connection?(); end

  def automatic_reconnect(); end

  def automatic_reconnect=(automatic_reconnect); end

  def checkin(conn); end

  def checkout(checkout_timeout=T.unsafe(nil)); end

  def checkout_timeout(); end

  def checkout_timeout=(checkout_timeout); end

  def clear_reloadable_connections(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def clear_reloadable_connections!(); end

  def connected?(); end

  def connection(); end

  def connections(); end

  def discard!(); end

  def disconnect(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def disconnect!(); end

  def flush(minimum_idle=T.unsafe(nil)); end

  def flush!(); end

  def initialize(spec); end

  def lock_thread=(lock_thread); end

  def num_waiting_in_queue(); end

  def reap(); end

  def reaper(); end

  def release_connection(owner_thread=T.unsafe(nil)); end

  def remove(conn); end

  def schema_cache(); end

  def schema_cache=(schema_cache); end

  def size(); end

  def spec(); end

  def stat(); end

  def with_connection(); end
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  def with_a_bias_for(thread); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  def broadcast(); end

  def broadcast_on_biased(); end

  def initialize(lock, other_cond, preferred_thread); end

  def signal(); end

  def wait(timeout); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
  include ::ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  def add(element); end

  def any_waiting?(); end

  def clear(); end

  def delete(element); end

  def initialize(lock=T.unsafe(nil)); end

  def num_waiting(); end

  def poll(timeout=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def frequency(); end

  def initialize(pool, frequency); end

  def pool(); end

  def run(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def self.register_pool(pool, frequency); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
  def adapter_method(); end

  def config(); end

  def initialize(name, config, adapter_method); end

  def name(); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
  def initialize(url); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
  def configurations(); end

  def initialize(configurations); end

  def resolve(config_or_env, pool_name=T.unsafe(nil)); end

  def spec(config); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  def allowed_index_name_length(); end

  def column_name_length(*args, &block); end

  def columns_per_multicolumn_index(*args, &block); end

  def columns_per_table(*args, &block); end

  def in_clause_length(); end

  def index_name_length(); end

  def indexes_per_table(*args, &block); end

  def joins_per_query(*args, &block); end

  def max_identifier_length(); end

  def sql_query_length(*args, &block); end

  def table_alias_length(); end

  def table_name_length(*args, &block); end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def add_transaction_record(record); end

  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*args, &block); end

  def cacheable_query(klass, arel); end

  def commit_db_transaction(); end

  def commit_transaction(*args, &block); end

  def create(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def current_transaction(*args, &block); end

  def default_sequence_name(table, column); end

  def delete(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def disable_lazy_transactions!(*args, &block); end

  def empty_insert_statement_value(primary_key=T.unsafe(nil)); end

  def enable_lazy_transactions!(*args, &block); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_insert_all(sql, name); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def initialize(); end

  def insert(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def insert_fixture(fixture, table_name); end

  def insert_fixtures_set(fixture_set, tables_to_delete=T.unsafe(nil)); end

  def materialize_transactions(*args, &block); end

  def open_transactions(*args, &block); end

  def query(sql, name=T.unsafe(nil)); end

  def query_value(sql, name=T.unsafe(nil)); end

  def query_values(sql, name=T.unsafe(nil)); end

  def reset_sequence!(table, column, sequence=T.unsafe(nil)); end

  def reset_transaction(); end

  def rollback_db_transaction(); end

  def rollback_to_savepoint(name=T.unsafe(nil)); end

  def rollback_transaction(*args, &block); end

  def sanitize_limit(limit); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def select_one(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_rows(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_value(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_values(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def to_sql(arel_or_sql_string, binds=T.unsafe(nil)); end

  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end

  def transaction_isolation_levels(); end

  def transaction_manager(); end

  def transaction_open?(); end

  def transaction_state(); end

  def truncate(table_name, name=T.unsafe(nil)); end

  def truncate_tables(*table_names); end

  def update(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def with_yaml_fallback(value); end

  def within_new_transaction(*args, &block); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
  def accept(object, collector); end

  def preparable(); end

  def preparable=(preparable); end

  def visit_Arel_Nodes_In(o, collector); end

  def visit_Arel_Nodes_NotIn(o, collector); end

  def visit_Arel_Nodes_SqlLiteral(o, collector); end
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def column(); end

  def custom_primary_key?(); end

  def defined_for?(to_table: T.unsafe(nil), **options); end

  def export_name_on_schema_dump?(); end

  def from_table(); end

  def from_table=(_); end

  def name(); end

  def on_delete(); end

  def on_update(); end

  def options(); end

  def options=(_); end

  def primary_key(); end

  def to_table(); end

  def to_table=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
  def columns(); end

  def comment(); end

  def initialize(table, name, unique=T.unsafe(nil), columns=T.unsafe(nil), lengths: T.unsafe(nil), orders: T.unsafe(nil), opclasses: T.unsafe(nil), where: T.unsafe(nil), type: T.unsafe(nil), using: T.unsafe(nil), comment: T.unsafe(nil)); end

  def lengths(); end

  def name(); end

  def opclasses(); end

  def orders(); end

  def table(); end

  def type(); end

  def unique(); end

  def using(); end

  def where(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
end

class ActiveRecord::ConnectionAdapters::NullPool
  include ::ActiveRecord::ConnectionAdapters::AbstractPool
end

class ActiveRecord::ConnectionAdapters::NullPool
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  def add_record(record); end

  def closed?(); end

  def joinable?(); end

  def open?(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def cache(); end

  def clear_query_cache(); end

  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache(); end

  def query_cache_enabled(); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def uncached(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache_enabled(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def self.dirties_query_cache(base, *method_names); end

  def self.included(base); end
end

module ActiveRecord::ConnectionAdapters::Quoting
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_column_name(column_name); end

  def quote_default_expression(value, column); end

  def quote_string(s); end

  def quote_table_name(table_name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def quoted_false(); end

  def quoted_time(value); end

  def quoted_true(); end

  def sanitize_as_sql_comment(value); end

  def type_cast(value, column=T.unsafe(nil)); end

  def type_cast_from_column(column, value); end

  def unquoted_false(); end

  def unquoted_true(); end
end

module ActiveRecord::ConnectionAdapters::Quoting
end

class ActiveRecord::ConnectionAdapters::RealTransaction
  def commit(); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::RealTransaction
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  def add_to(table); end

  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
end

module ActiveRecord::ConnectionAdapters::SQLite3
end

module ActiveRecord::ConnectionAdapters::SQLite3::DatabaseStatements
  def begin_db_transaction(); end

  def commit_db_transaction(); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::SQLite3::DatabaseStatements
end

class ActiveRecord::ConnectionAdapters::SQLite3::ExplainPrettyPrinter
  def pp(result); end
end

class ActiveRecord::ConnectionAdapters::SQLite3::ExplainPrettyPrinter
end

module ActiveRecord::ConnectionAdapters::SQLite3::Quoting
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def quote_column_name(name); end

  def quote_string(s); end

  def quote_table_name(name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_false(); end

  def quoted_time(value); end

  def quoted_true(); end

  def unquoted_false(); end

  def unquoted_true(); end
end

module ActiveRecord::ConnectionAdapters::SQLite3::Quoting
end

class ActiveRecord::ConnectionAdapters::SQLite3::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::SQLite3::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::SQLite3::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::SQLite3::SchemaDumper
end

module ActiveRecord::ConnectionAdapters::SQLite3::SchemaStatements
  def add_foreign_key(from_table, to_table, **options); end

  def create_schema_dumper(options); end

  def indexes(table_name); end

  def remove_foreign_key(from_table, to_table=T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::SQLite3::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::SQLite3::TableDefinition
end

class ActiveRecord::ConnectionAdapters::SQLite3::TableDefinition
end

module ActiveRecord::ConnectionAdapters::SQLite3
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter
  include ::ActiveRecord::ConnectionAdapters::SQLite3::Quoting
  include ::ActiveRecord::ConnectionAdapters::SQLite3::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::SQLite3::DatabaseStatements
  def add_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def encoding(); end

  def explain(arel, binds=T.unsafe(nil)); end

  def initialize(connection, logger, connection_options, config); end

  def primary_keys(table_name); end

  def supports_insert_on_conflict?(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  COLLATE_REGEX = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter::SQLite3Integer
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter::SQLite3Integer
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter::StatementPool
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter::StatementPool
end

class ActiveRecord::ConnectionAdapters::SQLite3Adapter
  def self.represent_boolean_as_integer=(value); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
  def commit(); end

  def initialize(connection, savepoint_name, parent_transaction, *args); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
end

module ActiveRecord::ConnectionAdapters::Savepoints
  def create_savepoint(name=T.unsafe(nil)); end

  def current_savepoint_name(); end

  def exec_rollback_to_savepoint(name=T.unsafe(nil)); end

  def release_savepoint(name=T.unsafe(nil)); end
end

module ActiveRecord::ConnectionAdapters::Savepoints
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def add(table_name); end

  def clear!(); end

  def clear_data_source_cache!(name); end

  def columns(table_name); end

  def columns_hash(table_name); end

  def columns_hash?(table_name); end

  def connection(); end

  def connection=(connection); end

  def data_source_exists?(name); end

  def data_sources(name); end

  def database_version(); end

  def encode_with(coder); end

  def indexes(table_name); end

  def init_with(coder); end

  def initialize(conn); end

  def marshal_dump(); end

  def marshal_load(array); end

  def primary_keys(table_name); end

  def size(); end

  def version(); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
end

ActiveRecord::ConnectionAdapters::SchemaCreation = ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation

class ActiveRecord::ConnectionAdapters::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  def self.create(connection, options); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, **options); end

  def add_foreign_key(from_table, to_table, options=T.unsafe(nil)); end

  def add_index(table_name, column_name, options=T.unsafe(nil)); end

  def add_index_options(table_name, column_name, comment: T.unsafe(nil), **options); end

  def add_reference(table_name, ref_name, **options); end

  def add_timestamps(table_name, options=T.unsafe(nil)); end

  def assume_migrated_upto_version(version, migrations_paths=T.unsafe(nil)); end

  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def change_table_comment(table_name, comment_or_changes); end

  def column_exists?(table_name, column_name, type=T.unsafe(nil), **options); end

  def columns(table_name); end

  def columns_for_distinct(columns, orders); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end

  def create_schema_dumper(options); end

  def create_table(table_name, **options); end

  def data_source_exists?(name); end

  def data_sources(); end

  def drop_join_table(table_1, table_2, options=T.unsafe(nil)); end

  def drop_table(table_name, options=T.unsafe(nil)); end

  def dump_schema_information(); end

  def foreign_key_column_for(table_name); end

  def foreign_key_exists?(from_table, to_table=T.unsafe(nil), **options); end

  def foreign_key_options(from_table, to_table, options); end

  def foreign_keys(table_name); end

  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def index_name(table_name, options); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def internal_string_options_for_primary_key(); end

  def native_database_types(); end

  def options_include_default?(options); end

  def primary_key(table_name); end

  def remove_belongs_to(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_column(table_name, column_name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def remove_columns(table_name, *column_names); end

  def remove_foreign_key(from_table, to_table=T.unsafe(nil), **options); end

  def remove_index(table_name, options=T.unsafe(nil)); end

  def remove_reference(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_timestamps(table_name, options=T.unsafe(nil)); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def table_alias_for(table_name); end

  def table_comment(table_name); end

  def table_exists?(table_name); end

  def table_options(table_name); end

  def tables(); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), **_); end

  def update_table_definition(table_name, base); end

  def view_exists?(view_name); end

  def views(); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  def ==(other); end

  def eql?(other); end

  def initialize(sql_type: T.unsafe(nil), type: T.unsafe(nil), limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  def limit(); end

  def precision(); end

  def scale(); end

  def sql_type(); end

  def type(); end
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
end

class ActiveRecord::ConnectionAdapters::StatementPool
  include ::Enumerable
  def [](key); end

  def []=(sql, stmt); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def initialize(statement_limit=T.unsafe(nil)); end

  def key?(key); end

  def length(); end
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::StatementPool
end

class ActiveRecord::ConnectionAdapters::Table
  def bigint(*names, **options); end

  def binary(*names, **options); end

  def boolean(*names, **options); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def initialize(table_name, base); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def numeric(*names, **options); end

  def string(*names, **options); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::Table
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  def as(); end

  def bigint(*names, **options); end

  def binary(*names, **options); end

  def boolean(*names, **options); end

  def comment(); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def foreign_key(table_name, options=T.unsafe(nil)); end

  def foreign_keys(); end

  def if_not_exists(); end

  def indexes(); end

  def initialize(conn, name, temporary: T.unsafe(nil), if_not_exists: T.unsafe(nil), options: T.unsafe(nil), as: T.unsafe(nil), comment: T.unsafe(nil), **_); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def name(); end

  def new_column_definition(name, type, **options); end

  def numeric(*names, **options); end

  def options(); end

  def primary_keys(name=T.unsafe(nil)); end

  def string(*names, **options); end

  def temporary(); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

class ActiveRecord::ConnectionAdapters::Transaction
  def add_record(record); end

  def before_commit_records(); end

  def closed?(); end

  def commit_records(); end

  def connection(); end

  def full_rollback?(); end

  def initialize(connection, options, run_commit_callbacks: T.unsafe(nil)); end

  def isolation_level(); end

  def joinable?(); end

  def materialize!(); end

  def materialized?(); end

  def open?(); end

  def records(); end

  def rollback_records(); end

  def savepoint_name(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::Transaction
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  def begin_transaction(options=T.unsafe(nil)); end

  def commit_transaction(); end

  def current_transaction(); end

  def disable_lazy_transactions!(); end

  def enable_lazy_transactions!(); end

  def initialize(connection); end

  def lazy_transactions_enabled?(); end

  def materialize_transactions(); end

  def open_transactions(); end

  def rollback_transaction(transaction=T.unsafe(nil)); end

  def within_new_transaction(options=T.unsafe(nil)); end
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionManager
end

class ActiveRecord::ConnectionAdapters::TransactionState
  def add_child(state); end

  def commit!(); end

  def committed?(); end

  def completed?(); end

  def finalized?(); end

  def full_commit!(); end

  def full_rollback!(); end

  def fully_committed?(); end

  def fully_completed?(); end

  def fully_rolledback?(); end

  def initialize(state=T.unsafe(nil)); end

  def nullify!(); end

  def rollback!(); end

  def rolledback?(); end
end

class ActiveRecord::ConnectionAdapters::TransactionState
end

module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::ConnectionHandling
  def clear_active_connections!(*args, &block); end

  def clear_all_connections!(*args, &block); end

  def clear_cache!(); end

  def clear_query_caches_for_current_thread(); end

  def clear_reloadable_connections!(*args, &block); end

  def connected?(); end

  def connected_to(database: T.unsafe(nil), role: T.unsafe(nil), prevent_writes: T.unsafe(nil), &blk); end

  def connected_to?(role:); end

  def connection(); end

  def connection_config(); end

  def connection_pool(); end

  def connection_specification_name(); end

  def connection_specification_name=(connection_specification_name); end

  def connects_to(database: T.unsafe(nil)); end

  def current_role(); end

  def establish_connection(config_or_env=T.unsafe(nil)); end

  def flush_idle_connections!(*args, &block); end

  def lookup_connection_handler(handler_key); end

  def primary_class?(); end

  def remove_connection(name=T.unsafe(nil)); end

  def resolve_config_for_connection(config_or_env); end

  def retrieve_connection(); end

  def sqlite3_connection(config); end

  def with_handler(handler_key, &blk); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionHandling
end

module ActiveRecord::Core
  def ==(comparison_object); end

  def blank?(); end

  def connection_handler(); end

  def encode_with(coder); end

  def eql?(comparison_object); end

  def freeze(); end

  def frozen?(); end

  def hash(); end

  def init_with(coder, &block); end

  def init_with_attributes(attributes, new_record=T.unsafe(nil)); end

  def initialize(attributes=T.unsafe(nil)); end

  def inspect(); end

  def present?(); end

  def pretty_print(pp); end

  def readonly!(); end

  def readonly?(); end

  def slice(*methods); end
end

module ActiveRecord::Core::ClassMethods
  def ===(object); end

  def _internal?(); end

  def arel_attribute(name, table=T.unsafe(nil)); end

  def arel_table(); end

  def filter_attributes(); end

  def filter_attributes=(filter_attributes); end

  def find(*ids); end

  def find_by(*args); end

  def find_by!(*args); end

  def generated_association_methods(); end

  def inherited(child_class); end

  def initialize_find_by_cache(); end

  def initialize_generated_modules(); end

  def inspect(); end

  def predicate_builder(); end

  def type_caster(); end
end

module ActiveRecord::Core::ClassMethods
end

module ActiveRecord::Core
  extend ::ActiveSupport::Concern
end

module ActiveRecord::CounterCache
end

module ActiveRecord::CounterCache::ClassMethods
  def decrement_counter(counter_name, id, touch: T.unsafe(nil)); end

  def increment_counter(counter_name, id, touch: T.unsafe(nil)); end

  def reset_counters(id, *counters, touch: T.unsafe(nil)); end

  def update_counters(id, counters); end
end

module ActiveRecord::CounterCache::ClassMethods
end

module ActiveRecord::CounterCache
  extend ::ActiveSupport::Concern
end

class ActiveRecord::DatabaseConfigurations
  def [](env=T.unsafe(nil)); end

  def any?(*args, &block); end

  def configs_for(env_name: T.unsafe(nil), spec_name: T.unsafe(nil), include_replicas: T.unsafe(nil)); end

  def configurations(); end

  def default_hash(env=T.unsafe(nil)); end

  def each(&blk); end

  def empty?(); end

  def find_db_config(env); end

  def first(); end

  def initialize(configurations=T.unsafe(nil)); end

  def to_h(); end
end

class ActiveRecord::DatabaseConfigurations::DatabaseConfig
  def env_name(); end

  def for_current_env?(); end

  def initialize(env_name, spec_name); end

  def migrations_paths(); end

  def replica?(); end

  def spec_name(); end

  def to_legacy_hash(); end

  def url_config?(); end
end

class ActiveRecord::DatabaseConfigurations::DatabaseConfig
end

class ActiveRecord::DatabaseConfigurations::HashConfig
  def config(); end

  def initialize(env_name, spec_name, config); end
end

class ActiveRecord::DatabaseConfigurations::HashConfig
end

class ActiveRecord::DatabaseConfigurations::InvalidConfigurationError
end

class ActiveRecord::DatabaseConfigurations::InvalidConfigurationError
end

class ActiveRecord::DatabaseConfigurations::UrlConfig
  def config(); end

  def initialize(env_name, spec_name, url, config=T.unsafe(nil)); end

  def url(); end
end

class ActiveRecord::DatabaseConfigurations::UrlConfig
end

class ActiveRecord::DatabaseConfigurations
end

module ActiveRecord::DefineCallbacks
end

module ActiveRecord::DefineCallbacks::ClassMethods
  include ::ActiveModel::Callbacks
end

module ActiveRecord::DefineCallbacks::ClassMethods
end

module ActiveRecord::DefineCallbacks
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Delegation
  def &(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def [](*args, &block); end

  def as_json(*args, &block); end

  def compact(*args, &block); end

  def connection(*args, &block); end

  def each(*args, &block); end

  def encode_with(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def index(*args, &block); end

  def join(*args, &block); end

  def length(*args, &block); end

  def primary_key(*args, &block); end

  def reverse(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def sample(*args, &block); end

  def shuffle(*args, &block); end

  def slice(*args, &block); end

  def split(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_sentence(*args, &block); end

  def to_xml(*args, &block); end

  def |(*args, &block); end
end

module ActiveRecord::Delegation::ClassMethods
  def create(klass, *args); end
end

module ActiveRecord::Delegation::ClassMethods
end

module ActiveRecord::Delegation::ClassSpecificRelation
end

module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  def name(); end
end

module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Delegation::DelegateCache
  def generate_relation_method(method); end

  def include_relation_methods(delegate); end

  def inherited(child_class); end

  def initialize_relation_delegate_cache(); end

  def relation_delegate_class(klass); end
end

module ActiveRecord::Delegation::DelegateCache
end

module ActiveRecord::Delegation
  extend ::ActiveSupport::Concern
end

class ActiveRecord::DeleteRestrictionError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

module ActiveRecord::DynamicMatchers
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::Method
  def attribute_names(); end

  def define(); end

  def initialize(model, name); end

  def model(); end

  def name(); end

  def valid?(); end
end

class ActiveRecord::DynamicMatchers::Method
  def self.match(model, name); end

  def self.matchers(); end

  def self.pattern(); end

  def self.prefix(); end

  def self.suffix(); end
end

module ActiveRecord::DynamicMatchers
end

class ActiveRecord::EagerLoadPolymorphicError
  def initialize(reflection=T.unsafe(nil)); end
end

module ActiveRecord::Enum
  def enum(definitions); end

  def inherited(base); end
end

class ActiveRecord::Enum::EnumType
  def assert_valid_value(value); end

  def initialize(name, mapping, subtype); end

  def type(*args, &block); end
end

class ActiveRecord::Enum::EnumType
end

module ActiveRecord::Enum
  def self.extended(base); end
end

class ActiveRecord::EnvironmentMismatchError
  def initialize(current: T.unsafe(nil), stored: T.unsafe(nil)); end
end

module ActiveRecord::Explain
  def collecting_queries_for_explain(); end

  def exec_explain(queries); end
end

module ActiveRecord::Explain
end

class ActiveRecord::ExplainRegistry
  def collect(); end

  def collect=(collect); end

  def collect?(); end

  def queries(); end

  def queries=(queries); end

  def reset(); end
end

class ActiveRecord::ExplainRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.collect?(*args, &block); end
end

class ActiveRecord::ExplainSubscriber
  def finish(name, id, payload); end

  def ignore_payload?(payload); end

  def start(name, id, payload); end
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ExplainSubscriber
end

module ActiveRecord::FinderMethods
  def exists?(conditions=T.unsafe(nil)); end

  def fifth(); end

  def fifth!(); end

  def find(*args); end

  def find_by(arg, *args); end

  def find_by!(arg, *args); end

  def first(limit=T.unsafe(nil)); end

  def first!(); end

  def forty_two(); end

  def forty_two!(); end

  def fourth(); end

  def fourth!(); end

  def last(limit=T.unsafe(nil)); end

  def last!(); end

  def raise_record_not_found_exception!(ids=T.unsafe(nil), result_size=T.unsafe(nil), expected_size=T.unsafe(nil), key=T.unsafe(nil), not_found_ids=T.unsafe(nil)); end

  def second(); end

  def second!(); end

  def second_to_last(); end

  def second_to_last!(); end

  def take(limit=T.unsafe(nil)); end

  def take!(); end

  def third(); end

  def third!(); end

  def third_to_last(); end

  def third_to_last!(); end
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
end

class ActiveRecord::Fixture
  include ::Enumerable
  def [](key); end

  def class_name(); end

  def each(&blk); end

  def find(); end

  def fixture(); end

  def initialize(fixture, model_class); end

  def model_class(); end

  def to_hash(); end
end

class ActiveRecord::Fixture::FixtureError
end

class ActiveRecord::Fixture::FixtureError
end

class ActiveRecord::Fixture::FormatError
end

class ActiveRecord::Fixture::FormatError
end

class ActiveRecord::Fixture
end

class ActiveRecord::FixtureSet
  def [](x); end

  def []=(k, v); end

  def all_loaded_fixtures(); end

  def all_loaded_fixtures=(obj); end

  def config(); end

  def each(&block); end

  def fixtures(); end

  def initialize(_, name, class_name, path, config=T.unsafe(nil)); end

  def model_class(); end

  def name(); end

  def size(); end

  def table_name(); end

  def table_rows(); end
  MAX_ID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::FixtureSet::ClassCache
  def [](fs_name); end

  def initialize(class_names, config); end
end

class ActiveRecord::FixtureSet::ClassCache
end

class ActiveRecord::FixtureSet::File
  include ::Enumerable
  def each(&block); end

  def initialize(file); end

  def model_class(); end
end

class ActiveRecord::FixtureSet::File
  def self.open(file); end
end

class ActiveRecord::FixtureSet::ModelMetadata
  def has_primary_key_column?(); end

  def inheritance_column_name(); end

  def initialize(model_class); end

  def primary_key_name(); end

  def primary_key_type(); end

  def timestamp_column_names(); end
end

class ActiveRecord::FixtureSet::ModelMetadata
end

class ActiveRecord::FixtureSet::RenderContext
end

class ActiveRecord::FixtureSet::RenderContext
  def self.create_subclass(); end
end

class ActiveRecord::FixtureSet::TableRow
  def initialize(fixture, table_rows:, label:, now:); end

  def to_hash(); end
end

class ActiveRecord::FixtureSet::TableRow::HasManyThroughProxy
  def lhs_key(); end

  def rhs_key(); end
end

class ActiveRecord::FixtureSet::TableRow::HasManyThroughProxy
end

class ActiveRecord::FixtureSet::TableRow::ReflectionProxy
  def initialize(association); end

  def join_table(); end

  def name(); end

  def primary_key_type(); end
end

class ActiveRecord::FixtureSet::TableRow::ReflectionProxy
end

class ActiveRecord::FixtureSet::TableRow
end

class ActiveRecord::FixtureSet::TableRows
  def initialize(table_name, model_class:, fixtures:, config:); end

  def model_class(); end

  def model_metadata(); end

  def tables(); end

  def to_hash(); end
end

class ActiveRecord::FixtureSet::TableRows
end

class ActiveRecord::FixtureSet
  def self.all_loaded_fixtures(); end

  def self.all_loaded_fixtures=(obj); end

  def self.cache_fixtures(connection, fixtures_map); end

  def self.cache_for_connection(connection); end

  def self.cached_fixtures(connection, keys_to_fetch=T.unsafe(nil)); end

  def self.context_class(); end

  def self.create_fixtures(fixtures_directory, fixture_set_names, class_names=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.default_fixture_model_name(fixture_set_name, config=T.unsafe(nil)); end

  def self.default_fixture_table_name(fixture_set_name, config=T.unsafe(nil)); end

  def self.fixture_is_cached?(connection, table_name); end

  def self.identify(label, column_type=T.unsafe(nil)); end

  def self.instantiate_all_loaded_fixtures(object, load_instances=T.unsafe(nil)); end

  def self.instantiate_fixtures(object, fixture_set, load_instances=T.unsafe(nil)); end

  def self.reset_cache(); end
end

module ActiveRecord::Generators
end

class ActiveRecord::Generators::Base
  include ::Rails::Generators::Migration
  include ::ActiveRecord::Generators::Migration
end

class ActiveRecord::Generators::Base
  extend ::ActiveRecord::Generators::Migration::ClassMethods
end

module ActiveRecord::Generators::Migration
end

module ActiveRecord::Generators::Migration::ClassMethods
  def next_migration_number(dirname); end
end

module ActiveRecord::Generators::Migration::ClassMethods
end

module ActiveRecord::Generators::Migration
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Generators
end

class ActiveRecord::HasManyThroughAssociationNotFoundError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughOrderError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughSourceAssociationNotFoundError
  def initialize(reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughCollection
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::IllegalMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

module ActiveRecord::Inheritance::ClassMethods
  def abstract_class?(); end

  def base_class(); end

  def base_class?(); end

  def compute_type(type_name); end

  def descends_from_active_record?(); end

  def finder_needs_type_condition?(); end

  def inherited(subclass); end

  def new(attributes=T.unsafe(nil), &block); end

  def polymorphic_name(); end

  def sti_name(); end
end

module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InsertAll
  def connection(); end

  def execute(); end

  def initialize(model, inserts, on_duplicate:, returning: T.unsafe(nil), unique_by: T.unsafe(nil)); end

  def inserts(); end

  def keys(); end

  def map_key_with_value(); end

  def model(); end

  def on_duplicate(); end

  def primary_keys(); end

  def returning(); end

  def skip_duplicates?(); end

  def unique_by(); end

  def updatable_columns(); end

  def update_duplicates?(); end
end

class ActiveRecord::InsertAll::Builder
  def conflict_target(); end

  def initialize(insert_all); end

  def into(); end

  def keys(*args, &block); end

  def model(); end

  def returning(); end

  def skip_duplicates?(*args, &block); end

  def updatable_columns(); end

  def update_duplicates?(*args, &block); end

  def values_list(); end
end

class ActiveRecord::InsertAll::Builder
end

class ActiveRecord::InsertAll
end

module ActiveRecord::Integration
  def cache_key(); end

  def cache_key_with_version(); end

  def cache_version(); end

  def to_param(); end
end

module ActiveRecord::Integration::ClassMethods
  def collection_cache_key(collection=T.unsafe(nil), timestamp_column=T.unsafe(nil)); end

  def to_param(method_name=T.unsafe(nil)); end
end

module ActiveRecord::Integration::ClassMethods
end

module ActiveRecord::Integration
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InternalMetadata
  include ::ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  include ::ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::InternalMetadata
  def self.[](key); end

  def self.[]=(key, value); end

  def self.create_table(); end

  def self.drop_table(); end
end

class ActiveRecord::InverseOfAssociationNotFoundError
  def initialize(reflection=T.unsafe(nil), associated_class=T.unsafe(nil)); end
end

module ActiveRecord::LegacyYamlAdapter
end

module ActiveRecord::LegacyYamlAdapter::Rails41
end

module ActiveRecord::LegacyYamlAdapter::Rails41
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter::Rails420
end

module ActiveRecord::LegacyYamlAdapter::Rails420
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter
  def self.convert(klass, coder); end
end

class ActiveRecord::Locking::LockingType
  def deserialize(value); end

  def encode_with(coder); end

  def init_with(coder); end

  def serialize(value); end
end

class ActiveRecord::Locking::LockingType
end

module ActiveRecord::Locking::Optimistic
  def locking_enabled?(); end
end

module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Locking::Pessimistic
  def lock!(lock=T.unsafe(nil)); end
end

module ActiveRecord::Locking
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::LogSubscriber
  def backtrace_cleaner(); end

  def backtrace_cleaner=(val); end

  def backtrace_cleaner?(); end

  def sql(event); end
  IGNORE_PAYLOAD_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::LogSubscriber
  def self.backtrace_cleaner(); end

  def self.backtrace_cleaner=(val); end

  def self.backtrace_cleaner?(); end

  def self.reset_runtime(); end

  def self.runtime(); end

  def self.runtime=(value); end
end

module ActiveRecord::Middleware
end

class ActiveRecord::Middleware::DatabaseSelector
  def call(env); end

  def context_klass(); end

  def initialize(app, resolver_klass=T.unsafe(nil), context_klass=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def resolver_klass(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def context(); end

  def delay(); end

  def initialize(context, options=T.unsafe(nil)); end

  def instrumenter(); end

  def read(&blk); end

  def write(&blk); end
  SEND_TO_REPLICA_DELAY = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def initialize(session); end

  def last_write_timestamp(); end

  def session(); end

  def update_last_write_timestamp(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def self.call(request); end

  def self.convert_time_to_timestamp(time); end

  def self.convert_timestamp_to_time(timestamp); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def self.call(context, options=T.unsafe(nil)); end
end

class ActiveRecord::Middleware::DatabaseSelector
end

module ActiveRecord::Middleware
  extend ::ActiveSupport::Autoload
end

class ActiveRecord::Migration
  def announce(message); end

  def connection(); end

  def copy(destination, sources, options=T.unsafe(nil)); end

  def disable_ddl_transaction(); end

  def down(); end

  def exec_migration(conn, direction); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def method_missing(method, *arguments, &block); end

  def migrate(direction); end

  def name(); end

  def name=(name); end

  def next_migration_number(number); end

  def proper_table_name(name, options=T.unsafe(nil)); end

  def reversible(); end

  def revert(*migration_classes); end

  def reverting?(); end

  def run(*migration_classes); end

  def say(message, subitem=T.unsafe(nil)); end

  def say_with_time(message); end

  def suppress_messages(); end

  def table_name_options(config=T.unsafe(nil)); end

  def up(); end

  def up_only(); end

  def verbose(); end

  def verbose=(obj); end

  def version(); end

  def version=(version); end

  def write(text=T.unsafe(nil)); end
  MigrationFilenameRegexp = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migration::CheckPending
  def call(env); end

  def initialize(app); end
end

class ActiveRecord::Migration::CheckPending
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, &block); end

  def add_column(*args, &block); end

  def add_foreign_key(*args, &block); end

  def add_index(*args, &block); end

  def add_reference(*args, &block); end

  def add_timestamps(*args, &block); end

  def change_column(*args, &block); end

  def change_column_comment(*args, &block); end

  def change_column_default(*args, &block); end

  def change_column_null(*args, &block); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def change_table_comment(*args, &block); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, &block); end

  def create_table(*args, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, &block); end

  def drop_join_table(*args, &block); end

  def drop_table(*args, &block); end

  def enable_extension(*args, &block); end

  def execute(*args, &block); end

  def execute_block(*args, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end

  def remove_column(*args, &block); end

  def remove_columns(*args, &block); end

  def remove_foreign_key(*args, &block); end

  def remove_index(*args, &block); end

  def remove_reference(*args, &block); end

  def remove_timestamps(*args, &block); end

  def rename_column(*args, &block); end

  def rename_index(*args, &block); end

  def rename_table(*args, &block); end

  def replay(migration); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migration::Compatibility::V4_2
  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*_, **options); end

  def references(*_, **options); end

  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V4_2
end

class ActiveRecord::Migration::Compatibility::V5_0
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def add_reference(table_name, ref_name, **options); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V5_0
end

class ActiveRecord::Migration::Compatibility::V5_1
  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def create_table(table_name, options=T.unsafe(nil)); end
end

class ActiveRecord::Migration::Compatibility::V5_2
  def add_timestamps(table_name, **options); end

  def change_table(table_name, **options); end

  def create_join_table(table_1, table_2, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
  def invert_change_column_comment(args); end

  def invert_change_table_comment(args); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
end

module ActiveRecord::Migration::Compatibility
  def self.find(version); end
end

module ActiveRecord::Migration::JoinTable
end

module ActiveRecord::Migration::JoinTable
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def down(); end

  def reverting(); end

  def reverting=(_); end

  def up(); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Migration
  def self.[](version); end

  def self.check_pending!(connection=T.unsafe(nil)); end

  def self.current_version(); end

  def self.delegate(); end

  def self.delegate=(delegate); end

  def self.disable_ddl_transaction(); end

  def self.disable_ddl_transaction!(); end

  def self.disable_ddl_transaction=(disable_ddl_transaction); end

  def self.inherited(subclass); end

  def self.load_schema_if_pending!(); end

  def self.maintain_test_schema!(); end

  def self.method_missing(name, *args, &block); end

  def self.migrate(direction); end

  def self.nearest_delegate(); end

  def self.verbose(); end

  def self.verbose=(obj); end
end

class ActiveRecord::MigrationContext
  def any_migrations?(); end

  def current_environment(); end

  def current_version(); end

  def down(target_version=T.unsafe(nil)); end

  def forward(steps=T.unsafe(nil)); end

  def get_all_versions(); end

  def initialize(migrations_paths, schema_migration); end

  def last_migration(); end

  def last_stored_environment(); end

  def migrate(target_version=T.unsafe(nil), &block); end

  def migrations(); end

  def migrations_paths(); end

  def migrations_status(); end

  def needs_migration?(); end

  def open(); end

  def protected_environment?(); end

  def rollback(steps=T.unsafe(nil)); end

  def run(direction, target_version); end

  def schema_migration(); end

  def up(target_version=T.unsafe(nil)); end
end

class ActiveRecord::MigrationContext
end

class ActiveRecord::MigrationError
  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::MigrationProxy
  def announce(*args, &block); end

  def basename(); end

  def disable_ddl_transaction(*args, &block); end

  def filename(); end

  def filename=(_); end

  def initialize(name, version, filename, scope); end

  def migrate(*args, &block); end

  def mtime(); end

  def name(); end

  def name=(_); end

  def scope(); end

  def scope=(_); end

  def version(); end

  def version=(_); end

  def write(*args, &block); end
end

class ActiveRecord::MigrationProxy
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Migrator
  def current(); end

  def current_migration(); end

  def current_version(); end

  def initialize(direction, migrations, schema_migration, target_version=T.unsafe(nil)); end

  def load_migrated(); end

  def migrate(); end

  def migrated(); end

  def migrations(); end

  def pending_migrations(); end

  def run(); end

  def runnable(); end
  MIGRATOR_SALT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migrator
  def self.current_version(); end

  def self.migrations_paths(); end

  def self.migrations_paths=(migrations_paths); end
end

class ActiveRecord::MismatchedForeignKey
  def initialize(message: T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil), table: T.unsafe(nil), foreign_key: T.unsafe(nil), target_table: T.unsafe(nil), primary_key: T.unsafe(nil), primary_key_column: T.unsafe(nil)); end
end

module ActiveRecord::ModelSchema
end

module ActiveRecord::ModelSchema::ClassMethods
  def _default_attributes(); end

  def attribute_types(); end

  def attributes_builder(); end

  def column_defaults(); end

  def column_names(); end

  def columns(); end

  def columns_hash(); end

  def content_columns(); end

  def full_table_name_prefix(); end

  def full_table_name_suffix(); end

  def ignored_columns(); end

  def ignored_columns=(columns); end

  def inheritance_column(); end

  def inheritance_column=(value); end

  def initialize_load_schema_monitor(); end

  def next_sequence_value(); end

  def prefetch_primary_key?(); end

  def protected_environments(); end

  def protected_environments=(environments); end

  def quoted_table_name(); end

  def reset_column_information(); end

  def reset_sequence_name(); end

  def reset_table_name(); end

  def sequence_name(); end

  def sequence_name=(value); end

  def symbol_column_to_string(name_symbol); end

  def table_exists?(); end

  def table_name(); end

  def table_name=(value); end

  def type_for_attribute(attr_name, &block); end

  def yaml_encoder(); end
end

module ActiveRecord::ModelSchema::ClassMethods
end

module ActiveRecord::ModelSchema
  extend ::ActiveSupport::Concern
  def self.derive_join_table_name(first_table, second_table); end
end

class ActiveRecord::MultiparameterAssignmentErrors
  def errors(); end

  def initialize(errors=T.unsafe(nil)); end
end

module ActiveRecord::NestedAttributes
  def _destroy(); end
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes::ClassMethods
  REJECT_ALL_BLANK_PROC = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::NestedAttributes::TooManyRecords
end

class ActiveRecord::NestedAttributes::TooManyRecords
end

module ActiveRecord::NestedAttributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::NoEnvironmentInSchemaError
  def initialize(); end
end

module ActiveRecord::NoTouching
  def no_touching?(); end

  def touch(*_); end

  def touch_later(*_); end
end

module ActiveRecord::NoTouching::ClassMethods
  def no_touching(&block); end
end

module ActiveRecord::NoTouching::ClassMethods
end

module ActiveRecord::NoTouching
  extend ::ActiveSupport::Concern
  def self.applied_to?(klass); end

  def self.apply_to(klass); end
end

class ActiveRecord::NullMigration
  def initialize(); end
end

class ActiveRecord::NullMigration
end

module ActiveRecord::NullRelation
  def any?(); end

  def calculate(operation, _column_name); end

  def delete(_id_or_array); end

  def delete_all(); end

  def empty?(); end

  def exists?(_conditions=T.unsafe(nil)); end

  def many?(); end

  def none?(); end

  def one?(); end

  def or(other); end

  def pluck(*column_names); end

  def to_sql(); end

  def update_all(_updates); end
end

module ActiveRecord::NullRelation
end

class ActiveRecord::PendingMigrationError
  include ::ActiveSupport::ActionableError
  def _actions(); end

  def _actions=(val); end

  def _actions?(); end
end

class ActiveRecord::PendingMigrationError
  def self._actions(); end

  def self._actions=(val); end

  def self._actions?(); end
end

module ActiveRecord::Persistence
  def delete(); end

  def destroy(); end

  def destroy!(); end
end

module ActiveRecord::Persistence::ClassMethods
  def _delete_record(constraints); end

  def _insert_record(values); end

  def _update_record(values, constraints); end
end

module ActiveRecord::Persistence
  extend ::ActiveSupport::Concern
end

class ActiveRecord::PredicateBuilder
  def build(attribute, value); end

  def build_bind_attribute(column_name, value); end

  def build_from_hash(attributes); end

  def expand_from_hash(attributes); end

  def initialize(table); end

  def register_handler(klass, handler); end

  def resolve_column_aliases(*args, &block); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  def self.or(other); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
  def initialize(associated_table, value); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
end

class ActiveRecord::PredicateBuilder::BaseHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::BaseHandler
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  def initialize(associated_table, values); end

  def queries(); end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
end

class ActiveRecord::PredicateBuilder::RangeHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def begin(); end

  def begin=(_); end

  def end(); end

  def end=(_); end

  def exclude_end?(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

class ActiveRecord::PredicateBuilder::RelationHandler
end

class ActiveRecord::PredicateBuilder
  def self.references(attributes); end
end

class ActiveRecord::ProtectedEnvironmentError
  def initialize(env=T.unsafe(nil)); end
end

class ActiveRecord::QueryCache
end

module ActiveRecord::QueryCache::ClassMethods
  def cache(&block); end

  def uncached(&block); end
end

module ActiveRecord::QueryCache::ClassMethods
end

class ActiveRecord::QueryCache
  def self.complete(pools); end

  def self.install_executor_hooks(executor=T.unsafe(nil)); end

  def self.run(); end
end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  def _select!(*fields); end

  def annotate(*args); end

  def annotate!(*args); end

  def annotate_values(); end

  def annotate_values=(value); end

  def arel(aliases=T.unsafe(nil)); end

  def build_subquery(subquery_alias, select_value); end

  def construct_join_dependency(associations, join_type); end

  def create_with(value); end

  def create_with!(value); end

  def create_with_value(); end

  def create_with_value=(value); end

  def distinct(value=T.unsafe(nil)); end

  def distinct!(value=T.unsafe(nil)); end

  def distinct_value(); end

  def distinct_value=(value); end

  def eager_load(*args); end

  def eager_load!(*args); end

  def eager_load_values(); end

  def eager_load_values=(value); end

  def extending(*modules, &block); end

  def extending!(*modules, &block); end

  def extending_values(); end

  def extending_values=(value); end

  def extensions(); end

  def extract_associated(association); end

  def from(value, subquery_name=T.unsafe(nil)); end

  def from!(value, subquery_name=T.unsafe(nil)); end

  def from_clause(); end

  def from_clause=(value); end

  def group(*args); end

  def group!(*args); end

  def group_values(); end

  def group_values=(value); end

  def having(opts, *rest); end

  def having!(opts, *rest); end

  def having_clause(); end

  def having_clause=(value); end

  def includes(*args); end

  def includes!(*args); end

  def includes_values(); end

  def includes_values=(value); end

  def joins(*args); end

  def joins!(*args); end

  def joins_values(); end

  def joins_values=(value); end

  def left_joins(*args); end

  def left_outer_joins(*args); end

  def left_outer_joins!(*args); end

  def left_outer_joins_values(); end

  def left_outer_joins_values=(value); end

  def limit(value); end

  def limit!(value); end

  def limit_value(); end

  def limit_value=(value); end

  def lock(locks=T.unsafe(nil)); end

  def lock!(locks=T.unsafe(nil)); end

  def lock_value(); end

  def lock_value=(value); end

  def none(); end

  def none!(); end

  def offset(value); end

  def offset!(value); end

  def offset_value(); end

  def offset_value=(value); end

  def optimizer_hints(*args); end

  def optimizer_hints!(*args); end

  def optimizer_hints_values(); end

  def optimizer_hints_values=(value); end

  def or(other); end

  def or!(other); end

  def order(*args); end

  def order!(*args); end

  def order_values(); end

  def order_values=(value); end

  def preload(*args); end

  def preload!(*args); end

  def preload_values(); end

  def preload_values=(value); end

  def readonly(value=T.unsafe(nil)); end

  def readonly!(value=T.unsafe(nil)); end

  def readonly_value(); end

  def readonly_value=(value); end

  def references(*table_names); end

  def references!(*table_names); end

  def references_values(); end

  def references_values=(value); end

  def reorder(*args); end

  def reorder!(*args); end

  def reordering_value(); end

  def reordering_value=(value); end

  def reselect(*args); end

  def reselect!(*args); end

  def reverse_order(); end

  def reverse_order!(); end

  def reverse_order_value(); end

  def reverse_order_value=(value); end

  def rewhere(conditions); end

  def select(*fields); end

  def select_values(); end

  def select_values=(value); end

  def skip_preloading!(); end

  def skip_query_cache!(value=T.unsafe(nil)); end

  def skip_query_cache_value(); end

  def skip_query_cache_value=(value); end

  def unscope(*args); end

  def unscope!(*args); end

  def unscope_values(); end

  def unscope_values=(value); end

  def where(opts=T.unsafe(nil), *rest); end

  def where!(opts, *rest); end

  def where_clause(); end

  def where_clause=(value); end
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_OR_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::QueryMethods::WhereChain
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(scope); end

  def not(opts, *rest); end
end

class ActiveRecord::QueryMethods::WhereChain
end

module ActiveRecord::QueryMethods
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Querying
  def annotate(*args, &block); end

  def any?(*args, &block); end

  def average(*args, &block); end

  def calculate(*args, &block); end

  def count(*args, &block); end

  def count_by_sql(sql); end

  def create_or_find_by(*args, &block); end

  def create_or_find_by!(*args, &block); end

  def create_with(*args, &block); end

  def delete_all(*args, &block); end

  def delete_by(*args, &block); end

  def destroy_all(*args, &block); end

  def destroy_by(*args, &block); end

  def distinct(*args, &block); end

  def eager_load(*args, &block); end

  def except(*args, &block); end

  def exists?(*args, &block); end

  def extending(*args, &block); end

  def extract_associated(*args, &block); end

  def fifth(*args, &block); end

  def fifth!(*args, &block); end

  def find(*args, &block); end

  def find_by(*args, &block); end

  def find_by!(*args, &block); end

  def find_by_sql(sql, binds=T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  def find_each(*args, &block); end

  def find_in_batches(*args, &block); end

  def find_or_create_by(*args, &block); end

  def find_or_create_by!(*args, &block); end

  def find_or_initialize_by(*args, &block); end

  def first(*args, &block); end

  def first!(*args, &block); end

  def first_or_create(*args, &block); end

  def first_or_create!(*args, &block); end

  def first_or_initialize(*args, &block); end

  def forty_two(*args, &block); end

  def forty_two!(*args, &block); end

  def fourth(*args, &block); end

  def fourth!(*args, &block); end

  def from(*args, &block); end

  def group(*args, &block); end

  def having(*args, &block); end

  def ids(*args, &block); end

  def in_batches(*args, &block); end

  def includes(*args, &block); end

  def joins(*args, &block); end

  def last(*args, &block); end

  def last!(*args, &block); end

  def left_joins(*args, &block); end

  def left_outer_joins(*args, &block); end

  def limit(*args, &block); end

  def lock(*args, &block); end

  def many?(*args, &block); end

  def maximum(*args, &block); end

  def merge(*args, &block); end

  def minimum(*args, &block); end

  def none(*args, &block); end

  def none?(*args, &block); end

  def offset(*args, &block); end

  def one?(*args, &block); end

  def only(*args, &block); end

  def optimizer_hints(*args, &block); end

  def or(*args, &block); end

  def order(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def preload(*args, &block); end

  def readonly(*args, &block); end

  def references(*args, &block); end

  def reorder(*args, &block); end

  def reselect(*args, &block); end

  def rewhere(*args, &block); end

  def second(*args, &block); end

  def second!(*args, &block); end

  def second_to_last(*args, &block); end

  def second_to_last!(*args, &block); end

  def select(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take!(*args, &block); end

  def third(*args, &block); end

  def third!(*args, &block); end

  def third_to_last(*args, &block); end

  def third_to_last!(*args, &block); end

  def touch_all(*args, &block); end

  def unscope(*args, &block); end

  def update_all(*args, &block); end

  def where(*args, &block); end
  QUERYING_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Querying
end

class ActiveRecord::Railtie
end

class ActiveRecord::Railtie
end

module ActiveRecord::Railties
end

module ActiveRecord::Railties::CollectionCacheAssociationLoading
  def collection_with_template(*_); end

  def collection_without_template(*_); end

  def relation_from_options(cached: T.unsafe(nil), partial: T.unsafe(nil), collection: T.unsafe(nil), **_); end

  def setup(context, options, as, block); end
end

module ActiveRecord::Railties::CollectionCacheAssociationLoading
end

module ActiveRecord::Railties::ControllerRuntime
  def db_runtime(); end

  def db_runtime=(db_runtime); end
end

module ActiveRecord::Railties::ControllerRuntime
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Railties
end

class ActiveRecord::ReadOnlyError
end

class ActiveRecord::ReadOnlyError
end

module ActiveRecord::ReadonlyAttributes
end

module ActiveRecord::ReadonlyAttributes::ClassMethods
  def attr_readonly(*attributes); end

  def readonly_attributes(); end
end

module ActiveRecord::ReadonlyAttributes::ClassMethods
end

module ActiveRecord::ReadonlyAttributes
  extend ::ActiveSupport::Concern
end

class ActiveRecord::RecordInvalid
  def initialize(record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotDestroyed
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotFound
  def id(); end

  def initialize(message=T.unsafe(nil), model=T.unsafe(nil), primary_key=T.unsafe(nil), id=T.unsafe(nil)); end

  def model(); end

  def primary_key(); end
end

class ActiveRecord::RecordNotSaved
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

module ActiveRecord::Reflection
end

class ActiveRecord::Reflection::AbstractReflection
  def actual_source_reflection(); end

  def alias_candidate(name); end

  def build_association(attributes, &block); end

  def build_scope(table, predicate_builder=T.unsafe(nil)); end

  def chain(); end

  def check_validity_of_inverse!(); end

  def class_name(); end

  def constraints(); end

  def counter_cache_column(); end

  def counter_must_be_updated_by_has_many?(); end

  def get_join_keys(association_klass); end

  def has_cached_counter?(); end

  def inverse_of(); end

  def inverse_updates_counter_cache?(); end

  def inverse_updates_counter_in_memory?(); end

  def inverse_which_updates_counter_cache(); end

  def join_foreign_key(); end

  def join_keys(); end

  def join_primary_key(*_); end

  def join_scope(table, foreign_table, foreign_klass); end

  def join_scopes(table, predicate_builder); end

  def klass_join_scope(table, predicate_builder); end

  def scopes(); end

  def table_name(); end

  def through_reflection?(); end
end

class ActiveRecord::Reflection::AbstractReflection::JoinKeys
  def foreign_key(); end

  def foreign_key=(_); end

  def key(); end

  def key=(_); end
end

class ActiveRecord::Reflection::AbstractReflection::JoinKeys
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Reflection::AbstractReflection
end

class ActiveRecord::Reflection::AggregateReflection
  def mapping(); end
end

class ActiveRecord::Reflection::AggregateReflection
end

class ActiveRecord::Reflection::AssociationReflection
  def active_record_primary_key(); end

  def add_as_polymorphic_through(reflection, seed); end

  def add_as_source(seed); end

  def add_as_through(seed); end

  def association_class(); end

  def association_foreign_key(); end

  def association_primary_key(klass=T.unsafe(nil)); end

  def association_scope_cache(conn, owner, &block); end

  def belongs_to?(); end

  def check_eager_loadable!(); end

  def check_preloadable!(); end

  def check_validity!(); end

  def clear_association_scope_cache(); end

  def collect_join_chain(); end

  def collection?(); end

  def constructable?(); end

  def extensions(); end

  def foreign_key(); end

  def foreign_type(); end

  def has_inverse?(); end

  def has_one?(); end

  def has_scope?(); end

  def join_id_for(owner); end

  def join_table(); end

  def macro(); end

  def nested?(); end

  def parent_reflection(); end

  def parent_reflection=(parent_reflection); end

  def polymorphic?(); end

  def polymorphic_inverse_of(associated_class); end

  def source_reflection(); end

  def through_reflection(); end

  def type(); end

  def validate?(); end
  INVALID_AUTOMATIC_INVERSE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_AUTOMATIC_INVERSE_MACROS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Reflection::AssociationReflection
end

class ActiveRecord::Reflection::BelongsToReflection
  def join_primary_key(klass=T.unsafe(nil)); end
end

class ActiveRecord::Reflection::BelongsToReflection
end

module ActiveRecord::Reflection::ClassMethods
  def _reflect_on_association(association); end

  def clear_reflections_cache(); end

  def reflect_on_aggregation(aggregation); end

  def reflect_on_all_aggregations(); end

  def reflect_on_all_associations(macro=T.unsafe(nil)); end

  def reflect_on_all_autosave_associations(); end

  def reflect_on_association(association); end

  def reflections(); end
end

module ActiveRecord::Reflection::ClassMethods
end

class ActiveRecord::Reflection::HasAndBelongsToManyReflection
end

class ActiveRecord::Reflection::HasAndBelongsToManyReflection
end

class ActiveRecord::Reflection::HasManyReflection
end

class ActiveRecord::Reflection::HasManyReflection
end

class ActiveRecord::Reflection::HasOneReflection
end

class ActiveRecord::Reflection::HasOneReflection
end

class ActiveRecord::Reflection::MacroReflection
  def ==(other_aggregation); end

  def active_record(); end

  def autosave=(autosave); end

  def compute_class(name); end

  def initialize(name, scope, options, active_record); end

  def klass(); end

  def name(); end

  def options(); end

  def plural_name(); end

  def scope(); end

  def scope_for(relation, owner=T.unsafe(nil)); end
end

class ActiveRecord::Reflection::MacroReflection
end

class ActiveRecord::Reflection::PolymorphicReflection
  def get_join_keys(*args, &block); end

  def initialize(reflection, previous_reflection); end

  def klass(*args, &block); end

  def plural_name(*args, &block); end

  def scope(*args, &block); end

  def scope_for(*args, &block); end

  def type(*args, &block); end
end

class ActiveRecord::Reflection::PolymorphicReflection
end

class ActiveRecord::Reflection::RuntimeReflection
  def aliased_table(); end

  def all_includes(); end

  def constraints(*args, &block); end

  def get_join_keys(*args, &block); end

  def initialize(reflection, association); end

  def klass(); end

  def scope(*args, &block); end

  def type(*args, &block); end
end

class ActiveRecord::Reflection::RuntimeReflection
end

class ActiveRecord::Reflection::ThroughReflection
  def active_record(*args, &block); end

  def active_record_primary_key(*args, &block); end

  def add_as_polymorphic_through(reflection, seed); end

  def add_as_source(seed); end

  def add_as_through(seed); end

  def association_class(*args, &block); end

  def association_foreign_key(*args, &block); end

  def association_primary_key(klass=T.unsafe(nil)); end

  def association_scope_cache(*args, &block); end

  def autosave=(arg); end

  def belongs_to?(*args, &block); end

  def check_eager_loadable!(*args, &block); end

  def check_preloadable!(*args, &block); end

  def check_validity!(); end

  def clear_association_scope_cache(); end

  def collect_join_chain(); end

  def collection?(*args, &block); end

  def compute_class(*args, &block); end

  def constructable?(*args, &block); end

  def extensions(*args, &block); end

  def foreign_key(*args, &block); end

  def foreign_type(*args, &block); end

  def get_join_keys(*args, &block); end

  def has_inverse?(*args, &block); end

  def has_one?(*args, &block); end

  def has_scope?(); end

  def initialize(delegate_reflection); end

  def join_id_for(*args, &block); end

  def join_table(*args, &block); end

  def klass(); end

  def macro(*args, &block); end

  def name(*args, &block); end

  def nested?(); end

  def options(*args, &block); end

  def parent_reflection(*args, &block); end

  def parent_reflection=(arg); end

  def plural_name(*args, &block); end

  def polymorphic?(*args, &block); end

  def polymorphic_inverse_of(*args, &block); end

  def scope(*args, &block); end

  def scope_for(*args, &block); end

  def source_options(); end

  def source_reflection(); end

  def source_reflection_name(); end

  def source_reflection_names(); end

  def through_options(); end

  def through_reflection(); end

  def type(*args, &block); end

  def validate?(*args, &block); end
end

class ActiveRecord::Reflection::ThroughReflection
end

module ActiveRecord::Reflection
  extend ::ActiveSupport::Concern
  extend ::ActiveStorage::Reflection::ReflectionExtension
  def self.add_aggregate_reflection(ar, name, reflection); end

  def self.add_reflection(ar, name, reflection); end

  def self.create(macro, name, scope, options, ar); end
end

class ActiveRecord::Relation
  include ::Enumerable
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::FinderMethods
  def ==(other); end

  def _deprecated_scope_source(); end

  def _deprecated_scope_source=(_deprecated_scope_source); end

  def _exec_scope(name, *args, &block); end

  def alias_tracker(joins=T.unsafe(nil), aliases=T.unsafe(nil)); end

  def arel_attribute(name); end

  def bind_attribute(name, value); end

  def build(attributes=T.unsafe(nil), &block); end

  def cache_key(timestamp_column=T.unsafe(nil)); end

  def cache_version(timestamp_column=T.unsafe(nil)); end

  def create(attributes=T.unsafe(nil), &block); end

  def create!(attributes=T.unsafe(nil), &block); end

  def create_or_find_by(attributes, &block); end

  def create_or_find_by!(attributes, &block); end

  def delete_by(*args); end

  def destroy_all(); end

  def destroy_by(*args); end

  def eager_loading?(); end

  def empty_scope?(); end

  def encode_with(coder); end

  def explain(); end

  def find_or_create_by(attributes, &block); end

  def find_or_create_by!(attributes, &block); end

  def find_or_initialize_by(attributes, &block); end

  def first_or_create(attributes=T.unsafe(nil), &block); end

  def first_or_create!(attributes=T.unsafe(nil), &block); end

  def first_or_initialize(attributes=T.unsafe(nil), &block); end

  def has_limit_or_offset?(); end

  def initialize(klass, table: T.unsafe(nil), predicate_builder: T.unsafe(nil), values: T.unsafe(nil)); end

  def joined_includes_values(); end

  def klass(); end

  def load(&block); end

  def load_records(records); end

  def loaded(); end

  def loaded?(); end

  def locked?(); end

  def model(); end

  def new(attributes=T.unsafe(nil), &block); end

  def null_relation?(); end

  def predicate_builder(); end

  def preload_associations(records); end

  def records(); end

  def reload(); end

  def reset(); end

  def scope_for_create(); end

  def scoping(); end

  def skip_preloading_value(); end

  def skip_preloading_value=(skip_preloading_value); end

  def table(); end

  def to_a(); end

  def to_ary(); end

  def to_sql(); end

  def touch_all(*names, time: T.unsafe(nil)); end

  def update(id=T.unsafe(nil), attributes); end

  def update_all(updates); end

  def update_counters(counters); end

  def values(); end

  def where_values_hash(relation_table_name=T.unsafe(nil)); end
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::FromClause
  def empty?(); end

  def initialize(value, name); end

  def merge(other); end

  def name(); end

  def value(); end
end

class ActiveRecord::Relation::FromClause
  def self.empty(); end
end

class ActiveRecord::Relation::HashMerger
  def initialize(relation, hash); end

  def merge(); end

  def other(); end

  def relation(); end
end

class ActiveRecord::Relation::HashMerger
end

class ActiveRecord::Relation::Merger
  def initialize(relation, other); end

  def merge(); end

  def normal_values(); end

  def other(); end

  def relation(); end

  def values(); end
  NORMAL_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::Merger
end

class ActiveRecord::Relation::QueryAttribute
  def infinite?(); end

  def type_cast(value); end

  def unboundable?(); end
end

class ActiveRecord::Relation::QueryAttribute
end

class ActiveRecord::Relation::WhereClause
  def +(other); end

  def -(other); end

  def ==(other); end

  def any?(*args, &block); end

  def ast(); end

  def empty?(*args, &block); end

  def except(*columns); end

  def initialize(predicates); end

  def invert(as=T.unsafe(nil)); end

  def merge(other); end

  def or(other); end

  def predicates(); end

  def referenced_columns(); end

  def to_h(table_name=T.unsafe(nil)); end
  ARRAY_WITH_EMPTY_STRING = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::WhereClause
  def self.empty(); end
end

class ActiveRecord::Relation::WhereClauseFactory
  def build(opts, other); end

  def initialize(klass, predicate_builder); end
end

class ActiveRecord::Relation::WhereClauseFactory
end

class ActiveRecord::Relation
  extend ::ActiveRecord::Delegation::ClassMethods
end

class ActiveRecord::Result
  include ::Enumerable
  def [](idx); end

  def cast_values(type_overrides=T.unsafe(nil)); end

  def collect!(); end

  def column_types(); end

  def columns(); end

  def each(&blk); end

  def empty?(); end

  def first(); end

  def includes_column?(name); end

  def initialize(columns, rows, column_types=T.unsafe(nil)); end

  def last(); end

  def length(); end

  def map!(); end

  def rows(); end

  def to_a(); end

  def to_ary(); end

  def to_hash(); end
end

class ActiveRecord::RuntimeRegistry
  def connection_handler(); end

  def connection_handler=(connection_handler); end

  def sql_runtime(); end

  def sql_runtime=(sql_runtime); end
end

class ActiveRecord::RuntimeRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.connection_handler(); end

  def self.connection_handler=(x); end

  def self.sql_runtime(); end

  def self.sql_runtime=(x); end
end

module ActiveRecord::Sanitization
end

module ActiveRecord::Sanitization::ClassMethods
  def disallow_raw_sql!(args, permit: T.unsafe(nil)); end

  def sanitize_sql(condition); end

  def sanitize_sql_array(ary); end

  def sanitize_sql_for_assignment(assignments, default_table_name=T.unsafe(nil)); end

  def sanitize_sql_for_conditions(condition); end

  def sanitize_sql_for_order(condition); end

  def sanitize_sql_hash_for_assignment(attrs, table); end

  def sanitize_sql_like(string, escape_character=T.unsafe(nil)); end
end

module ActiveRecord::Sanitization::ClassMethods
end

module ActiveRecord::Sanitization
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Schema
  def define(info, &block); end
end

class ActiveRecord::SchemaDumper
  def dump(stream); end

  def fk_ignore_pattern(); end

  def fk_ignore_pattern=(obj); end

  def ignore_tables(); end

  def ignore_tables=(obj); end

  def initialize(connection, options=T.unsafe(nil)); end
end

class ActiveRecord::SchemaDumper
  def self.dump(connection=T.unsafe(nil), stream=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.fk_ignore_pattern(); end

  def self.fk_ignore_pattern=(obj); end

  def self.ignore_tables(); end

  def self.ignore_tables=(obj); end
end

class ActiveRecord::SchemaMigration
  include ::ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  include ::ActiveRecord::SchemaMigration::GeneratedAssociationMethods
  def version(); end
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::SchemaMigration
  def self.all_versions(); end

  def self.create_table(); end

  def self.drop_table(); end

  def self.normalize_migration_number(number); end

  def self.normalized_versions(); end
end

module ActiveRecord::Scoping
  def initialize_internals_callback(); end

  def populate_with_current_scope_attributes(); end
end

module ActiveRecord::Scoping::ClassMethods
  def current_scope(skip_inherited_scope=T.unsafe(nil)); end

  def current_scope=(scope); end

  def scope_attributes(); end

  def scope_attributes?(); end
end

module ActiveRecord::Scoping::ClassMethods
end

module ActiveRecord::Scoping::Default
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Scoping::Named
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Scoping::ScopeRegistry
  def set_value_for(scope_type, model, value); end

  def value_for(scope_type, model, skip_inherited_scope=T.unsafe(nil)); end
  VALID_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Scoping::ScopeRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::SecureToken
end

module ActiveRecord::SecureToken::ClassMethods
  def generate_unique_secure_token(); end

  def has_secure_token(attribute=T.unsafe(nil)); end
end

module ActiveRecord::SecureToken::ClassMethods
end

module ActiveRecord::SecureToken
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Serialization
  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveRecord::Serialization
  extend ::ActiveSupport::Concern
end

module ActiveRecord::SpawnMethods
  def except(*skips); end

  def merge(other); end

  def merge!(other); end

  def only(*onlies); end

  def spawn(); end
end

module ActiveRecord::SpawnMethods
end

class ActiveRecord::StaleObjectError
  def attempted_action(); end

  def initialize(record=T.unsafe(nil), attempted_action=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::StatementCache
  def execute(params, connection, &block); end

  def initialize(query_builder, bind_map, klass); end
end

class ActiveRecord::StatementCache::BindMap
  def bind(values); end

  def initialize(bound_attributes); end
end

class ActiveRecord::StatementCache::BindMap
end

class ActiveRecord::StatementCache::Params
  def bind(); end
end

class ActiveRecord::StatementCache::Params
end

class ActiveRecord::StatementCache::PartialQuery
  def initialize(values); end
end

class ActiveRecord::StatementCache::PartialQuery
end

class ActiveRecord::StatementCache::PartialQueryCollector
  def <<(str); end

  def add_bind(obj); end

  def value(); end
end

class ActiveRecord::StatementCache::PartialQueryCollector
end

class ActiveRecord::StatementCache::Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::Query
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache
  def self.create(connection, callable=T.unsafe(nil), &block); end

  def self.partial_query(values); end

  def self.partial_query_collector(); end

  def self.query(sql); end

  def self.unsupported_value?(value); end
end

class ActiveRecord::StatementInvalid
  def binds(); end

  def initialize(message=T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil)); end

  def sql(); end
end

module ActiveRecord::Store
end

module ActiveRecord::Store::ClassMethods
  def _store_accessors_module(); end

  def store(store_attribute, options=T.unsafe(nil)); end

  def store_accessor(store_attribute, *keys, prefix: T.unsafe(nil), suffix: T.unsafe(nil)); end

  def stored_attributes(); end
end

module ActiveRecord::Store::ClassMethods
end

class ActiveRecord::Store::HashAccessor
end

class ActiveRecord::Store::HashAccessor
  def self.prepare(object, attribute); end

  def self.read(object, attribute, key); end

  def self.write(object, attribute, key, value); end
end

class ActiveRecord::Store::IndifferentCoder
  def dump(obj); end

  def initialize(attr_name, coder_or_class_name); end

  def load(yaml); end
end

class ActiveRecord::Store::IndifferentCoder
  def self.as_indifferent_hash(obj); end
end

class ActiveRecord::Store::IndifferentHashAccessor
end

class ActiveRecord::Store::IndifferentHashAccessor
  def self.prepare(object, store_attribute); end
end

class ActiveRecord::Store::StringKeyedHashAccessor
end

class ActiveRecord::Store::StringKeyedHashAccessor
end

module ActiveRecord::Store
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Suppressor
  def save(*_); end

  def save!(*_); end
end

module ActiveRecord::Suppressor::ClassMethods
  def suppress(&block); end
end

module ActiveRecord::Suppressor::ClassMethods
end

module ActiveRecord::Suppressor
  extend ::ActiveSupport::Concern
end

class ActiveRecord::SuppressorRegistry
  def suppressed(); end
end

class ActiveRecord::SuppressorRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

class ActiveRecord::TableMetadata
  def aggregated_with?(aggregation_name); end

  def arel_attribute(column_name); end

  def associated_table(table_name); end

  def associated_with?(association_name); end

  def association_foreign_key(*args, &block); end

  def association_foreign_type(*args, &block); end

  def association_join_foreign_key(*args, &block); end

  def association_join_primary_key(*args, &block); end

  def has_column?(column_name); end

  def initialize(klass, arel_table, association=T.unsafe(nil), types=T.unsafe(nil)); end

  def polymorphic_association?(); end

  def reflect_on_aggregation(aggregation_name); end

  def resolve_column_aliases(hash); end

  def type(column_name); end
end

class ActiveRecord::TableMetadata
end

module ActiveRecord::Tasks
end

class ActiveRecord::Tasks::DatabaseAlreadyExists
end

class ActiveRecord::Tasks::DatabaseAlreadyExists
end

class ActiveRecord::Tasks::DatabaseNotSupported
end

class ActiveRecord::Tasks::DatabaseNotSupported
end

module ActiveRecord::Tasks::DatabaseTasks
  def cache_dump_filename(namespace); end

  def charset(*arguments); end

  def charset_current(environment=T.unsafe(nil), specification_name=T.unsafe(nil)); end

  def check_protected_environments!(); end

  def check_schema_file(filename); end

  def check_target_version(); end

  def collation(*arguments); end

  def collation_current(environment=T.unsafe(nil), specification_name=T.unsafe(nil)); end

  def create(*arguments); end

  def create_all(); end

  def create_current(environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def current_config(options=T.unsafe(nil)); end

  def current_config=(current_config); end

  def database_configuration(); end

  def database_configuration=(database_configuration); end

  def db_dir(); end

  def db_dir=(db_dir); end

  def drop(*arguments); end

  def drop_all(); end

  def drop_current(environment=T.unsafe(nil)); end

  def dump_filename(namespace, format=T.unsafe(nil)); end

  def dump_schema(configuration, format=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def dump_schema_cache(conn, filename); end

  def env(); end

  def env=(env); end

  def fixtures_path(); end

  def fixtures_path=(fixtures_path); end

  def for_each(databases); end

  def load_schema(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def load_schema_current(format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_seed(); end

  def migrate(); end

  def migrate_status(); end

  def migrations_paths(); end

  def migrations_paths=(migrations_paths); end

  def purge(configuration); end

  def purge_all(); end

  def purge_current(environment=T.unsafe(nil)); end

  def raise_for_multi_db(environment=T.unsafe(nil), command:); end

  def reconstruct_from_schema(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def register_task(pattern, task); end

  def root(); end

  def root=(root); end

  def schema_file(format=T.unsafe(nil)); end

  def schema_file_type(format=T.unsafe(nil)); end

  def schema_up_to_date?(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil), spec_name=T.unsafe(nil)); end

  def seed_loader(); end

  def seed_loader=(seed_loader); end

  def setup_initial_database_yaml(); end

  def spec(); end

  def structure_dump(*arguments); end

  def structure_load(*arguments); end

  def target_version(); end

  def truncate_all(environment=T.unsafe(nil)); end
  LOCAL_HOSTS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Tasks::DatabaseTasks
  extend ::ActiveRecord::Tasks::DatabaseTasks
  def self.structure_dump_flags(); end

  def self.structure_dump_flags=(obj); end

  def self.structure_load_flags(); end

  def self.structure_load_flags=(obj); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  ER_DB_CREATE_EXISTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*args, &block); end

  def collation(); end

  def connection(*args, &block); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
end

module ActiveRecord::Tasks
  extend ::ActiveSupport::Autoload
end

module ActiveRecord::TestDatabases
end

module ActiveRecord::TestDatabases
  def self.create_and_load_schema(i, env_name:); end
end

module ActiveRecord::TestFixtures
  def after_teardown(); end

  def before_setup(); end

  def enlist_fixture_connections(); end

  def run_in_transaction?(); end

  def setup_fixtures(config=T.unsafe(nil)); end

  def teardown_fixtures(); end
end

module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
end

class ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::ThroughNestedAssociationsAreReadonly
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

module ActiveRecord::Timestamp
end

module ActiveRecord::Timestamp::ClassMethods
  def all_timestamp_attributes_in_model(); end

  def current_time_from_proper_timezone(); end

  def timestamp_attributes_for_create_in_model(); end

  def timestamp_attributes_for_update_in_model(); end

  def touch_attributes_with_time(*names, time: T.unsafe(nil)); end
end

module ActiveRecord::Timestamp::ClassMethods
end

module ActiveRecord::Timestamp
  extend ::ActiveSupport::Concern
end

module ActiveRecord::TouchLater
  def touch(*names, time: T.unsafe(nil)); end

  def touch_later(*names); end
end

module ActiveRecord::TouchLater
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Transactions
  def before_committed!(); end

  def committed!(should_run_callbacks: T.unsafe(nil)); end

  def destroy(); end

  def rolledback!(force_restore_state: T.unsafe(nil), should_run_callbacks: T.unsafe(nil)); end

  def save(*_); end

  def save!(*_); end

  def touch(*_); end

  def transaction(options=T.unsafe(nil), &block); end

  def trigger_transactional_callbacks?(); end

  def with_transaction_returning_status(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Transactions::ClassMethods
  def after_commit(*args, &block); end

  def after_commit_without_transaction_enrollment(*args, &block); end

  def after_create_commit(*args, &block); end

  def after_destroy_commit(*args, &block); end

  def after_rollback(*args, &block); end

  def after_rollback_without_transaction_enrollment(*args, &block); end

  def after_save_commit(*args, &block); end

  def after_update_commit(*args, &block); end

  def before_commit(*args, &block); end

  def before_commit_without_transaction_enrollment(*args, &block); end
end

module ActiveRecord::Transactions
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Translation
  include ::ActiveModel::Translation
  include ::ActiveModel::Naming
  def i18n_scope(); end

  def lookup_ancestors(); end
end

module ActiveRecord::Translation
end

class ActiveRecord::Type::AdapterSpecificRegistry
  def add_modifier(options, klass, **args); end
end

class ActiveRecord::Type::AdapterSpecificRegistry
end

ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger

ActiveRecord::Type::Binary = ActiveModel::Type::Binary

class ActiveRecord::Type::Date
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Date
end

class ActiveRecord::Type::DateTime
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::DateTime
end

ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecorationRegistration
  def call(registry, *args, **kwargs); end

  def initialize(options, klass, adapter: T.unsafe(nil)); end

  def matches?(*args, **kwargs); end
end

class ActiveRecord::Type::DecorationRegistration
end

ActiveRecord::Type::Float = ActiveModel::Type::Float

class ActiveRecord::Type::HashLookupTypeMap
  def alias_type(type, alias_type); end

  def key?(key); end

  def keys(); end
end

class ActiveRecord::Type::HashLookupTypeMap
end

ActiveRecord::Type::Integer = ActiveModel::Type::Integer

module ActiveRecord::Type::Internal
end

module ActiveRecord::Type::Internal::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

module ActiveRecord::Type::Internal::Timezone
end

module ActiveRecord::Type::Internal
end

class ActiveRecord::Type::Json
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end
end

class ActiveRecord::Type::Json
end

class ActiveRecord::Type::Registration
  def adapter(); end

  def block(); end

  def call(_registry, *args, adapter: T.unsafe(nil), **kwargs); end

  def initialize(name, block, adapter: T.unsafe(nil), override: T.unsafe(nil)); end

  def matches?(type_name, *args, **kwargs); end

  def name(); end

  def override(); end

  def priority(); end

  def priority_except_adapter(); end
end

class ActiveRecord::Type::Registration
end

class ActiveRecord::Type::Serialized
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end

  def assert_valid_value(value); end

  def changed_in_place?(raw_old_value, value); end

  def coder(); end

  def deserialize(value); end

  def force_equality?(value); end

  def initialize(subtype, coder); end

  def inspect(); end

  def serialize(value); end

  def subtype(); end
end

class ActiveRecord::Type::Serialized
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Time
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time
end

class ActiveRecord::Type::TypeMap
  def alias_type(key, target_key); end

  def clear(); end

  def fetch(lookup_key, *args, &block); end

  def lookup(lookup_key, *args); end

  def register_type(key, value=T.unsafe(nil), &block); end
end

class ActiveRecord::Type::TypeMap
end

class ActiveRecord::Type::UnsignedInteger
end

class ActiveRecord::Type::UnsignedInteger
end

module ActiveRecord::Type
  def self.add_modifier(*args, &block); end

  def self.default_value(); end

  def self.lookup(*args, adapter: T.unsafe(nil), **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

module ActiveRecord::TypeCaster
end

class ActiveRecord::TypeCaster::Connection
  def initialize(klass, table_name); end

  def type_cast_for_database(attr_name, value); end

  def type_for_attribute(attr_name); end
end

class ActiveRecord::TypeCaster::Connection
end

class ActiveRecord::TypeCaster::Map
  def initialize(types); end

  def type_cast_for_database(attr_name, value); end
end

class ActiveRecord::TypeCaster::Map
end

module ActiveRecord::TypeCaster
end

class ActiveRecord::UnknownMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

class ActiveRecord::UnknownPrimaryKey
  def initialize(model=T.unsafe(nil), description=T.unsafe(nil)); end

  def model(); end
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
end

module ActiveRecord::Validations
  def save(options=T.unsafe(nil)); end

  def save!(options=T.unsafe(nil)); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end
end

class ActiveRecord::Validations::AbsenceValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::AbsenceValidator
end

class ActiveRecord::Validations::AssociatedValidator
end

class ActiveRecord::Validations::AssociatedValidator
end

module ActiveRecord::Validations::ClassMethods
  def validates_absence_of(*attr_names); end

  def validates_associated(*attr_names); end

  def validates_length_of(*attr_names); end

  def validates_presence_of(*attr_names); end

  def validates_size_of(*attr_names); end

  def validates_uniqueness_of(*attr_names); end
end

module ActiveRecord::Validations::ClassMethods
end

class ActiveRecord::Validations::LengthValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::LengthValidator
end

class ActiveRecord::Validations::PresenceValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::PresenceValidator
end

class ActiveRecord::Validations::UniquenessValidator
end

class ActiveRecord::Validations::UniquenessValidator
end

module ActiveRecord::Validations
  extend ::ActiveSupport::Concern
end

module ActiveRecord
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end

  def self.version(); end
end

module ActiveResource
end

module ActiveResource::Associations
  def belongs_to(name, options=T.unsafe(nil)); end

  def defines_belongs_to_finder_method(reflection); end

  def defines_has_many_finder_method(reflection); end

  def defines_has_one_finder_method(reflection); end

  def has_many(name, options=T.unsafe(nil)); end

  def has_one(name, options=T.unsafe(nil)); end
end

module ActiveResource::Associations::Builder
end

class ActiveResource::Associations::Builder::Association
  def build(); end

  def initialize(model, name, options); end

  def klass(); end

  def macro(); end

  def macro=(val); end

  def macro?(); end

  def model(); end

  def name(); end

  def options(); end

  def valid_options(); end

  def valid_options=(val); end

  def valid_options?(); end
end

class ActiveResource::Associations::Builder::Association
  def self.build(model, name, options); end

  def self.macro(); end

  def self.macro=(val); end

  def self.macro?(); end

  def self.valid_options(); end

  def self.valid_options=(val); end

  def self.valid_options?(); end
end

class ActiveResource::Associations::Builder::BelongsTo
end

class ActiveResource::Associations::Builder::BelongsTo
end

class ActiveResource::Associations::Builder::HasMany
end

class ActiveResource::Associations::Builder::HasMany
end

class ActiveResource::Associations::Builder::HasOne
end

class ActiveResource::Associations::Builder::HasOne
end

module ActiveResource::Associations::Builder
end

module ActiveResource::Associations
end

class ActiveResource::BadRequest
end

class ActiveResource::BadRequest
end

class ActiveResource::Base
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveResource::Validations
  include ::ActiveResource::CustomMethods
  include ::ActiveResource::Callbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveModel::Conversion
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serializers::Xml
  include ::ActiveModel::Serialization
  include ::ActiveResource::Reflection
  def ==(other); end

  def __callbacks(); end

  def __callbacks?(); end

  def _collection_parser(); end

  def _collection_parser=(val); end

  def _collection_parser?(); end

  def _create_callbacks(); end

  def _destroy_callbacks(); end

  def _format(); end

  def _format=(val); end

  def _format?(); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _update_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def attributes(); end

  def attributes=(attributes); end

  def clone(); end

  def collection_path(options=T.unsafe(nil)); end

  def connection(refresh=T.unsafe(nil)); end

  def connection_class(); end

  def connection_class=(val); end

  def connection_class?(); end

  def create(); end

  def destroy(); end

  def element_path(options=T.unsafe(nil)); end

  def element_url(options=T.unsafe(nil)); end

  def encode(options=T.unsafe(nil)); end

  def eql?(other); end

  def exists?(); end

  def id(); end

  def id=(id); end

  def id_from_response(response); end

  def include_format_in_path(); end

  def include_format_in_path=(val); end

  def include_format_in_path?(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def initialize(attributes=T.unsafe(nil), persisted=T.unsafe(nil)); end

  def known_attributes(); end

  def load(attributes, remove_root=T.unsafe(nil), persisted=T.unsafe(nil)); end

  def load_attributes_from_response(response); end

  def logger(); end

  def model_name(*args, &block); end

  def new?(); end

  def new_element_path(); end

  def new_record?(); end

  def persisted?(); end

  def prefix_options(); end

  def prefix_options=(prefix_options); end

  def read_attribute_for_serialization(n); end

  def reflections(); end

  def reflections=(val); end

  def reflections?(); end

  def reload(); end

  def respond_to_without_attributes?(*_); end

  def save(options=T.unsafe(nil)); end

  def save!(); end

  def save_without_validation(); end

  def schema(); end

  def to_xml(options=T.unsafe(nil)); end

  def update(); end

  def update_attribute(name, value); end

  def update_attributes(attributes); end

  def validation_context(); end
end

class ActiveResource::Base
  extend ::ThreadsafeAttributes
  extend ::ActiveResource::Associations
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveResource::CustomMethods::ClassMethods
  extend ::ActiveResource::Reflection::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._collection_parser(); end

  def self._collection_parser=(val); end

  def self._collection_parser?(); end

  def self._connection(); end

  def self._connection=(value); end

  def self._connection_defined?(); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._format(); end

  def self._format=(val); end

  def self._format?(); end

  def self._headers(); end

  def self._headers=(value); end

  def self._headers_defined?(); end

  def self._password(); end

  def self._password=(value); end

  def self._password_defined?(); end

  def self._proxy(); end

  def self._proxy=(value); end

  def self._proxy_defined?(); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._site(); end

  def self._site=(value); end

  def self._site_defined?(); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._user(); end

  def self._user=(value); end

  def self._user_defined?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.after_create(*args, **options, &block); end

  def self.after_destroy(*args, **options, &block); end

  def self.after_save(*args, **options, &block); end

  def self.after_update(*args, **options, &block); end

  def self.all(*args); end

  def self.around_create(*args, **options, &block); end

  def self.around_destroy(*args, **options, &block); end

  def self.around_save(*args, **options, &block); end

  def self.around_update(*args, **options, &block); end

  def self.auth_type(); end

  def self.auth_type=(auth_type); end

  def self.before_create(*args, **options, &block); end

  def self.before_destroy(*args, **options, &block); end

  def self.before_save(*args, **options, &block); end

  def self.before_update(*args, **options, &block); end

  def self.build(attributes=T.unsafe(nil)); end

  def self.collection_name(); end

  def self.collection_name=(collection_name); end

  def self.collection_parser(); end

  def self.collection_parser=(parser_instance); end

  def self.collection_path(prefix_options=T.unsafe(nil), query_options=T.unsafe(nil)); end

  def self.connection(refresh=T.unsafe(nil)); end

  def self.connection_class(); end

  def self.connection_class=(val); end

  def self.connection_class?(); end

  def self.create(attributes=T.unsafe(nil)); end

  def self.create!(attributes=T.unsafe(nil)); end

  def self.delete(custom_method_name, options=T.unsafe(nil)); end

  def self.element_name(); end

  def self.element_name=(element_name); end

  def self.element_path(id, prefix_options=T.unsafe(nil), query_options=T.unsafe(nil)); end

  def self.element_url(id, prefix_options=T.unsafe(nil), query_options=T.unsafe(nil)); end

  def self.exists?(id, options=T.unsafe(nil)); end

  def self.find(*arguments); end

  def self.first(*args); end

  def self.format(); end

  def self.format=(mime_type_reference_or_format); end

  def self.format_extension(); end

  def self.get(custom_method_name, options=T.unsafe(nil)); end

  def self.headers(); end

  def self.include_format_in_path(); end

  def self.include_format_in_path=(val); end

  def self.include_format_in_path?(); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(val); end

  def self.include_root_in_json?(); end

  def self.known_attributes(); end

  def self.last(*args); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.new_element_path(prefix_options=T.unsafe(nil)); end

  def self.open_timeout(); end

  def self.open_timeout=(timeout); end

  def self.orig_delete(id, options=T.unsafe(nil)); end

  def self.password(); end

  def self.password=(password); end

  def self.patch(custom_method_name, options=T.unsafe(nil), body=T.unsafe(nil)); end

  def self.post(custom_method_name, options=T.unsafe(nil), body=T.unsafe(nil)); end

  def self.prefix(options=T.unsafe(nil)); end

  def self.prefix=(value=T.unsafe(nil)); end

  def self.prefix_source(); end

  def self.primary_key(); end

  def self.primary_key=(primary_key); end

  def self.proxy(); end

  def self.proxy=(proxy); end

  def self.put(custom_method_name, options=T.unsafe(nil), body=T.unsafe(nil)); end

  def self.read_timeout(); end

  def self.read_timeout=(timeout); end

  def self.reflections(); end

  def self.reflections=(val); end

  def self.reflections?(); end

  def self.schema(&block); end

  def self.schema=(the_schema); end

  def self.set_collection_name(_); end

  def self.set_element_name(_); end

  def self.set_prefix(value=T.unsafe(nil)); end

  def self.set_primary_key(_); end

  def self.site(); end

  def self.site=(site); end

  def self.ssl_options(); end

  def self.ssl_options=(options); end

  def self.timeout(); end

  def self.timeout=(timeout); end

  def self.user(); end

  def self.user=(user); end

  def self.where(clauses=T.unsafe(nil)); end
end

module ActiveResource::Callbacks
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActiveResource::Callbacks
  extend ::ActiveSupport::Concern
end

class ActiveResource::ClientError
end

class ActiveResource::ClientError
end

class ActiveResource::Collection
  include ::Enumerable
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def ==(arg); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def as_json(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def blank?(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def dclone(*args, &block); end

  def deep_dup(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_index(*args, &block); end

  def elements(); end

  def elements=(elements); end

  def empty?(*args, &block); end

  def eql?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def first_or_create(attributes=T.unsafe(nil)); end

  def first_or_initialize(attributes=T.unsafe(nil)); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def hash(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def initialize(elements=T.unsafe(nil)); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(); end

  def max(*args, &block); end

  def min(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def original_params(); end

  def original_params=(original_params); end

  def pack(*args, &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def pretty_print(*args, &block); end

  def pretty_print_cycle(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resource_class(); end

  def resource_class=(resource_class); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by!(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_a(); end

  def to_ary(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_param(*args, &block); end

  def to_query(*args, &block); end

  def to_s(*args, &block); end

  def to_sentence(*args, &block); end

  def to_xml(*args, &block); end

  def to_yaml(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def where(clauses=T.unsafe(nil)); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  SELF_DEFINE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveResource::Collection
end

class ActiveResource::Connection
  def auth_type(); end

  def auth_type=(auth_type); end

  def bearer_token(); end

  def bearer_token=(bearer_token); end

  def delete(path, headers=T.unsafe(nil)); end

  def format(); end

  def format=(format); end

  def get(path, headers=T.unsafe(nil)); end

  def head(path, headers=T.unsafe(nil)); end

  def initialize(site, format=T.unsafe(nil), logger: T.unsafe(nil)); end

  def logger(); end

  def logger=(logger); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def password(); end

  def password=(password); end

  def patch(path, body=T.unsafe(nil), headers=T.unsafe(nil)); end

  def post(path, body=T.unsafe(nil), headers=T.unsafe(nil)); end

  def proxy(); end

  def proxy=(proxy); end

  def put(path, body=T.unsafe(nil), headers=T.unsafe(nil)); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def site(); end

  def site=(site); end

  def ssl_options(); end

  def ssl_options=(ssl_options); end

  def timeout(); end

  def timeout=(timeout); end

  def user(); end

  def user=(user); end
  HTTP_FORMAT_HEADER_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveResource::Connection
  def self.requests(); end
end

class ActiveResource::ConnectionError
  def initialize(response, message=T.unsafe(nil)); end

  def response(); end
end

class ActiveResource::ConnectionError
end

module ActiveResource::CustomMethods
  def delete(method_name, options=T.unsafe(nil)); end

  def get(method_name, options=T.unsafe(nil)); end

  def patch(method_name, options=T.unsafe(nil), body=T.unsafe(nil)); end

  def post(method_name, options=T.unsafe(nil), body=T.unsafe(nil)); end

  def put(method_name, options=T.unsafe(nil), body=T.unsafe(nil)); end
end

module ActiveResource::CustomMethods::ClassMethods
  def custom_method_collection_url(method_name, options=T.unsafe(nil)); end
end

module ActiveResource::CustomMethods::ClassMethods
end

module ActiveResource::CustomMethods
  extend ::ActiveSupport::Concern
end

class ActiveResource::DetailedLogSubscriber
  def request(event); end
  VERSION_DEPRECATION_HEADER = ::T.let(nil, ::T.untyped)
  VERSION_EOL_WARNING_HEADER = ::T.let(nil, ::T.untyped)
end

class ActiveResource::DetailedLogSubscriber
end

class ActiveResource::Errors
  def from_array(messages, save_cache=T.unsafe(nil)); end

  def from_hash(messages, save_cache=T.unsafe(nil)); end

  def from_json(json, save_cache=T.unsafe(nil)); end

  def from_string(error, save_cache=T.unsafe(nil)); end

  def from_xml(xml, save_cache=T.unsafe(nil)); end
end

class ActiveResource::Errors
end

class ActiveResource::ForbiddenAccess
end

class ActiveResource::ForbiddenAccess
end

module ActiveResource::Formats
end

module ActiveResource::Formats::JsonFormat
  def decode(json); end

  def encode(hash, options=T.unsafe(nil)); end

  def extension(); end

  def mime_type(); end
end

module ActiveResource::Formats::JsonFormat
  extend ::ActiveResource::Formats::JsonFormat
end

module ActiveResource::Formats::XmlFormat
  def decode(xml); end

  def encode(hash, options=T.unsafe(nil)); end

  def extension(); end

  def mime_type(); end
end

module ActiveResource::Formats::XmlFormat
  extend ::ActiveResource::Formats::XmlFormat
end

module ActiveResource::Formats
  def self.[](mime_type_reference); end

  def self.remove_root(data); end
end

class ActiveResource::HttpMock
  def delete(path, headers); end

  def get(path, headers); end

  def head(path, headers); end

  def initialize(site); end

  def inspect_responses(); end

  def patch(path, body, headers); end

  def post(path, body, headers); end

  def put(path, body, headers); end
end

class ActiveResource::HttpMock::Responder
  def delete(path, request_headers=T.unsafe(nil), body=T.unsafe(nil), status=T.unsafe(nil), response_headers=T.unsafe(nil)); end

  def get(path, request_headers=T.unsafe(nil), body=T.unsafe(nil), status=T.unsafe(nil), response_headers=T.unsafe(nil)); end

  def head(path, request_headers=T.unsafe(nil), body=T.unsafe(nil), status=T.unsafe(nil), response_headers=T.unsafe(nil)); end

  def initialize(responses); end

  def patch(path, request_headers=T.unsafe(nil), body=T.unsafe(nil), status=T.unsafe(nil), response_headers=T.unsafe(nil)); end

  def post(path, request_headers=T.unsafe(nil), body=T.unsafe(nil), status=T.unsafe(nil), response_headers=T.unsafe(nil)); end

  def put(path, request_headers=T.unsafe(nil), body=T.unsafe(nil), status=T.unsafe(nil), response_headers=T.unsafe(nil)); end
end

class ActiveResource::HttpMock::Responder
end

class ActiveResource::HttpMock
  def self.delete_responses_to_replace(new_responses); end

  def self.disable_net_connection!(); end

  def self.enable_net_connection!(); end

  def self.net_connection_disabled?(); end

  def self.net_connection_enabled?(); end

  def self.requests(); end

  def self.reset!(); end

  def self.respond_to(*args); end

  def self.responses(); end
end

class ActiveResource::LogSubscriber
  def request(event); end
end

class ActiveResource::LogSubscriber
end

class ActiveResource::MethodNotAllowed
  def allowed_methods(); end
end

class ActiveResource::MethodNotAllowed
end

class ActiveResource::MissingPrefixParam
end

class ActiveResource::MissingPrefixParam
end

class ActiveResource::Railtie
end

class ActiveResource::Railtie
end

class ActiveResource::Redirection
end

class ActiveResource::Redirection
end

module ActiveResource::Reflection
end

class ActiveResource::Reflection::AssociationReflection
  def class_name(); end

  def foreign_key(); end

  def initialize(macro, name, options); end

  def klass(); end

  def macro(); end

  def name(); end

  def options(); end
end

class ActiveResource::Reflection::AssociationReflection
end

module ActiveResource::Reflection::ClassMethods
  def create_reflection(macro, name, options); end
end

module ActiveResource::Reflection::ClassMethods
end

module ActiveResource::Reflection
  extend ::ActiveSupport::Concern
end

class ActiveResource::ResourceConflict
end

class ActiveResource::ResourceConflict
end

class ActiveResource::ResourceGone
end

class ActiveResource::ResourceGone
end

class ActiveResource::ResourceInvalid
end

class ActiveResource::ResourceInvalid
end

class ActiveResource::ResourceNotFound
end

class ActiveResource::ResourceNotFound
end

class ActiveResource::SSLError
  def initialize(message); end
end

class ActiveResource::SSLError
end

class ActiveResource::Schema
  def attribute(name, type, options=T.unsafe(nil)); end

  def attrs(); end

  def attrs=(attrs); end

  def binary(*args); end

  def boolean(*args); end

  def date(*args); end

  def datetime(*args); end

  def decimal(*args); end

  def float(*args); end

  def integer(*args); end

  def string(*args); end

  def text(*args); end

  def time(*args); end

  def timestamp(*args); end
  KNOWN_ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveResource::Schema
end

class ActiveResource::ServerError
end

class ActiveResource::ServerError
end

module ActiveResource::Singleton
  def create(); end

  def destroy(); end

  def update(); end
end

module ActiveResource::Singleton::ClassMethods
  def find(options=T.unsafe(nil)); end

  def singleton_name(); end

  def singleton_name=(singleton_name); end

  def singleton_path(prefix_options=T.unsafe(nil), query_options=T.unsafe(nil)); end
end

module ActiveResource::Singleton::ClassMethods
end

module ActiveResource::Singleton
  extend ::ActiveSupport::Concern
end

class ActiveResource::TimeoutError
  def initialize(message); end
end

class ActiveResource::TimeoutError
end

class ActiveResource::UnauthorizedAccess
end

class ActiveResource::UnauthorizedAccess
end

module ActiveResource::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveResource::VERSION
end

module ActiveResource::Validations
  def errors(); end

  def load_remote_errors(remote_errors, save_cache=T.unsafe(nil)); end

  def save_with_validation(options=T.unsafe(nil)); end

  def valid?(); end
end

module ActiveResource::Validations
  extend ::ActiveSupport::Concern
end

module ActiveResource
  extend ::ActiveSupport::Autoload
end

module ActiveStorage
  def analyzers(); end

  def analyzers=(obj); end

  def binary_content_type(); end

  def binary_content_type=(obj); end

  def content_types_allowed_inline(); end

  def content_types_allowed_inline=(obj); end

  def content_types_to_serve_as_binary(); end

  def content_types_to_serve_as_binary=(obj); end

  def logger(); end

  def logger=(obj); end

  def paths(); end

  def paths=(obj); end

  def previewers(); end

  def previewers=(obj); end

  def queues(); end

  def queues=(obj); end

  def replace_on_assign_to_many(); end

  def replace_on_assign_to_many=(obj); end

  def routes_prefix(); end

  def routes_prefix=(obj); end

  def service_urls_expire_in(); end

  def service_urls_expire_in=(obj); end

  def variable_content_types(); end

  def variable_content_types=(obj); end

  def variant_processor(); end

  def variant_processor=(obj); end

  def verifier(); end

  def verifier=(obj); end
end

class ActiveStorage::Analyzer
  def blob(); end

  def initialize(blob); end

  def metadata(); end
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer
  def self.accept?(blob); end
end

class ActiveStorage::Attached
  def initialize(name, record); end

  def name(); end

  def record(); end
end

module ActiveStorage::Attached::Changes
end

class ActiveStorage::Attached::Changes::CreateMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record, attachables); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateMany
end

class ActiveStorage::Attached::Changes::CreateOne
  def attachable(); end

  def attachment(); end

  def blob(); end

  def initialize(name, record, attachable); end

  def name(); end

  def record(); end

  def save(); end

  def upload(); end
end

class ActiveStorage::Attached::Changes::CreateOne
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::CreateOneOfMany
end

class ActiveStorage::Attached::Changes::DeleteMany
  def attachables(); end

  def attachments(); end

  def blobs(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteMany
end

class ActiveStorage::Attached::Changes::DeleteOne
  def attachment(); end

  def initialize(name, record); end

  def name(); end

  def record(); end

  def save(); end
end

class ActiveStorage::Attached::Changes::DeleteOne
end

module ActiveStorage::Attached::Changes
  extend ::ActiveSupport::Autoload
end

class ActiveStorage::Attached::Many
  def method_missing(method, *args, &block); end
end

module ActiveStorage::Attached::Model
  def attachment_changes(); end

  def reload(*_); end
end

module ActiveStorage::Attached::Model
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Attached::One
  def method_missing(method, *args, &block); end
end

class ActiveStorage::Engine
end

class ActiveStorage::Engine
end

class ActiveStorage::Error
end

class ActiveStorage::Error
end

class ActiveStorage::FileNotFoundError
end

class ActiveStorage::FileNotFoundError
end

class ActiveStorage::IntegrityError
end

class ActiveStorage::IntegrityError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::Previewer
  def blob(); end

  def initialize(blob); end

  def preview(); end
end

class ActiveStorage::Previewer::MuPDFPreviewer
end

class ActiveStorage::Previewer::MuPDFPreviewer
  def self.mutool_exists?(); end

  def self.mutool_path(); end
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
  def self.pdftoppm_exists?(); end

  def self.pdftoppm_path(); end
end

class ActiveStorage::Previewer::VideoPreviewer
end

class ActiveStorage::Previewer::VideoPreviewer
end

class ActiveStorage::Previewer
  def self.accept?(blob); end
end

module ActiveStorage::Reflection
end

module ActiveStorage::Reflection::ActiveRecordExtensions
end

module ActiveStorage::Reflection::ActiveRecordExtensions
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Reflection::HasManyAttachedReflection
  def macro(); end
end

class ActiveStorage::Reflection::HasManyAttachedReflection
end

class ActiveStorage::Reflection::HasOneAttachedReflection
  def macro(); end
end

class ActiveStorage::Reflection::HasOneAttachedReflection
end

module ActiveStorage::Reflection::ReflectionExtension
  def add_attachment_reflection(model, name, reflection); end
end

module ActiveStorage::Reflection::ReflectionExtension
end

module ActiveStorage::Reflection
end

class ActiveStorage::Service
  def delete(key); end

  def delete_prefixed(prefix); end

  def download(key); end

  def download_chunk(key, range); end

  def exist?(key); end

  def headers_for_direct_upload(key, filename:, content_type:, content_length:, checksum:); end

  def open(*args, &block); end

  def update_metadata(key, **metadata); end

  def upload(key, io, checksum: T.unsafe(nil), **options); end

  def url(key, expires_in:, disposition:, filename:, content_type:); end

  def url_for_direct_upload(key, expires_in:, content_type:, content_length:, checksum:); end
end

class ActiveStorage::Service::Configurator
  def build(service_name); end

  def configurations(); end

  def initialize(configurations); end
end

class ActiveStorage::Service::Configurator
  def self.build(service_name, configurations); end
end

class ActiveStorage::Service
  extend ::ActiveSupport::Autoload
  def self.build(configurator:, service: T.unsafe(nil), **service_config); end

  def self.configure(service_name, configurations); end
end

module ActiveStorage::Transformers
end

class ActiveStorage::Transformers::Transformer
  def initialize(transformations); end

  def transform(file, format:); end

  def transformations(); end
end

class ActiveStorage::Transformers::Transformer
end

module ActiveStorage::Transformers
  extend ::ActiveSupport::Autoload
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnrepresentableError
end

class ActiveStorage::UnrepresentableError
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::VERSION
end

module ActiveStorage
  extend ::ActiveSupport::Autoload
  def self.analyzers(); end

  def self.analyzers=(obj); end

  def self.binary_content_type(); end

  def self.binary_content_type=(obj); end

  def self.content_types_allowed_inline(); end

  def self.content_types_allowed_inline=(obj); end

  def self.content_types_to_serve_as_binary(); end

  def self.content_types_to_serve_as_binary=(obj); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.paths(); end

  def self.paths=(obj); end

  def self.previewers(); end

  def self.previewers=(obj); end

  def self.queues(); end

  def self.queues=(obj); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.replace_on_assign_to_many(); end

  def self.replace_on_assign_to_many=(obj); end

  def self.routes_prefix(); end

  def self.routes_prefix=(obj); end

  def self.service_urls_expire_in(); end

  def self.service_urls_expire_in=(obj); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end

  def self.variable_content_types(); end

  def self.variable_content_types=(obj); end

  def self.variant_processor(); end

  def self.variant_processor=(obj); end

  def self.verifier(); end

  def self.verifier=(obj); end
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(obj); end

  def test_order(); end

  def test_order=(obj); end
end

module ActiveSupport::ActionableError
end

module ActiveSupport::ActionableError
  extend ::ActiveSupport::Concern
  def self.actions(error); end

  def self.dispatch(error, name); end
end

class ActiveSupport::ArrayInquirer
  def any?(*candidates); end
end

class ActiveSupport::ArrayInquirer
end

module ActiveSupport::Autoload
  def autoload(const_name, path=T.unsafe(nil)); end

  def autoload_at(path); end

  def autoload_under(path); end

  def autoloads(); end

  def eager_autoload(); end

  def eager_load!(); end
end

module ActiveSupport::Autoload
  def self.extended(base); end
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean(backtrace, kind=T.unsafe(nil)); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::BacktraceCleaner
end

module ActiveSupport::Benchmarkable
  def benchmark(message=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActiveSupport::Benchmarkable
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format=T.unsafe(nil)); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
  def dup_value!(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(value); end

  def initialize(value, compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), version: T.unsafe(nil), expires_in: T.unsafe(nil), **_); end

  def mismatched?(version); end

  def size(); end

  def value(); end

  def version(); end
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
end

class ActiveSupport::Cache::FileStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  def cache_path(); end

  def initialize(cache_path, options=T.unsafe(nil)); end
  DIR_FORMATTER = ::T.let(nil, ::T.untyped)
  FILENAME_MAX_SIZE = ::T.let(nil, ::T.untyped)
  FILEPATH_MAX_SIZE = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::MemoryStore
  def prune(target_size, max_time=T.unsafe(nil)); end

  def pruning?(); end

  def synchronize(&block); end
  PER_ENTRY_OVERHEAD = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::MemoryStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
  def self.supports_cache_versioning?(); end
end

class ActiveSupport::Cache::Store
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(name, options=T.unsafe(nil)); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def fetch(name, options=T.unsafe(nil)); end

  def fetch_multi(*names); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def logger=(obj); end

  def mute(); end

  def options(); end

  def read(name, options=T.unsafe(nil)); end

  def read_multi(*names); end

  def silence(); end

  def silence!(); end

  def silence?(); end

  def write(name, value, options=T.unsafe(nil)); end

  def write_multi(hash, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::Store
  def self.logger(); end

  def self.logger=(obj); end
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def middleware(); end

  def with_local_cache(); end
end

module ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.lookup_store(*store_option); end
end

class ActiveSupport::CachingKeyGenerator
  def generate_key(*args); end

  def initialize(key_generator); end
end

class ActiveSupport::CachingKeyGenerator
end

module ActiveSupport::Callbacks
  def run_callbacks(kind); end
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Callbacks
  extend ::ActiveSupport::Concern
end

module ActiveSupport::CompareWithRange
  def ===(value); end

  def cover?(value); end

  def include?(value); end
end

module ActiveSupport::CompareWithRange
end

module ActiveSupport::Concern
  def append_features(base); end

  def class_methods(&class_methods_module_definition); end

  def included(base=T.unsafe(nil), &block); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
  def initialize(); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
end

module ActiveSupport::Concern
  def self.extended(base); end
end

module ActiveSupport::Concurrency
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
end

class ActiveSupport::Concurrency::ShareLock
  include ::MonitorMixin
  def exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), after_compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def initialize(); end

  def raw_state(); end

  def sharing(); end

  def start_exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def start_sharing(); end

  def stop_exclusive(compatible: T.unsafe(nil)); end

  def stop_sharing(); end

  def yield_shares(purpose: T.unsafe(nil), compatible: T.unsafe(nil), block_share: T.unsafe(nil)); end
end

class ActiveSupport::Concurrency::ShareLock
end

module ActiveSupport::Concurrency
end

module ActiveSupport::Configurable
  def config(); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::CurrentAttributes
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def reset(); end

  def set(set_attributes); end
end

class ActiveSupport::CurrentAttributes
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.after_reset(&block); end

  def self.attribute(*names); end

  def self.before_reset(&block); end

  def self.clear_all(); end

  def self.instance(); end

  def self.reset(*args, &block); end

  def self.reset_all(); end

  def self.resets(&block); end

  def self.set(*args, &block); end
end

module ActiveSupport::Dependencies
  def _eager_load_paths(); end

  def _eager_load_paths=(obj); end

  def autoload_module!(into, const_name, qualified_name, path_suffix); end

  def autoload_once_paths(); end

  def autoload_once_paths=(obj); end

  def autoload_paths(); end

  def autoload_paths=(obj); end

  def autoloadable_module?(path_suffix); end

  def autoloaded?(desc); end

  def autoloaded_constants(); end

  def autoloaded_constants=(obj); end

  def clear(); end

  def constant_watch_stack(); end

  def constant_watch_stack=(obj); end

  def constantize(name); end

  def depend_on(file_name, message=T.unsafe(nil)); end

  def explicitly_unloadable_constants(); end

  def explicitly_unloadable_constants=(obj); end

  def history(); end

  def history=(obj); end

  def hook!(); end

  def interlock(); end

  def interlock=(obj); end

  def load?(); end

  def load_file(path, const_paths=T.unsafe(nil)); end

  def load_missing_constant(from_mod, const_name); end

  def load_once_path?(path); end

  def loadable_constants_for_path(path, bases=T.unsafe(nil)); end

  def loaded(); end

  def loaded=(obj); end

  def loading(); end

  def loading=(obj); end

  def log(message); end

  def logger(); end

  def logger=(obj); end

  def mark_for_unload(const_desc); end

  def mechanism(); end

  def mechanism=(obj); end

  def new_constants_in(*descs); end

  def qualified_const_defined?(path); end

  def qualified_name_for(mod, name); end

  def reference(klass); end

  def remove_constant(const); end

  def remove_unloadable_constants!(); end

  def require_or_load(file_name, const_path=T.unsafe(nil)); end

  def safe_constantize(name); end

  def search_for_file(path_suffix); end

  def to_constant_name(desc); end

  def unhook!(); end

  def verbose(); end

  def verbose=(obj); end

  def warnings_on_first_load(); end

  def warnings_on_first_load=(obj); end

  def will_unload?(const_desc); end
  Reference = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies::Blamable
  def blame_file!(file); end

  def blamed_files(); end

  def copy_blame!(exc); end

  def describe_blame(); end
end

module ActiveSupport::Dependencies::Blamable
end

class ActiveSupport::Dependencies::ClassCache
  def [](key); end

  def clear!(); end

  def empty?(); end

  def get(key); end

  def key?(key); end

  def safe_get(key); end

  def store(klass); end
end

class ActiveSupport::Dependencies::ClassCache
end

class ActiveSupport::Dependencies::Interlock
  def done_running(); end

  def done_unloading(); end

  def loading(); end

  def permit_concurrent_loads(); end

  def raw_state(&block); end

  def running(); end

  def start_running(); end

  def start_unloading(); end

  def unloading(); end
end

class ActiveSupport::Dependencies::Interlock
end

module ActiveSupport::Dependencies::Loadable
  def load_dependency(file); end

  def require_dependency(file_name, message=T.unsafe(nil)); end

  def require_or_load(file_name); end

  def unloadable(const_desc); end
end

module ActiveSupport::Dependencies::Loadable
  def self.exclude_from(base); end

  def self.include_into(base); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def const_missing(const_name); end

  def guess_for_anonymous(const_name); end

  def unloadable(const_desc=T.unsafe(nil)); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def self.append_features(base); end

  def self.exclude_from(base); end

  def self.include_into(base); end
end

class ActiveSupport::Dependencies::WatchStack
  include ::Enumerable
  def each(&block); end

  def new_constants(); end

  def watch_namespaces(namespaces); end

  def watching(); end

  def watching?(); end
end

class ActiveSupport::Dependencies::WatchStack
end

module ActiveSupport::Dependencies::ZeitwerkIntegration
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
  def autoloaded?(object); end

  def autoloaded_constants(); end

  def clear(); end

  def constantize(cpath); end

  def safe_constantize(cpath); end

  def unhook!(); end

  def verbose=(verbose); end
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Inflector
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::Inflector
  def self.camelize(basename, _abspath); end

  def self.inflect(overrides); end
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
  def require_dependency(filename); end
end

module ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
end

module ActiveSupport::Dependencies::ZeitwerkIntegration
  def self.take_over(enable_reloading:); end
end

module ActiveSupport::Dependencies
  extend ::ActiveSupport::Dependencies
  def self.load_interlock(); end

  def self.run_interlock(); end

  def self.unload_interlock(); end
end

class ActiveSupport::Deprecation
  include ::Singleton
  include ::ActiveSupport::Deprecation::InstanceDelegator
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::MethodWrapper
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Behavior
  def behavior(); end

  def behavior=(behavior); end

  def debug(); end

  def debug=(debug); end
end

module ActiveSupport::Deprecation::Behavior
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  def self.included(base); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def initialize(old_const, new_const, deprecator=T.unsafe(nil), message: T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def self.new(*args, &block); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
  def initialize(instance, method, var=T.unsafe(nil), deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
  def initialize(object, message, deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
  def self.new(*args, &block); end
end

module ActiveSupport::Deprecation::InstanceDelegator
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  def include(included_module); end

  def method_added(method_name); end
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
end

module ActiveSupport::Deprecation::InstanceDelegator
  def self.included(base); end
end

module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end

module ActiveSupport::Deprecation::MethodWrapper
end

module ActiveSupport::Deprecation::Reporting
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def silence(); end

  def silenced(); end

  def silenced=(silenced); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
  RAILS_GEM_ROOT = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Reporting
end

class ActiveSupport::Deprecation
  extend ::Singleton::SingletonClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def self.behavior(*args, &block); end

  def self.behavior=(arg); end

  def self.debug(*args, &block); end

  def self.debug=(arg); end

  def self.deprecate_methods(*args, &block); end

  def self.deprecation_horizon(*args, &block); end

  def self.deprecation_horizon=(arg); end

  def self.deprecation_warning(*args, &block); end

  def self.gem_name(*args, &block); end

  def self.gem_name=(arg); end

  def self.initialize(*args, &block); end

  def self.instance(); end

  def self.silence(*args, &block); end

  def self.silenced(*args, &block); end

  def self.silenced=(arg); end

  def self.warn(*args, &block); end
end

class ActiveSupport::DeprecationException
end

class ActiveSupport::DeprecationException
end

module ActiveSupport::DescendantsTracker
  def descendants(); end

  def direct_descendants(); end

  def inherited(base); end
end

class ActiveSupport::DescendantsTracker::DescendantsArray
  include ::Enumerable
  def <<(klass); end

  def cleanup!(); end

  def each(&blk); end

  def refs_size(); end

  def reject!(); end
end

class ActiveSupport::DescendantsTracker::DescendantsArray
end

module ActiveSupport::DescendantsTracker
  def self.clear(); end

  def self.descendants(klass); end

  def self.direct_descendants(klass); end

  def self.store_inherited(klass, descendant); end
end

class ActiveSupport::Digest
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  def -@(); end

  def after(time=T.unsafe(nil)); end

  def ago(time=T.unsafe(nil)); end

  def before(time=T.unsafe(nil)); end

  def coerce(other); end

  def encode_with(coder); end

  def from_now(time=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(value, parts); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def parts(); end

  def parts=(parts); end

  def since(time=T.unsafe(nil)); end

  def until(time=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
end

class ActiveSupport::Duration::ISO8601Serializer
end

class ActiveSupport::Duration::Scalar
  def %(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def coerce(other); end

  def initialize(value); end

  def to_f(*args, &block); end

  def to_i(*args, &block); end

  def to_s(*args, &block); end

  def value(); end
end

class ActiveSupport::Duration::Scalar
end

class ActiveSupport::Duration
  def self.===(other); end

  def self.days(value); end

  def self.hours(value); end

  def self.minutes(value); end

  def self.months(value); end

  def self.seconds(value); end

  def self.weeks(value); end

  def self.years(value); end
end

module ActiveSupport::EachTimeWithZone
  def each(&block); end

  def step(n=T.unsafe(nil), &block); end
end

module ActiveSupport::EachTimeWithZone
end

class ActiveSupport::EncryptedConfiguration
  def [](*args, &block); end

  def config(); end

  def fetch(*args, &block); end

  def initialize(config_path:, key_path:, env_key:, raise_if_missing_key:); end

  def method_missing(method, *args, &block); end
end

class ActiveSupport::EncryptedConfiguration
end

class ActiveSupport::EncryptedFile
  def change(&block); end

  def content_path(); end

  def env_key(); end

  def initialize(content_path:, key_path:, env_key:, raise_if_missing_key:); end

  def key(); end

  def key_path(); end

  def raise_if_missing_key(); end

  def read(); end

  def write(contents); end
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EncryptedFile::MissingContentError
  def initialize(content_path); end
end

class ActiveSupport::EncryptedFile::MissingContentError
end

class ActiveSupport::EncryptedFile::MissingKeyError
  def initialize(key_path:, env_key:); end
end

class ActiveSupport::EncryptedFile::MissingKeyError
end

class ActiveSupport::EncryptedFile
  def self.generate_key(); end
end

class ActiveSupport::EventedFileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
  def existing_parent(dir); end

  def filter_out_descendants(dirs); end

  def longest_common_subpath(paths); end

  def normalize_extension(ext); end

  def xpath(path); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
end

class ActiveSupport::EventedFileUpdateChecker
end

class ActiveSupport::ExecutionWrapper
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _complete_callbacks(); end

  def _run_callbacks(); end

  def _run_complete_callbacks(&block); end

  def _run_run_callbacks(&block); end

  def complete!(); end

  def run!(); end
  Null = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def after(target); end

  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._complete_callbacks(); end

  def self._complete_callbacks=(value); end

  def self._run_callbacks(); end

  def self._run_callbacks=(value); end

  def self.active(); end

  def self.active=(active); end

  def self.active?(); end

  def self.inherited(other); end

  def self.register_hook(hook, outer: T.unsafe(nil)); end

  def self.run!(); end

  def self.to_complete(*args, &block); end

  def self.to_run(*args, &block); end

  def self.wrap(); end
end

class ActiveSupport::Executor
end

class ActiveSupport::Executor
end

class ActiveSupport::FileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::FileUpdateChecker
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

class ActiveSupport::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def assoc(key); end

  def default(*args); end

  def delete(key); end

  def dig(*args); end

  def fetch(key, *extras); end

  def fetch_values(*indices, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash, &block); end

  def merge!(other_hash); end

  def regular_update(*_); end

  def regular_writer(_, _1); end

  def reject(*args, &block); end

  def replace(other_hash); end

  def select(*args, &block); end

  def slice(*keys); end

  def store(key, value); end

  def transform_keys(*args, &block); end

  def transform_values(*args, &block); end

  def update(other_hash); end

  def values_at(*keys); end

  def without(*keys); end
end

class ActiveSupport::HashWithIndifferentAccess
  def self.[](*args); end
end

module ActiveSupport::IncludeTimeWithZone
  def include?(value); end
end

module ActiveSupport::IncludeTimeWithZone
end

class ActiveSupport::Inflector::Inflections
  def acronym(word); end

  def acronyms(); end

  def acronyms_camelize_regex(); end

  def acronyms_underscore_regex(); end

  def clear(scope=T.unsafe(nil)); end

  def human(rule, replacement); end

  def humans(); end

  def irregular(singular, plural); end

  def plural(rule, replacement); end

  def plurals(); end

  def singular(rule, replacement); end

  def singulars(); end

  def uncountable(*words); end

  def uncountables(); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
  def <<(*word); end

  def add(words); end

  def delete(entry); end

  def initialize(); end

  def uncountable?(str); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
end

class ActiveSupport::Inflector::Inflections
  def self.instance(locale=T.unsafe(nil)); end
end

module ActiveSupport::Inflector
  extend ::ActiveSupport::Inflector
end

class ActiveSupport::InheritableOptions
  def inheritable_copy(); end

  def initialize(parent=T.unsafe(nil)); end
end

class ActiveSupport::InheritableOptions
end

module ActiveSupport::JSON
  DATETIME_REGEX = ::T.let(nil, ::T.untyped)
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.parse_error(); end
end

class ActiveSupport::KeyGenerator
  def generate_key(salt, key_size=T.unsafe(nil)); end

  def initialize(secret, options=T.unsafe(nil)); end
end

class ActiveSupport::KeyGenerator
end

module ActiveSupport::LazyLoadHooks
  def on_load(name, options=T.unsafe(nil), &block); end

  def run_load_hooks(name, base=T.unsafe(nil)); end
end

module ActiveSupport::LazyLoadHooks
  def self.extended(base); end
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(obj); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def self.colorize_logging(); end

  def self.colorize_logging=(obj); end

  def self.flush_all!(); end

  def self.log_subscribers(); end

  def self.logger(); end

  def self.logger=(logger); end
end

class ActiveSupport::Logger
  include ::ActiveSupport::LoggerSilence
  include ::ActiveSupport::LoggerThreadSafeLevel
  def initialize(*args); end

  def silencer(); end

  def silencer=(obj); end
end

class ActiveSupport::Logger::SimpleFormatter
  def call(severity, timestamp, progname, msg); end
end

class ActiveSupport::Logger::SimpleFormatter
end

class ActiveSupport::Logger
  def self.broadcast(logger); end

  def self.local_levels(); end

  def self.local_levels=(obj); end

  def self.logger_outputs_to?(logger, *sources); end

  def self.silencer(); end

  def self.silencer=(obj); end
end

module ActiveSupport::LoggerSilence
  def silence(temporary_level=T.unsafe(nil)); end
end

module ActiveSupport::LoggerSilence
  extend ::ActiveSupport::Concern
end

module ActiveSupport::LoggerThreadSafeLevel
  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def after_initialize(); end

  def debug?(); end

  def error?(); end

  def fatal?(); end

  def info?(); end

  def level(); end

  def local_level(); end

  def local_level=(level); end

  def local_log_id(); end

  def unknown?(); end

  def warn?(); end
end

module ActiveSupport::LoggerThreadSafeLevel
  extend ::ActiveSupport::Concern
end

module ActiveSupport::MarshalWithAutoloading
  def load(source, proc=T.unsafe(nil)); end
end

module ActiveSupport::MarshalWithAutoloading
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
  def encrypt_and_sign(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

module ActiveSupport::MessageEncryptor::NullSerializer
end

module ActiveSupport::MessageEncryptor::NullSerializer
  def self.dump(value); end

  def self.load(value); end
end

module ActiveSupport::MessageEncryptor::NullVerifier
end

module ActiveSupport::MessageEncryptor::NullVerifier
  def self.generate(value); end

  def self.verify(value); end
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageEncryptor
  def self.default_cipher(); end

  def self.key_len(cipher=T.unsafe(nil)); end

  def self.use_authenticated_message_encryption(); end

  def self.use_authenticated_message_encryption=(obj); end
end

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  def generate(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def valid_message?(signed_message); end

  def verify(*args); end
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier
end

module ActiveSupport::Messages
end

class ActiveSupport::Messages::Metadata
  def initialize(message, expires_at=T.unsafe(nil), purpose=T.unsafe(nil)); end

  def verify(purpose); end
end

class ActiveSupport::Messages::Metadata
  def self.verify(message, purpose); end

  def self.wrap(message, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

class ActiveSupport::Messages::RotationConfiguration
  def encrypted(); end

  def rotate(kind, *args); end

  def signed(); end
end

class ActiveSupport::Messages::RotationConfiguration
end

module ActiveSupport::Messages::Rotator
  def initialize(*_, **options); end

  def rotate(*secrets, **options); end
end

module ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
  def decrypt_and_verify(*args, on_rotation: T.unsafe(nil), **options); end
end

module ActiveSupport::Messages::Rotator::Encryptor
end

module ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  def verified(*args, on_rotation: T.unsafe(nil), **options); end
end

module ActiveSupport::Messages::Rotator::Verifier
end

module ActiveSupport::Messages::Rotator
end

module ActiveSupport::Messages
end

module ActiveSupport::Multibyte
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*args, &block); end

  def acts_like_string?(*args, &block); end

  def compose(); end

  def decompose(); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
  def self.consumes?(string); end
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def downcase(string); end

  def normalize(string, form=T.unsafe(nil)); end

  def pack_graphemes(unpacked); end

  def swapcase(string); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def unpack_graphemes(string); end

  def upcase(string); end
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORM_ALIASES = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
end

module ActiveSupport::Multibyte
  def self.proxy_class(); end

  def self.proxy_class=(klass); end
end

module ActiveSupport::Notifications
end

class ActiveSupport::Notifications::Event
  def <<(event); end

  def allocations(); end

  def children(); end

  def cpu_time(); end

  def duration(); end

  def end(); end

  def end=(ending); end

  def finish!(); end

  def idle_time(); end

  def initialize(name, start, ending, transaction_id, payload); end

  def name(); end

  def parent_of?(event); end

  def payload(); end

  def start!(); end

  def time(); end

  def transaction_id(); end
end

class ActiveSupport::Notifications::Event
end

class ActiveSupport::Notifications::Fanout
  include ::Mutex_m
  def finish(name, id, payload, listeners=T.unsafe(nil)); end

  def initialize(); end

  def listeners_for(name); end

  def listening?(name); end

  def lock(); end

  def locked?(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribe(pattern=T.unsafe(nil), callable=T.unsafe(nil), &block); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end

  def unsubscribe(subscriber_or_name); end

  def wait(); end
end

module ActiveSupport::Notifications::Fanout::Subscribers
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
  def finish(name, id, payload); end

  def initialize(delegate); end

  def matches?(_); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end

  def unsubscribe!(*_); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::EventObject
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def finish(name, id, payload); end

  def initialize(pattern, delegate); end

  def matches?(name); end

  def pattern(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def ===(name); end

  def exclusions(); end

  def initialize(pattern); end

  def pattern(); end

  def unsubscribe!(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def self.wrap(pattern); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

module ActiveSupport::Notifications::Fanout::Subscribers
  def self.event_object_subscriber(pattern, block); end

  def self.new(pattern, listener); end

  def self.wrap_all(pattern, subscriber); end
end

class ActiveSupport::Notifications::Fanout
end

class ActiveSupport::Notifications::InstrumentationRegistry
  def instrumenter_for(notifier); end
end

class ActiveSupport::Notifications::InstrumentationRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

class ActiveSupport::Notifications::Instrumenter
  def finish(name, payload); end

  def finish_with_state(listeners_state, name, payload); end

  def id(); end

  def initialize(notifier); end

  def instrument(name, payload=T.unsafe(nil)); end

  def start(name, payload); end
end

class ActiveSupport::Notifications::Instrumenter
end

module ActiveSupport::Notifications
  def self.instrument(name, payload=T.unsafe(nil)); end

  def self.instrumenter(); end

  def self.notifier(); end

  def self.notifier=(notifier); end

  def self.publish(name, *args); end

  def self.subscribe(*args, &block); end

  def self.subscribed(callback, *args, &block); end

  def self.unsubscribe(subscriber_or_name); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(val); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(val); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(val); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(val); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::NumberHelper
end

module ActiveSupport::NumericWithFormat
  def to_s(format=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActiveSupport::NumericWithFormat
end

class ActiveSupport::OptionMerger
  def initialize(context, options); end
end

class ActiveSupport::OptionMerger
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedHash
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def _get(_); end

  def method_missing(name, *args); end
end

class ActiveSupport::OrderedOptions
end

class ActiveSupport::ParameterFilter
  def filter(params); end

  def filter_param(key, value); end

  def initialize(filters=T.unsafe(nil), mask: T.unsafe(nil)); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ParameterFilter::CompiledFilter
  def blocks(); end

  def call(params, parents=T.unsafe(nil), original_params=T.unsafe(nil)); end

  def deep_regexps(); end

  def initialize(regexps, deep_regexps, blocks, mask:); end

  def regexps(); end

  def value_for_key(key, value, parents=T.unsafe(nil), original_params=T.unsafe(nil)); end
end

class ActiveSupport::ParameterFilter::CompiledFilter
  def self.compile(filters, mask:); end
end

class ActiveSupport::ParameterFilter
end

module ActiveSupport::PerThreadRegistry
  def instance(); end
end

module ActiveSupport::PerThreadRegistry
  def self.extended(object); end
end

class ActiveSupport::ProxyObject
  def raise(*args); end
end

class ActiveSupport::ProxyObject
end

class ActiveSupport::Railtie
end

class ActiveSupport::Railtie
end

module ActiveSupport::RangeWithFormat
  def to_default_s(format=T.unsafe(nil)); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def to_s(format=T.unsafe(nil)); end
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::RangeWithFormat
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def check(); end

  def check=(val); end

  def check?(); end

  def class_unload!(&block); end

  def executor(); end

  def executor=(val); end

  def executor?(); end

  def release_unload_lock!(); end

  def require_unload_lock!(); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end

  def self.after_class_unload(*args, &block); end

  def self.before_class_unload(*args, &block); end

  def self.check(); end

  def self.check!(); end

  def self.check=(val); end

  def self.check?(); end

  def self.executor(); end

  def self.executor=(val); end

  def self.executor?(); end

  def self.prepare!(); end

  def self.reload!(); end

  def self.reloaded!(); end

  def self.to_prepare(*args, &block); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def *(*_); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def []=(*args); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def clone_empty(); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def delete_prefix(*args, &block); end

  def delete_prefix!(*args); end

  def delete_suffix(*args, &block); end

  def delete_suffix!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args, &block); end

  def initialize(str=T.unsafe(nil)); end

  def insert(index, value); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def replace(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def slice(*args, &block); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args, &block); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def unicode_normalize(*args, &block); end

  def unicode_normalize!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
  UNSAFE_STRING_METHODS_WITH_BACKREF = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SafeBuffer
end

module ActiveSupport::SecurityUtils
end

module ActiveSupport::SecurityUtils
  def self.fixed_length_secure_compare(a, b); end

  def self.secure_compare(a, b); end
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def start(name, id, payload); end
end

class ActiveSupport::Subscriber
  def self.attach_to(namespace, subscriber=T.unsafe(nil), notifier=T.unsafe(nil)); end

  def self.detach_from(namespace, notifier=T.unsafe(nil)); end

  def self.method_added(event); end

  def self.subscribers(); end
end

class ActiveSupport::SubscriberQueueRegistry
  def get_queue(queue_key); end
end

class ActiveSupport::SubscriberQueueRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

module ActiveSupport::TaggedLogging
  def clear_tags!(*args, &block); end

  def flush(); end

  def pop_tags(*args, &block); end

  def push_tags(*args, &block); end

  def tagged(*tags); end
end

module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end

  def clear_tags!(); end

  def current_tags(); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tagged(*tags); end

  def tags_text(); end
end

module ActiveSupport::TaggedLogging::Formatter
end

module ActiveSupport::TaggedLogging
  def self.new(logger); end
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveRecord::TestDatabases
  include ::ActiveRecord::TestFixtures
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_raise(*exp); end

  def config(); end

  def config=(val); end

  def config?(); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def fixture_class_names(); end

  def fixture_class_names=(val); end

  def fixture_class_names?(); end

  def fixture_path(); end

  def fixture_path?(); end

  def fixture_table_names(); end

  def fixture_table_names=(val); end

  def fixture_table_names?(); end

  def lock_threads(); end

  def lock_threads=(val); end

  def lock_threads?(); end

  def method_name(); end

  def pre_loaded_fixtures(); end

  def pre_loaded_fixtures=(val); end

  def pre_loaded_fixtures?(); end

  def use_instantiated_fixtures(); end

  def use_instantiated_fixtures=(val); end

  def use_instantiated_fixtures?(); end

  def use_transactional_tests(); end

  def use_transactional_tests=(val); end

  def use_transactional_tests?(); end
end

class ActiveSupport::TestCase
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveSupport::Testing::Declarative
  extend ::Rails::LineFiltering
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.config(); end

  def self.config=(val); end

  def self.config?(); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(val); end

  def self.file_fixture_path?(); end

  def self.fixture_class_names(); end

  def self.fixture_class_names=(val); end

  def self.fixture_class_names?(); end

  def self.fixture_path(); end

  def self.fixture_path=(val); end

  def self.fixture_path?(); end

  def self.fixture_table_names(); end

  def self.fixture_table_names=(val); end

  def self.fixture_table_names?(); end

  def self.lock_threads(); end

  def self.lock_threads=(val); end

  def self.lock_threads?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.pre_loaded_fixtures(); end

  def self.pre_loaded_fixtures=(val); end

  def self.pre_loaded_fixtures?(); end

  def self.test_order=(new_order); end

  def self.use_instantiated_fixtures(); end

  def self.use_instantiated_fixtures=(val); end

  def self.use_instantiated_fixtures?(); end

  def self.use_transactional_tests(); end

  def self.use_transactional_tests=(val); end

  def self.use_transactional_tests?(); end
end

module ActiveSupport::Testing
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Assertions
end

module ActiveSupport::Testing::ConstantLookup
end

module ActiveSupport::Testing::ConstantLookup
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end

module ActiveSupport::Testing::Declarative
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator=T.unsafe(nil), &block); end

  def collect_deprecations(deprecator=T.unsafe(nil)); end
end

module ActiveSupport::Testing::Deprecation
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::Isolation
  include ::ActiveSupport::Testing::Isolation::Forking
  def run(); end
end

module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end

module ActiveSupport::Testing::Isolation::Forking
end

module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation::Subprocess
end

module ActiveSupport::Testing::Isolation
  def self.forking_env?(); end

  def self.included(klass); end
end

class ActiveSupport::Testing::Parallelization
  def <<(work); end

  def after_fork(worker); end

  def after_fork_hooks(); end

  def initialize(queue_size); end

  def run_cleanup(worker); end

  def run_cleanup_hooks(); end

  def shutdown(); end

  def start(); end
end

class ActiveSupport::Testing::Parallelization::Server
  include ::DRb::DRbUndumped
  def <<(o); end

  def length(); end

  def pop(); end

  def record(reporter, result); end
end

class ActiveSupport::Testing::Parallelization::Server
end

class ActiveSupport::Testing::Parallelization
  def self.after_fork_hook(&blk); end

  def self.after_fork_hooks(); end

  def self.run_cleanup_hook(&blk); end

  def self.run_cleanup_hooks(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

class ActiveSupport::Testing::SimpleStubs
  def stub_object(object, method_name, &block); end

  def stubbing(object, method_name); end

  def unstub_all!(); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def method_name(); end

  def method_name=(_); end

  def object(); end

  def object=(_); end

  def original_method(); end

  def original_method=(_); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::Testing::SimpleStubs
end

module ActiveSupport::Testing::Stream
end

module ActiveSupport::Testing::Stream
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TaggedLogging
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(&block); end

  def travel(duration, &block); end

  def travel_back(); end

  def travel_to(date_or_time); end

  def unfreeze_time(); end
end

module ActiveSupport::Testing::TimeHelpers
end

module ActiveSupport::Testing
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  include ::Comparable
  def +(other); end

  def -(other); end

  def acts_like_time?(); end

  def advance(options); end

  def after?(_); end

  def ago(other); end

  def before?(_); end

  def between?(min, max); end

  def change(options); end

  def comparable_time(); end

  def day(); end

  def dst?(); end

  def encode_with(coder); end

  def eql?(other); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def future?(); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmt?(); end

  def gmt_offset(); end

  def gmtime(); end

  def gmtoff(); end

  def hour(); end

  def httpdate(); end

  def in(other); end

  def in_time_zone(new_zone=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(utc_time, time_zone, local_time=T.unsafe(nil), period=T.unsafe(nil)); end

  def is_a?(klass); end

  def isdst(); end

  def iso8601(fraction_digits=T.unsafe(nil)); end

  def kind_of?(klass); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(variables); end

  def mday(); end

  def method_missing(sym, *args, &block); end

  def min(); end

  def mon(); end

  def month(); end

  def nsec(); end

  def past?(); end

  def period(); end

  def respond_to?(sym, include_priv=T.unsafe(nil)); end

  def rfc2822(); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def rfc822(); end

  def sec(); end

  def since(other); end

  def strftime(format); end

  def time(); end

  def time_zone(); end

  def to_a(); end

  def to_date(); end

  def to_datetime(); end

  def to_f(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def to_i(); end

  def to_r(); end

  def to_s(format=T.unsafe(nil)); end

  def to_time(); end

  def today?(); end

  def tv_sec(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end

  def wday(); end

  def xmlschema(fraction_digits=T.unsafe(nil)); end

  def yday(); end

  def year(); end

  def zone(); end
  PRECISIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  include ::Comparable
  def =~(re); end

  def at(*args); end

  def encode_with(coder); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(name, utc_offset=T.unsafe(nil), tzinfo=T.unsafe(nil)); end

  def iso8601(str); end

  def local(*args); end

  def local_to_utc(time, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def parse(str, now=T.unsafe(nil)); end

  def period_for_local(time, dst=T.unsafe(nil)); end

  def period_for_utc(time); end

  def periods_for_local(time); end

  def rfc3339(str); end

  def strptime(str, format, now=T.unsafe(nil)); end

  def today(); end

  def tomorrow(); end

  def tzinfo(); end

  def utc_offset(); end

  def utc_to_local(time); end

  def yesterday(); end
  MAPPING = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  def self.[](arg); end

  def self.all(); end

  def self.clear(); end

  def self.country_zones(country_code); end

  def self.create(*_); end

  def self.find_tzinfo(name); end

  def self.new(name); end

  def self.seconds_to_utc_offset(seconds, colon=T.unsafe(nil)); end

  def self.us_zones(); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
end

module ActiveSupport::Tryable
  def try(method_name=T.unsafe(nil), *args, &b); end

  def try!(method_name=T.unsafe(nil), *args, &b); end
end

module ActiveSupport::Tryable
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
end

class ActiveSupport::XMLConverter
  def initialize(xml, disallowed_types=T.unsafe(nil)); end

  def to_h(); end
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter::DisallowedType
  def initialize(type); end
end

class ActiveSupport::XMLConverter::DisallowedType
end

class ActiveSupport::XMLConverter
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*args, &block); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini::FileLike
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
end

module ActiveSupport::XmlMini_REXML
  def parse(data); end
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  extend ::ActiveSupport::XmlMini_REXML
end

module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks
  extend ::ActiveSupport::Autoload
  def self.escape_html_entities_in_json(*args, &block); end

  def self.escape_html_entities_in_json=(arg); end

  def self.gem_version(); end

  def self.json_encoder(*args, &block); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(obj); end

  def self.test_order(); end

  def self.test_order=(obj); end

  def self.time_precision(*args, &block); end

  def self.time_precision=(arg); end

  def self.to_time_preserves_timezone(); end

  def self.to_time_preserves_timezone=(value); end

  def self.use_standard_json_time_format(*args, &block); end

  def self.use_standard_json_time_format=(arg); end

  def self.version(); end
end

module Addressable
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeOverflow
end

class Addressable::IDNA::PunycodeOverflow
end

module Addressable::IDNA
  def self.to_ascii(input); end

  def self.to_unicode(input); end

  def self.unicode_normalize_kc(input); end
end

class Addressable::Template
  def ==(template); end

  def eql?(template); end

  def expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def extract(uri, processor=T.unsafe(nil)); end

  def generate(params=T.unsafe(nil), recall=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(pattern); end

  def keys(); end

  def match(uri, processor=T.unsafe(nil)); end

  def named_captures(); end

  def names(); end

  def partial_expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def pattern(); end

  def source(); end

  def to_regexp(); end

  def variable_defaults(); end

  def variables(); end
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::MatchData
  def [](key, len=T.unsafe(nil)); end

  def captures(); end

  def initialize(uri, template, mapping); end

  def keys(); end

  def mapping(); end

  def names(); end

  def post_match(); end

  def pre_match(); end

  def string(); end

  def template(); end

  def to_a(); end

  def uri(); end

  def values(); end

  def values_at(*indexes); end

  def variables(); end
end

class Addressable::Template::MatchData
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template
end

class Addressable::URI
  def +(uri); end

  def ==(uri); end

  def ===(uri); end

  def absolute?(); end

  def authority(); end

  def authority=(new_authority); end

  def basename(); end

  def default_port(); end

  def defer_validation(); end

  def display_uri(); end

  def domain(); end

  def empty?(); end

  def eql?(uri); end

  def extname(); end

  def fragment(); end

  def fragment=(new_fragment); end

  def host(); end

  def host=(new_host); end

  def hostname(); end

  def hostname=(new_hostname); end

  def inferred_port(); end

  def initialize(options=T.unsafe(nil)); end

  def ip_based?(); end

  def join(uri); end

  def join!(uri); end

  def merge(hash); end

  def merge!(uri); end

  def normalize(); end

  def normalize!(); end

  def normalized_authority(); end

  def normalized_fragment(); end

  def normalized_host(); end

  def normalized_password(); end

  def normalized_path(); end

  def normalized_port(); end

  def normalized_query(*flags); end

  def normalized_scheme(); end

  def normalized_site(); end

  def normalized_user(); end

  def normalized_userinfo(); end

  def omit(*components); end

  def omit!(*components); end

  def origin(); end

  def origin=(new_origin); end

  def password(); end

  def password=(new_password); end

  def path(); end

  def path=(new_path); end

  def port(); end

  def port=(new_port); end

  def query(); end

  def query=(new_query); end

  def query_values(return_type=T.unsafe(nil)); end

  def query_values=(new_query_values); end

  def relative?(); end

  def remove_composite_values(); end

  def replace_self(uri); end

  def request_uri(); end

  def request_uri=(new_request_uri); end

  def route_from(uri); end

  def route_to(uri); end

  def scheme(); end

  def scheme=(new_scheme); end

  def site(); end

  def site=(new_site); end

  def split_path(path); end

  def tld(); end

  def tld=(new_tld); end

  def to_hash(); end

  def to_str(); end

  def user(); end

  def user=(new_user); end

  def userinfo(); end

  def userinfo=(new_userinfo); end

  def validate(); end
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI
  def self.convert_path(path); end

  def self.encode(uri, return_type=T.unsafe(nil)); end

  def self.encode_component(component, character_class=T.unsafe(nil), upcase_encoded=T.unsafe(nil)); end

  def self.escape(uri, return_type=T.unsafe(nil)); end

  def self.form_encode(form_values, sort=T.unsafe(nil)); end

  def self.form_unencode(encoded_value); end

  def self.heuristic_parse(uri, hints=T.unsafe(nil)); end

  def self.ip_based_schemes(); end

  def self.join(*uris); end

  def self.normalize_component(component, character_class=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.normalize_path(path); end

  def self.normalized_encode(uri, return_type=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.port_mapping(); end

  def self.unencode(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unencode_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
end

module Addressable
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Arel::AliasPredication
  def as(other); end
end

module Arel::AliasPredication
end

class Arel::ArelError
end

class Arel::ArelError
end

Arel::Attribute = Arel::Attributes::Attribute

module Arel::Attributes
end

class Arel::Attributes::Attribute
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
  def able_to_type_cast?(); end

  def lower(); end

  def type_cast_for_database(value); end
end

class Arel::Attributes::Attribute
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Float
end

class Arel::Attributes::Float
end

class Arel::Attributes::Integer
end

class Arel::Attributes::Integer
end

class Arel::Attributes::String
end

class Arel::Attributes::String
end

class Arel::Attributes::Time
end

class Arel::Attributes::Time
end

class Arel::Attributes::Undefined
end

class Arel::Attributes::Undefined
end

module Arel::Attributes
  def self.for(column); end
end

module Arel::Collectors
end

class Arel::Collectors::Bind
  def <<(str); end

  def add_bind(bind); end

  def value(); end
end

class Arel::Collectors::Bind
end

class Arel::Collectors::Composite
  def <<(str); end

  def add_bind(bind, &block); end

  def initialize(left, right); end

  def value(); end
end

class Arel::Collectors::Composite
end

class Arel::Collectors::PlainString
  def <<(str); end

  def value(); end
end

class Arel::Collectors::PlainString
end

class Arel::Collectors::SQLString
  def add_bind(bind); end

  def initialize(*_); end
end

class Arel::Collectors::SQLString
end

class Arel::Collectors::SubstituteBinds
  def <<(str); end

  def add_bind(bind); end

  def initialize(quoter, delegate_collector); end

  def value(); end
end

class Arel::Collectors::SubstituteBinds
end

module Arel::Collectors
end

module Arel::Crud
  def compile_delete(); end

  def compile_insert(values); end

  def compile_update(values, pk); end

  def create_insert(); end
end

module Arel::Crud
end

class Arel::DeleteManager
  include ::Arel::TreeManager::StatementMethods
  def from(relation); end
end

class Arel::DeleteManager
end

class Arel::EmptyJoinError
end

class Arel::EmptyJoinError
end

module Arel::Expressions
  def average(); end

  def count(distinct=T.unsafe(nil)); end

  def extract(field); end

  def maximum(); end

  def minimum(); end

  def sum(); end
end

module Arel::Expressions
end

module Arel::FactoryMethods
  def coalesce(*exprs); end

  def create_and(clauses); end

  def create_false(); end

  def create_join(to, constraint=T.unsafe(nil), klass=T.unsafe(nil)); end

  def create_on(expr); end

  def create_string_join(to); end

  def create_table_alias(relation, name); end

  def create_true(); end

  def grouping(expr); end

  def lower(column); end
end

module Arel::FactoryMethods
end

class Arel::InsertManager
  def columns(); end

  def create_values(values); end

  def create_values_list(rows); end

  def insert(fields); end

  def into(table); end

  def select(select); end

  def values=(val); end
end

class Arel::InsertManager
end

module Arel::Math
  def &(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def <<(other); end

  def >>(other); end

  def ^(other); end

  def |(other); end

  def ~(); end
end

module Arel::Math
end

Arel::Node = Arel::Nodes::Node

module Arel::Nodes
end

class Arel::Nodes::Addition
  def initialize(left, right); end
end

class Arel::Nodes::Addition
end

class Arel::Nodes::And
  def ==(other); end

  def children(); end

  def eql?(other); end

  def initialize(children); end

  def left(); end

  def right(); end
end

class Arel::Nodes::And
end

class Arel::Nodes::As
end

class Arel::Nodes::As
end

class Arel::Nodes::Ascending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Ascending
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Between
end

class Arel::Nodes::Between
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Binary
  def ==(other); end

  def eql?(other); end

  def initialize(left, right); end

  def left(); end

  def left=(left); end

  def right(); end

  def right=(right); end
end

class Arel::Nodes::Binary
end

class Arel::Nodes::BindParam
  def ==(other); end

  def eql?(other); end

  def infinite?(); end

  def initialize(value); end

  def unboundable?(); end

  def value(); end
end

class Arel::Nodes::BindParam
end

class Arel::Nodes::BitwiseAnd
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseAnd
end

class Arel::Nodes::BitwiseNot
  def initialize(operand); end
end

class Arel::Nodes::BitwiseNot
end

class Arel::Nodes::BitwiseOr
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseOr
end

class Arel::Nodes::BitwiseShiftLeft
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftLeft
end

class Arel::Nodes::BitwiseShiftRight
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftRight
end

class Arel::Nodes::BitwiseXor
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseXor
end

class Arel::Nodes::Case
  def ==(other); end

  def case(); end

  def case=(_); end

  def conditions(); end

  def conditions=(conditions); end

  def default(); end

  def default=(default); end

  def else(expression); end

  def eql?(other); end

  def initialize(expression=T.unsafe(nil), default=T.unsafe(nil)); end

  def then(expression); end

  def when(condition, expression=T.unsafe(nil)); end
end

class Arel::Nodes::Case
end

class Arel::Nodes::Casted
  def ==(other); end

  def attribute(); end

  def eql?(other); end

  def initialize(val, attribute); end

  def val(); end
end

class Arel::Nodes::Casted
end

class Arel::Nodes::Comment
  def ==(other); end

  def eql?(other); end

  def initialize(values); end

  def values(); end
end

class Arel::Nodes::Comment
end

class Arel::Nodes::Concat
  def initialize(left, right); end
end

class Arel::Nodes::Concat
end

class Arel::Nodes::Count
  def initialize(expr, distinct=T.unsafe(nil), aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Count
end

class Arel::Nodes::Cube
end

class Arel::Nodes::Cube
end

class Arel::Nodes::CurrentRow
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::CurrentRow
end

class Arel::Nodes::DeleteStatement
  def ==(other); end

  def eql?(other); end

  def initialize(relation=T.unsafe(nil), wheres=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def left(); end

  def left=(left); end

  def limit(); end

  def limit=(limit); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def right(); end

  def right=(right); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::DeleteStatement
end

class Arel::Nodes::Descending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Descending
end

class Arel::Nodes::Distinct
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::Distinct
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::Division
  def initialize(left, right); end
end

class Arel::Nodes::Division
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::Else
end

class Arel::Nodes::Else
end

class Arel::Nodes::Equality
  def operand1(); end

  def operand2(); end

  def operator(); end
end

class Arel::Nodes::Equality
end

class Arel::Nodes::Except
end

class Arel::Nodes::Except
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Extract
  def field(); end

  def field=(field); end

  def initialize(expr, field); end
end

class Arel::Nodes::Extract
end

class Arel::Nodes::False
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::False
end

class Arel::Nodes::Following
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Following
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::Function
  include ::Arel::WindowPredications
  def ==(other); end

  def alias(); end

  def alias=(_); end

  def as(aliaz); end

  def distinct(); end

  def distinct=(distinct); end

  def eql?(other); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(expr, aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Function
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::Group
end

class Arel::Nodes::Group
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::In
end

class Arel::Nodes::In
end

class Arel::Nodes::InfixOperation
  def initialize(operator, left, right); end

  def operator(); end
end

class Arel::Nodes::InfixOperation
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InsertStatement
  def ==(other); end

  def columns(); end

  def columns=(columns); end

  def eql?(other); end

  def relation(); end

  def relation=(relation); end

  def select=(select); end

  def values(); end

  def values=(values); end
end

class Arel::Nodes::InsertStatement
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::Join
end

class Arel::Nodes::Join
end

class Arel::Nodes::JoinSource
  def empty?(); end

  def initialize(single_source, joinop=T.unsafe(nil)); end
end

class Arel::Nodes::JoinSource
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Matches
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def escape(); end

  def initialize(left, right, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Matches
end

class Arel::Nodes::Max
end

class Arel::Nodes::Max
end

class Arel::Nodes::Min
end

class Arel::Nodes::Min
end

class Arel::Nodes::Multiplication
  def initialize(left, right); end
end

class Arel::Nodes::Multiplication
end

class Arel::Nodes::NamedFunction
  def initialize(name, expr, aliaz=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedFunction
end

class Arel::Nodes::NamedWindow
  def initialize(name); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedWindow
end

class Arel::Nodes::Node
  include ::Arel::FactoryMethods
  include ::Enumerable
  def and(right); end

  def each(&block); end

  def not(); end

  def or(right); end

  def to_sql(engine=T.unsafe(nil)); end
end

class Arel::Nodes::Node
end

class Arel::Nodes::NodeExpression
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
end

class Arel::Nodes::NodeExpression
end

class Arel::Nodes::Not
end

class Arel::Nodes::Not
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::Offset
end

class Arel::Nodes::Offset
end

class Arel::Nodes::On
end

class Arel::Nodes::On
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::Or
end

class Arel::Nodes::Or
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::Over
  def initialize(left, right=T.unsafe(nil)); end

  def operator(); end
end

class Arel::Nodes::Over
end

class Arel::Nodes::Preceding
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Preceding
end

class Arel::Nodes::Quoted
  def infinite?(); end

  def val(); end
end

class Arel::Nodes::Quoted
end

class Arel::Nodes::Range
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Range
end

class Arel::Nodes::Regexp
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def initialize(left, right, case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Regexp
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::Rows
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Rows
end

class Arel::Nodes::SelectCore
  def ==(other); end

  def comment(); end

  def comment=(comment); end

  def eql?(other); end

  def from(); end

  def from=(value); end

  def froms(); end

  def froms=(value); end

  def groups(); end

  def groups=(groups); end

  def havings(); end

  def havings=(havings); end

  def optimizer_hints(); end

  def optimizer_hints=(optimizer_hints); end

  def projections(); end

  def projections=(projections); end

  def set_quantifier(); end

  def set_quantifier=(set_quantifier); end

  def source(); end

  def source=(source); end

  def wheres(); end

  def wheres=(wheres); end

  def windows(); end

  def windows=(windows); end
end

class Arel::Nodes::SelectCore
end

class Arel::Nodes::SelectStatement
  def ==(other); end

  def cores(); end

  def eql?(other); end

  def initialize(cores=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(); end

  def lock=(lock); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def with(); end

  def with=(with); end
end

class Arel::Nodes::SelectStatement
end

class Arel::Nodes::SqlLiteral
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  def encode_with(coder); end
end

class Arel::Nodes::SqlLiteral
end

class Arel::Nodes::StringJoin
  def initialize(left, right=T.unsafe(nil)); end
end

class Arel::Nodes::StringJoin
end

class Arel::Nodes::Subtraction
  def initialize(left, right); end
end

class Arel::Nodes::Subtraction
end

class Arel::Nodes::Sum
end

class Arel::Nodes::Sum
end

class Arel::Nodes::TableAlias
  def [](name); end

  def able_to_type_cast?(); end

  def name(); end

  def relation(); end

  def table_alias(); end

  def table_name(); end

  def type_cast_for_database(*args); end
end

class Arel::Nodes::TableAlias
end

class Arel::Nodes::True
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::True
end

class Arel::Nodes::Unary
  def ==(other); end

  def eql?(other); end

  def expr(); end

  def expr=(expr); end

  def initialize(expr); end

  def value(); end
end

class Arel::Nodes::Unary
end

class Arel::Nodes::UnaryOperation
  def initialize(operator, operand); end

  def operator(); end
end

class Arel::Nodes::UnaryOperation
end

class Arel::Nodes::Union
end

class Arel::Nodes::Union
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnqualifiedColumn
  def attribute(); end

  def attribute=(attribute); end

  def column(); end

  def name(); end

  def relation(); end
end

class Arel::Nodes::UnqualifiedColumn
end

class Arel::Nodes::UpdateStatement
  def ==(other); end

  def eql?(other); end

  def key(); end

  def key=(key); end

  def limit(); end

  def limit=(limit); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def values(); end

  def values=(values); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::UpdateStatement
end

class Arel::Nodes::ValuesList
  def rows(); end
end

class Arel::Nodes::ValuesList
end

class Arel::Nodes::When
end

class Arel::Nodes::When
end

class Arel::Nodes::Window
  def ==(other); end

  def eql?(other); end

  def frame(expr); end

  def framing(); end

  def framing=(framing); end

  def order(*expr); end

  def orders(); end

  def orders=(orders); end

  def partition(*expr); end

  def partitions(); end

  def partitions=(partitions); end

  def range(expr=T.unsafe(nil)); end

  def rows(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Window
end

class Arel::Nodes::With
  def children(); end
end

class Arel::Nodes::With
end

class Arel::Nodes::WithRecursive
end

class Arel::Nodes::WithRecursive
end

module Arel::Nodes
  def self.build_quoted(other, attribute=T.unsafe(nil)); end
end

module Arel::OrderPredications
  def asc(); end

  def desc(); end
end

module Arel::OrderPredications
end

module Arel::Predications
  def between(other); end

  def concat(other); end

  def does_not_match(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def does_not_match_all(others, escape=T.unsafe(nil)); end

  def does_not_match_any(others, escape=T.unsafe(nil)); end

  def does_not_match_regexp(other, case_sensitive=T.unsafe(nil)); end

  def eq(other); end

  def eq_all(others); end

  def eq_any(others); end

  def gt(right); end

  def gt_all(others); end

  def gt_any(others); end

  def gteq(right); end

  def gteq_all(others); end

  def gteq_any(others); end

  def in(other); end

  def in_all(others); end

  def in_any(others); end

  def is_distinct_from(other); end

  def is_not_distinct_from(other); end

  def lt(right); end

  def lt_all(others); end

  def lt_any(others); end

  def lteq(right); end

  def lteq_all(others); end

  def lteq_any(others); end

  def matches(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_all(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_any(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_regexp(other, case_sensitive=T.unsafe(nil)); end

  def not_between(other); end

  def not_eq(other); end

  def not_eq_all(others); end

  def not_eq_any(others); end

  def not_in(other); end

  def not_in_all(others); end

  def not_in_any(others); end

  def when(right); end
end

module Arel::Predications
end

class Arel::SelectManager
  include ::Arel::Crud
  def as(other); end

  def comment(*values); end

  def constraints(); end

  def distinct(value=T.unsafe(nil)); end

  def distinct_on(value); end

  def except(other); end

  def exists(); end

  def from(table); end

  def froms(); end

  def group(*columns); end

  def having(expr); end

  def initialize(table=T.unsafe(nil)); end

  def intersect(other); end

  def join(relation, klass=T.unsafe(nil)); end

  def join_sources(); end

  def lateral(table_name=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(locking=T.unsafe(nil)); end

  def locked(); end

  def minus(other); end

  def offset(); end

  def offset=(amount); end

  def on(*exprs); end

  def optimizer_hints(*hints); end

  def order(*expr); end

  def orders(); end

  def outer_join(relation); end

  def project(*projections); end

  def projections(); end

  def projections=(projections); end

  def skip(amount); end

  def source(); end

  def take(limit); end

  def taken(); end

  def union(operation, other=T.unsafe(nil)); end

  def where_sql(engine=T.unsafe(nil)); end

  def window(name); end

  def with(*subqueries); end
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class Arel::SelectManager
end

class Arel::Table
  include ::Arel::Crud
  include ::Arel::FactoryMethods
  def ==(other); end

  def [](name); end

  def able_to_type_cast?(); end

  def alias(name=T.unsafe(nil)); end

  def eql?(other); end

  def from(); end

  def group(*columns); end

  def having(expr); end

  def initialize(name, as: T.unsafe(nil), type_caster: T.unsafe(nil)); end

  def join(relation, klass=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def order(*expr); end

  def outer_join(relation); end

  def project(*things); end

  def skip(amount); end

  def table_alias(); end

  def table_alias=(table_alias); end

  def table_name(); end

  def take(amount); end

  def type_cast_for_database(attribute_name, value); end

  def where(condition); end
end

class Arel::Table
  def self.engine(); end

  def self.engine=(engine); end
end

class Arel::TreeManager
  include ::Arel::FactoryMethods
  def ast(); end

  def to_dot(); end

  def to_sql(engine=T.unsafe(nil)); end

  def where(expr); end
end

module Arel::TreeManager::StatementMethods
  def key(); end

  def key=(key); end

  def offset(offset); end

  def order(*expr); end

  def take(limit); end

  def where(expr); end

  def wheres=(exprs); end
end

module Arel::TreeManager::StatementMethods
end

class Arel::TreeManager
end

class Arel::UpdateManager
  include ::Arel::TreeManager::StatementMethods
  def set(values); end

  def table(table); end
end

class Arel::UpdateManager
end

module Arel::Visitors
end

class Arel::Visitors::DepthFirst
  def initialize(block=T.unsafe(nil)); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::DepthFirst
end

class Arel::Visitors::Dot
  def accept(object, collector); end
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Node
  def fields(); end

  def fields=(fields); end

  def id(); end

  def id=(id); end

  def initialize(name, id, fields=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Visitors::Dot::Node
end

class Arel::Visitors::Dot
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::Informix
end

class Arel::Visitors::Informix
end

class Arel::Visitors::MSSQL
  def initialize(*_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def children(); end

  def children=(_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def self.[](*_); end

  def self.members(); end
end

class Arel::Visitors::MSSQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::ToSql
  def compile(node, collector=T.unsafe(nil)); end

  def initialize(connection); end
end

class Arel::Visitors::ToSql
end

class Arel::Visitors::UnsupportedVisitError
  def initialize(object); end
end

class Arel::Visitors::UnsupportedVisitError
end

class Arel::Visitors::Visitor
  def accept(object, collector=T.unsafe(nil)); end
end

class Arel::Visitors::Visitor
  def self.dispatch_cache(); end
end

class Arel::Visitors::WhereSql
  def initialize(inner_visitor, *args, &block); end
end

class Arel::Visitors::WhereSql
end

module Arel::Visitors
end

module Arel::WindowPredications
  def over(expr=T.unsafe(nil)); end
end

module Arel::WindowPredications
end

module Arel
  def self.arel_node?(value); end

  def self.fetch_attribute(value); end

  def self.sql(raw_sql); end

  def self.star(); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::Mocha::Inspect::ArrayMethods
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_default_s(); end

  def to_h(); end

end

class Array
  def self.try_convert(_); end

  def self.wrap(object); end
end

class AuthenticatedController
  include ::ShopifyApp::Localization
  include ::ShopifyApp::EmbeddedApp
end

class AuthenticatedTest
end

class AuthenticatedTest::AuthenticatedTestController
  include ::ShopifyApp::Localization
  include ::ShopifyApp::LoginProtection
  include ::ShopifyApp::Itp
  include ::ShopifyApp::EmbeddedApp
end

module Base64Bp
end

module Base64Bp
  extend ::Base64
  def self.urlsafe_encode64(bin, padding:); end
end

class BasicObject
  def __binding__(); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  include ::ActiveSupport::NumericWithFormat
  def clone(); end

  def to_d(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  include ::BindingOfCaller::BindingExtensions
  def clone(); end

  def irb(); end
end

module BindingOfCaller
end

module BindingOfCaller::BindingExtensions
  def callers(); end

  def frame_count(); end

  def frame_description(); end

  def frame_type(); end

  def of_caller(n); end
end

module BindingOfCaller::BindingExtensions
end

module BindingOfCaller
end

class BrowserSniffer
  def android?(); end

  def browser(); end

  def browser_info(); end

  def browser_name(); end

  def browser_version(); end

  def chromium_based?(); end

  def desktop?(); end

  def device(); end

  def device_info(); end

  def device_name(); end

  def device_vendor(); end

  def engine(); end

  def engine_info(); end

  def engine_name(); end

  def engine_version(); end

  def form_factor(); end

  def handheld?(); end

  def ie11?(); end

  def ie8?(); end

  def initialize(user_agent); end

  def ios?(); end

  def major_browser_version(); end

  def major_engine_version(); end

  def os(); end

  def os_info(); end

  def os_name(); end

  def os_version(); end

  def parse_user_agent_for(type); end

  def same_site_none_compatible?(); end

  def same_site_recognized_browser?(); end

  def tablet?(); end

  def uc_browser?(); end

  def uc_browser_version_at_least?(major, minor, build); end

  def user_agent(); end

  def webkit_same_site_compatible?(); end
  REGEX_MAP = ::T.let(nil, ::T.untyped)
  STRING_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BrowserSniffer
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

module Byebug
  include ::Byebug::Helpers::ReflectionHelper
  def displays(); end

  def displays=(displays); end

  def init_file(); end

  def init_file=(init_file); end

  def mode(); end

  def mode=(mode); end

  def run_init_script(); end
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
end

class Byebug::AutolistSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
end

class Byebug::AutoprySetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
end

class Byebug::AutosaveSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
end

class Byebug::BasenameSetting
  def banner(); end
end

class Byebug::BasenameSetting
end

class Byebug::BreakCommand
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::BreakCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(_, _1, _2); end

  def pos(); end

  def source(); end
end

class Byebug::Breakpoint
  def self.add(file, line, expr=T.unsafe(nil)); end

  def self.first(); end

  def self.last(); end

  def self.none?(); end

  def self.potential_line?(filename, lineno); end

  def self.potential_lines(filename); end

  def self.remove(id); end
end

class Byebug::CallstyleSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
end

class Byebug::CatchCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::CatchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Command
  def arguments(); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(); end

  def help(*args, &block); end

  def initialize(processor, input=T.unsafe(nil)); end

  def match(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def print(*args, &block); end

  def processor(); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::Command
  extend ::Forwardable
  extend ::Byebug::Helpers::StringHelper
  def self.allow_in_control(); end

  def self.allow_in_control=(allow_in_control); end

  def self.allow_in_post_mortem(); end

  def self.allow_in_post_mortem=(allow_in_post_mortem); end

  def self.always_run(); end

  def self.always_run=(always_run); end

  def self.columnize(width); end

  def self.help(); end

  def self.match(input); end
end

class Byebug::CommandList
  include ::Enumerable
  def each(&blk); end

  def initialize(commands); end

  def match(input); end
end

class Byebug::CommandList
end

class Byebug::CommandNotFound
  def initialize(input, parent=T.unsafe(nil)); end
end

class Byebug::CommandNotFound
end

class Byebug::CommandProcessor
  include ::Byebug::Helpers::EvalHelper
  def after_repl(); end

  def at_breakpoint(brkpt); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def before_repl(); end

  def command_list(); end

  def commands(*args, &block); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(*args, &block); end

  def initialize(context, interface=T.unsafe(nil)); end

  def interface(); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def prev_line(); end

  def prev_line=(prev_line); end

  def printer(); end

  def proceed!(); end

  def process_commands(); end

  def prompt(); end

  def prv(*args, &block); end

  def puts(*args, &block); end

  def repl(); end
end

class Byebug::CommandProcessor
  extend ::Forwardable
end

class Byebug::ConditionCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ConditionCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Context
  include ::Byebug::Helpers::FileHelper
  def at_breakpoint(breakpoint); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def backtrace(); end

  def dead?(); end

  def file(*args, &block); end

  def frame(); end

  def frame=(pos); end

  def frame_binding(*_); end

  def frame_class(*_); end

  def frame_file(*_); end

  def frame_line(*_); end

  def frame_method(*_); end

  def frame_self(*_); end

  def full_location(); end

  def ignored?(); end

  def interrupt(); end

  def line(*args, &block); end

  def location(); end

  def resume(); end

  def stack_size(); end

  def step_into(*_); end

  def step_out(*_); end

  def step_over(*_); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
  extend ::Forwardable
  def self.ignored_files(); end

  def self.ignored_files=(ignored_files); end

  def self.interface(); end

  def self.interface=(interface); end

  def self.processor(); end

  def self.processor=(processor); end
end

class Byebug::ContinueCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ContinueCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ControlProcessor
  def commands(); end
end

class Byebug::ControlProcessor
end

class Byebug::DebugCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DebugCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
  def self.inherited(); end
end

class Byebug::DeleteCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DeleteCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  include ::Byebug::Subcommands
end

class Byebug::DisableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisplayCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DownCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DownCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EditCommand
  def execute(); end
end

class Byebug::EditCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  include ::Byebug::Subcommands
end

class Byebug::EnableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FinishCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FinishCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Frame
  include ::Byebug::Helpers::FileHelper
  def _binding(); end

  def _class(); end

  def _method(); end

  def _self(); end

  def args(); end

  def c_frame?(); end

  def current?(); end

  def deco_args(); end

  def deco_block(); end

  def deco_call(); end

  def deco_class(); end

  def deco_file(); end

  def deco_method(); end

  def deco_pos(); end

  def file(); end

  def initialize(context, pos); end

  def line(); end

  def locals(); end

  def mark(); end

  def pos(); end

  def to_hash(); end
end

class Byebug::Frame
end

class Byebug::FrameCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FrameCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FullpathSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::FullpathSetting
end

class Byebug::HelpCommand
  def execute(); end
end

class Byebug::HelpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Helpers
end

module Byebug::Helpers::BinHelper
  def executable_file_extensions(); end

  def find_executable(path, cmd); end

  def real_executable?(file); end

  def search_paths(); end

  def which(cmd); end
end

module Byebug::Helpers::BinHelper
end

module Byebug::Helpers::EvalHelper
  def error_eval(str, binding=T.unsafe(nil)); end

  def multiple_thread_eval(expression); end

  def separate_thread_eval(expression); end

  def silent_eval(str, binding=T.unsafe(nil)); end

  def warning_eval(str, binding=T.unsafe(nil)); end
end

module Byebug::Helpers::EvalHelper
end

module Byebug::Helpers::FileHelper
  def get_line(filename, lineno); end

  def get_lines(filename); end

  def n_lines(filename); end

  def normalize(filename); end

  def shortpath(fullpath); end

  def virtual_file?(name); end
end

module Byebug::Helpers::FileHelper
end

module Byebug::Helpers::FrameHelper
  def jump_frames(steps); end

  def switch_to_frame(frame); end
end

module Byebug::Helpers::FrameHelper
end

module Byebug::Helpers::ParseHelper
  def get_int(str, cmd, min=T.unsafe(nil), max=T.unsafe(nil)); end

  def parse_steps(str, cmd); end

  def syntax_valid?(code); end
end

module Byebug::Helpers::ParseHelper
end

module Byebug::Helpers::PathHelper
  def all_files(); end

  def bin_file(); end

  def gem_files(); end

  def lib_files(); end

  def root_path(); end

  def test_files(); end
end

module Byebug::Helpers::PathHelper
end

module Byebug::Helpers::ReflectionHelper
  def commands(); end
end

module Byebug::Helpers::ReflectionHelper
end

module Byebug::Helpers::StringHelper
  def camelize(str); end

  def deindent(str, leading_spaces: T.unsafe(nil)); end

  def prettify(str); end
end

module Byebug::Helpers::StringHelper
end

module Byebug::Helpers::ThreadHelper
  def context_from_thread(thnum); end

  def current_thread?(ctx); end

  def display_context(ctx); end

  def thread_arguments(ctx); end
end

module Byebug::Helpers::ThreadHelper
end

module Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def enable_disable_breakpoints(is_enable, args); end

  def enable_disable_display(is_enable, args); end
end

module Byebug::Helpers::ToggleHelper
end

module Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def var_args(); end

  def var_global(); end

  def var_instance(str); end

  def var_list(ary, binding=T.unsafe(nil)); end

  def var_local(); end
end

module Byebug::Helpers::VarHelper
end

module Byebug::Helpers
end

class Byebug::HistfileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
end

class Byebug::History
  def buffer(); end

  def clear(); end

  def default_max_size(); end

  def ignore?(buf); end

  def last_ids(number); end

  def pop(); end

  def push(cmd); end

  def restore(); end

  def save(); end

  def size(); end

  def size=(size); end

  def specific_max_size(number); end

  def to_s(n_cmds); end
end

class Byebug::History
end

class Byebug::HistoryCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::HistoryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::HistsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
end

class Byebug::InfoCommand
  include ::Byebug::Subcommands
end

class Byebug::InfoCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::InfoCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::DisplayCommand
  def execute(); end
end

class Byebug::InfoCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::FileCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::StringHelper
  def execute(); end
end

class Byebug::InfoCommand::FileCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::LineCommand
  def execute(); end
end

class Byebug::InfoCommand::LineCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::ProgramCommand
  def execute(); end
end

class Byebug::InfoCommand::ProgramCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Interface
  include ::Byebug::Helpers::FileHelper
  def autorestore(); end

  def autosave(); end

  def close(); end

  def command_queue(); end

  def command_queue=(command_queue); end

  def confirm(prompt); end

  def errmsg(message); end

  def error(); end

  def history(); end

  def history=(history); end

  def input(); end

  def last_if_empty(input); end

  def output(); end

  def prepare_input(prompt); end

  def print(message); end

  def puts(message); end

  def read_command(prompt); end

  def read_file(filename); end

  def read_input(prompt, save_hist=T.unsafe(nil)); end
end

class Byebug::Interface
end

class Byebug::InterruptCommand
  def execute(); end
end

class Byebug::InterruptCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::IrbCommand
  def execute(); end
end

class Byebug::IrbCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::KillCommand
  def execute(); end
end

class Byebug::KillCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::LinetraceSetting
  def banner(); end

  def value=(val); end
end

class Byebug::LinetraceSetting
end

class Byebug::ListCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def amend_final(*args, &block); end

  def execute(); end

  def max_line(*args, &block); end

  def size(*args, &block); end
end

class Byebug::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ListsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
end

class Byebug::LocalInterface
  def readline(prompt); end

  def with_repl_like_sigint(); end
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
end

class Byebug::MethodCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::MethodCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::NextCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::NextCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PostMortemProcessor
  def commands(); end
end

class Byebug::PostMortemProcessor
end

class Byebug::PostMortemSetting
  def banner(); end

  def value=(val); end
end

class Byebug::PostMortemSetting
end

module Byebug::Printers
end

class Byebug::Printers::Base
  def type(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base
end

class Byebug::Printers::Plain
  def print(path, args=T.unsafe(nil)); end

  def print_collection(path, collection, &block); end

  def print_variables(variables, *_unused); end
end

class Byebug::Printers::Plain
end

module Byebug::Printers
end

class Byebug::PryCommand
  def execute(); end
end

class Byebug::PryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::QuitCommand
  def execute(); end
end

class Byebug::QuitCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Remote
end

class Byebug::Remote::Client
  def initialize(interface); end

  def interface(); end

  def socket(); end

  def start(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def started?(); end
end

class Byebug::Remote::Client
end

class Byebug::Remote::Server
  def actual_port(); end

  def initialize(wait_connection:, &block); end

  def start(host, port); end

  def wait_connection(); end
end

class Byebug::Remote::Server
end

module Byebug::Remote
end

class Byebug::RemoteInterface
  def initialize(socket); end

  def readline(prompt); end
end

class Byebug::RemoteInterface
end

class Byebug::RestartCommand
  include ::Byebug::Helpers::BinHelper
  include ::Byebug::Helpers::PathHelper
  def execute(); end
end

class Byebug::RestartCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SaveCommand
  def execute(); end
end

class Byebug::SaveCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SavefileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
end

class Byebug::ScriptInterface
  def initialize(file, verbose=T.unsafe(nil)); end
end

class Byebug::ScriptInterface
end

class Byebug::ScriptProcessor
  def commands(); end
end

class Byebug::ScriptProcessor
end

class Byebug::SetCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::SetCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Setting
  def boolean?(); end

  def help(); end

  def integer?(); end

  def to_sym(); end

  def value(); end

  def value=(value); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  def self.[](name); end

  def self.[]=(name, value); end

  def self.find(shortcut); end

  def self.help_all(); end

  def self.settings(); end
end

class Byebug::ShowCommand
  def execute(); end
end

class Byebug::ShowCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SkipCommand
  include ::Byebug::Helpers::ParseHelper
  def auto_run(); end

  def execute(); end

  def initialize_attributes(); end

  def keep_execution(); end

  def reset_attributes(); end
end

class Byebug::SkipCommand
  def self.description(); end

  def self.file_line(); end

  def self.file_line=(file_line); end

  def self.file_path(); end

  def self.file_path=(file_path); end

  def self.previous_autolist(); end

  def self.regexp(); end

  def self.restore_autolist(); end

  def self.setup_autolist(value); end

  def self.short_description(); end
end

class Byebug::SourceCommand
  def execute(); end
end

class Byebug::SourceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SourceFileFormatter
  include ::Byebug::Helpers::FileHelper
  def amend(line, ceiling); end

  def amend_final(line); end

  def amend_initial(line); end

  def annotator(); end

  def file(); end

  def initialize(file, annotator); end

  def lines(min, max); end

  def lines_around(center); end

  def max_initial_line(); end

  def max_line(); end

  def range_around(center); end

  def range_from(min); end

  def size(); end
end

class Byebug::SourceFileFormatter
end

class Byebug::StackOnErrorSetting
  def banner(); end
end

class Byebug::StackOnErrorSetting
end

class Byebug::StepCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::StepCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Subcommands
  def execute(); end

  def subcommand_list(*args, &block); end
end

module Byebug::Subcommands::ClassMethods
  include ::Byebug::Helpers::ReflectionHelper
  def help(); end

  def subcommand_list(); end
end

module Byebug::Subcommands::ClassMethods
end

module Byebug::Subcommands
  extend ::Forwardable
  def self.included(command); end
end

class Byebug::ThreadCommand
  include ::Byebug::Subcommands
end

class Byebug::ThreadCommand::CurrentCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::CurrentCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ListCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ResumeCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::StopCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::StopCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::SwitchCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::TracevarCommand
  def execute(); end
end

class Byebug::TracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UndisplayCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UndisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UntracevarCommand
  def execute(); end
end

class Byebug::UntracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UpCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  include ::Byebug::Subcommands
end

class Byebug::VarCommand::AllCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::AllCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ArgsCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ArgsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ConstCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ConstCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::GlobalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::GlobalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::InstanceCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::InstanceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::LocalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::LocalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WhereCommand
  include ::Byebug::Helpers::FrameHelper
  def execute(); end
end

class Byebug::WhereCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WidthSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::WidthSetting
end

module Byebug
  extend ::Byebug
  extend ::Byebug::Helpers::ReflectionHelper
  def self.actual_control_port(); end

  def self.actual_port(); end

  def self.attach(); end

  def self.handle_post_mortem(); end

  def self.interrupt(); end

  def self.load_settings(); end

  def self.parse_host_and_port(host_port_spec); end

  def self.spawn(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_client(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_control(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_server(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.wait_connection(); end

  def self.wait_connection=(wait_connection); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  include ::Mocha::ClassMethods
  def class_attribute(*attrs, instance_accessor: T.unsafe(nil), instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_predicate: T.unsafe(nil), default: T.unsafe(nil)); end

  def descendants(); end

  def json_creatable?(); end

  def subclasses(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*_); end
end

module CodeRay::Encoders
end

class CodeRay::Encoders::Encoder
  def <<(token); end

  def begin_group(kind); end

  def begin_line(kind); end

  def compile(tokens, options=T.unsafe(nil)); end

  def encode(code, lang, options=T.unsafe(nil)); end

  def encode_tokens(tokens, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def file_extension(); end

  def finish(options); end

  def get_output(options); end

  def highlight(code, lang, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output(data); end

  def scanner(); end

  def scanner=(scanner); end

  def setup(options); end

  def text_token(text, kind); end

  def token(content, kind); end

  def tokens(tokens, options=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Encoder
  extend ::CodeRay::Plugin
  def self.const_missing(sym); end

  def self.file_extension(); end
end

class CodeRay::Encoders::HTML
  def break_lines(text, style); end

  def check_group_nesting(name, kind); end

  def check_options!(options); end

  def close_span(); end

  def css(); end

  def css_class_for_kinds(kinds); end

  def make_span_for_kinds(method, hint); end

  def style_for_kinds(kinds); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_EXTENSION = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
  TOKEN_KIND_TO_INFO = ::T.let(nil, ::T.untyped)
  TRANSPARENT_TOKEN_KINDS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def get_style_for_css_classes(css_classes); end

  def initialize(style=T.unsafe(nil)); end

  def stylesheet(); end
  CSS_CLASS_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def self.load_stylesheet(style=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Numbering
end

module CodeRay::Encoders::HTML::Numbering
  def self.number!(output, mode=T.unsafe(nil), options=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Output
  def apply_title!(title); end

  def css(); end

  def css=(css); end

  def stylesheet(in_tag=T.unsafe(nil)); end

  def wrap!(element, *args); end

  def wrap_in!(template); end

  def wrapped_in(); end

  def wrapped_in=(wrapped_in); end

  def wrapped_in?(element); end
  DIV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  SPAN = ::T.let(nil, ::T.untyped)
  TABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::Output::Template
  def apply(target, replacement); end
end

class CodeRay::Encoders::HTML::Output::Template
  def self.wrap!(str, template, target); end
end

module CodeRay::Encoders::HTML::Output
  def self.extended(o); end

  def self.make_stylesheet(css, in_tag=T.unsafe(nil)); end

  def self.page_template_for_css(css); end
end

class CodeRay::Encoders::HTML
  def self.make_html_escape_hash(); end

  def self.token_path_to_hint(hint, kinds); end
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
end

module CodeRay::Encoders
  extend ::CodeRay::PluginHost
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::Plugin
  def aliases(); end

  def plugin_host(host=T.unsafe(nil)); end

  def plugin_id(); end

  def register_for(id); end

  def title(title=T.unsafe(nil)); end
end

module CodeRay::Plugin
end

module CodeRay::PluginHost
  def [](id, *args, &blk); end

  def all_plugins(); end

  def const_missing(const); end

  def default(id=T.unsafe(nil)); end

  def list(); end

  def load(id, *args, &blk); end

  def load_all(); end

  def load_plugin_map(); end

  def make_plugin_hash(); end

  def map(hash); end

  def path_to(plugin_id); end

  def plugin_hash(); end

  def plugin_path(*args); end

  def register(plugin, id); end

  def validate_id(id); end
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

module CodeRay::PluginHost
  def self.extended(mod); end
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Java
  def scan_tokens(encoder, options); end
  CONSTANTS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MAGIC_VARIABLES = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  STRING_CONTENT_PATTERN = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
  List = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
end

class CodeRay::Scanners::Java
end

class CodeRay::Scanners::Ruby
  def interpreted_string_state(); end

  def scan_tokens(encoder, options); end
end

module CodeRay::Scanners::Ruby::Patterns
  BINARY = ::T.let(nil, ::T.untyped)
  CHARACTER = ::T.let(nil, ::T.untyped)
  CLASS_VARIABLE = ::T.let(nil, ::T.untyped)
  CONTROL_META_ESCAPE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FANCY_STRING_INTERPRETED = ::T.let(nil, ::T.untyped)
  FANCY_STRING_KIND = ::T.let(nil, ::T.untyped)
  FANCY_STRING_START = ::T.let(nil, ::T.untyped)
  FLOAT_OR_INT = ::T.let(nil, ::T.untyped)
  FLOAT_SUFFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_VARIABLE = ::T.let(nil, ::T.untyped)
  HEREDOC_OPEN = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_EXPECTING_VALUE = ::T.let(nil, ::T.untyped)
  KEYWORD_NEW_STATE = ::T.let(nil, ::T.untyped)
  METHOD_AFTER_DOT = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME_EX = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OPERATOR = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OR_SYMBOL = ::T.let(nil, ::T.untyped)
  METHOD_SUFFIX = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  OBJECT_VARIABLE = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
  PREDEFINED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREFIX_VARIABLE = ::T.let(nil, ::T.untyped)
  QUOTE_TO_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP_MODIFIERS = ::T.let(nil, ::T.untyped)
  RUBYDOC = ::T.let(nil, ::T.untyped)
  RUBYDOC_OR_DATA = ::T.let(nil, ::T.untyped)
  SIMPLE_ESCAPE = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  VALUE_FOLLOWS = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Ruby::Patterns
end

class CodeRay::Scanners::Ruby::StringState
  def heredoc_pattern(delim, interpreted, indented); end

  def initialize(kind, interpreted, delim, heredoc=T.unsafe(nil)); end
  CLOSING_PAREN = ::T.let(nil, ::T.untyped)
  STRING_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  def self.simple_key_pattern(delim); end
end

class CodeRay::Scanners::Ruby
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*_); end

  def to_s(); end

  def tokens(*_); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

class CodeRay::WordList
  def add(words, value=T.unsafe(nil)); end

  def initialize(default=T.unsafe(nil)); end
end

class CodeRay::WordList::CaseIgnoring
  def [](key); end

  def []=(key, value); end
end

class CodeRay::WordList::CaseIgnoring
end

class CodeRay::WordList
end

module CodeRay
  def self.coderay_path(*path); end

  def self.encode(code, lang, format, options=T.unsafe(nil)); end

  def self.encode_file(filename, format, options=T.unsafe(nil)); end

  def self.encode_tokens(tokens, format, options=T.unsafe(nil)); end

  def self.encoder(format, options=T.unsafe(nil)); end

  def self.get_scanner_options(options); end

  def self.highlight(code, lang, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.highlight_file(filename, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.scan(code, lang, options=T.unsafe(nil), &block); end

  def self.scan_file(filename, lang=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.scanner(lang, options=T.unsafe(nil), &block); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

class CompositeReadIO
  def initialize(*ios); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class CompositeReadIO
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExchanger
  def exchange(value, timeout=T.unsafe(nil)); end

  def exchange!(value, timeout=T.unsafe(nil)); end

  def try_exchange(value, timeout=T.unsafe(nil)); end
end

class Concurrent::AbstractExchanger
end

class Concurrent::AbstractExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Deprecation
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def auto_terminate=(value); end

  def auto_terminate?(); end

  def fallback_policy(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def kill(); end

  def name(); end

  def running?(); end

  def shutdown(); end

  def shutdown?(); end

  def shuttingdown?(); end

  def wait_for_termination(timeout=T.unsafe(nil)); end
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
end

class Concurrent::AbstractThreadLocalVar
  def allocate_storage(); end

  def bind(value, &block); end

  def default(); end

  def initialize(default=T.unsafe(nil), &default_block); end

  def value(); end

  def value=(value); end
end

class Concurrent::AbstractThreadLocalVar
end

class Concurrent::Agent
  include ::Concurrent::Concern::Observable
  def <<(action); end

  def await(); end

  def await_for(timeout); end

  def await_for!(timeout); end

  def deref(); end

  def error(); end

  def error_mode(); end

  def failed?(); end

  def initialize(initial, opts=T.unsafe(nil)); end

  def post(*args, &action); end

  def reason(); end

  def restart(new_value, opts=T.unsafe(nil)); end

  def send(*args, &action); end

  def send!(*args, &action); end

  def send_off(*args, &action); end

  def send_off!(*args, &action); end

  def send_via(executor, *args, &action); end

  def send_via!(executor, *args, &action); end

  def stopped?(); end

  def value(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
  def initialize(message=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent
  def self.await(*agents); end

  def self.await_for(timeout, *agents); end

  def self.await_for!(timeout, *agents); end
end

class Concurrent::Array
end

class Concurrent::Array
end

module Concurrent::Async
  def async(); end

  def await(); end

  def call(); end

  def cast(); end

  def init_synchronization(); end
end

module Concurrent::Async
  def self.included(base); end

  def self.validate_argc(obj, method, *args); end
end

class Concurrent::Atom
  include ::Concurrent::Concern::Observable
  def compare_and_set(old_value, new_value); end

  def deref(); end

  def initialize(value, opts=T.unsafe(nil)); end

  def reset(new_value); end

  def swap(*args); end

  def value(); end
end

class Concurrent::Atom
  def self.new(*args, &block); end
end

class Concurrent::AtomicBoolean
end

class Concurrent::AtomicBoolean
end

module Concurrent::AtomicDirectUpdate
  def try_update(); end

  def try_update!(); end

  def update(); end
end

module Concurrent::AtomicDirectUpdate
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicMarkableReference
  def compare_and_set(expected_val, new_val, expected_mark, new_mark); end

  def compare_and_swap(expected_val, new_val, expected_mark, new_mark); end

  def get(); end

  def initialize(value=T.unsafe(nil), mark=T.unsafe(nil)); end

  def mark(); end

  def marked?(); end

  def set(new_val, new_mark); end

  def try_update(); end

  def try_update!(); end

  def update(); end

  def value(); end
end

class Concurrent::AtomicMarkableReference
  def self.new(*args, &block); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
  def compare_and_set(old_value, new_value); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
end

class Concurrent::AtomicReference
end

class Concurrent::AtomicReference
end

class Concurrent::CachedThreadPool
end

class Concurrent::CachedThreadPool
end

class Concurrent::CancelledOperationError
end

class Concurrent::CancelledOperationError
end

module Concurrent::Collection
end

class Concurrent::Collection::CopyOnNotifyObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnNotifyObserverSet
end

class Concurrent::Collection::CopyOnWriteObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnWriteObserverSet
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::NonConcurrentMapBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
end

class Concurrent::Collection::NonConcurrentMapBackend
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def <<(item); end

  def clear(); end

  def delete(item); end

  def deq(); end

  def empty?(); end

  def enq(item); end

  def has_priority?(item); end

  def include?(item); end

  def initialize(opts=T.unsafe(nil)); end

  def length(); end

  def peek(); end

  def pop(); end

  def push(item); end

  def shift(); end

  def size(); end
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def self.from_list(list, opts=T.unsafe(nil)); end
end

module Concurrent::Collection
end

module Concurrent::Concern
end

module Concurrent::Concern::Deprecation
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def deprecated(message, strip=T.unsafe(nil)); end

  def deprecated_method(old_name, new_name); end
end

module Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
end

module Concurrent::Concern::Dereferenceable
  def apply_deref_options(value); end

  def deref(); end

  def ns_set_deref_options(opts); end

  def set_deref_options(opts=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
end

module Concurrent::Concern::Dereferenceable
end

module Concurrent::Concern::Logging
  include ::Logger::Severity
  def log(level, progname, message=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Logging
end

module Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def compare_and_set_state(next_state, *expected_current); end

  def complete?(); end

  def event(); end

  def exception(*args); end

  def fulfilled?(); end

  def get_arguments_from(opts=T.unsafe(nil)); end

  def if_state(*expected_states); end

  def incomplete?(); end

  def init_obligation(); end

  def no_error!(timeout=T.unsafe(nil)); end

  def ns_check_state?(expected); end

  def ns_set_state(value); end

  def pending?(); end

  def realized?(); end

  def reason(); end

  def rejected?(); end

  def set_state(success, value, reason); end

  def state(); end

  def state=(value); end

  def unscheduled?(); end

  def value(timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end
end

module Concurrent::Concern::Obligation
end

module Concurrent::Concern::Observable
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def observers(); end

  def observers=(observers); end

  def with_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Observable
end

module Concurrent::Concern
end

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::ConcurrentUpdateError
end

class Concurrent::ConfigurationError
end

class Concurrent::ConfigurationError
end

class Concurrent::CountDownLatch
end

class Concurrent::CountDownLatch
end

class Concurrent::CyclicBarrier
  def broken?(); end

  def initialize(parties, &block); end

  def ns_generation_done(generation, status, continue=T.unsafe(nil)); end

  def ns_initialize(parties, &block); end

  def ns_next_generation(); end

  def number_waiting(); end

  def parties(); end

  def reset(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::CyclicBarrier
end

class Concurrent::Delay
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def initialize(opts=T.unsafe(nil), &block); end

  def ns_initialize(opts, &block); end

  def reconfigure(&block); end
end

class Concurrent::Delay
end

class Concurrent::DependencyCounter
  def initialize(count, &block); end

  def update(time, value, reason); end
end

class Concurrent::DependencyCounter
end

class Concurrent::Error
end

class Concurrent::Error
end

class Concurrent::Event
  def initialize(); end

  def ns_initialize(); end

  def ns_set(); end

  def reset(); end

  def set(); end

  def set?(); end

  def try?(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Event
end

class Concurrent::Exchanger
end

class Concurrent::Exchanger
end

module Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def <<(task); end

  def can_overflow?(); end

  def post(*args, &task); end

  def serialized?(); end
end

module Concurrent::ExecutorService
end

class Concurrent::FixedThreadPool
  def initialize(num_threads, opts=T.unsafe(nil)); end
end

class Concurrent::FixedThreadPool
end

class Concurrent::Future
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def set(value=T.unsafe(nil), &block); end

  def wait_or_cancel(timeout); end
end

class Concurrent::Future
  def self.execute(opts=T.unsafe(nil), &block); end
end

class Concurrent::Hash
end

class Concurrent::Hash
end

class Concurrent::IVar
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def check_for_block_or_value!(block_given, value); end

  def complete(success, value, reason); end

  def complete_without_notification(success, value, reason); end

  def fail(reason=T.unsafe(nil)); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def notify_observers(value, reason); end

  def ns_complete_without_notification(success, value, reason); end

  def ns_initialize(value, opts); end

  def safe_execute(task, args=T.unsafe(nil)); end

  def set(value=T.unsafe(nil)); end

  def try_set(value=T.unsafe(nil), &block); end
end

class Concurrent::IVar
end

class Concurrent::IllegalOperationError
end

class Concurrent::IllegalOperationError
end

class Concurrent::ImmediateExecutor
  include ::Concurrent::SerialExecutorService
  def initialize(); end
end

class Concurrent::ImmediateExecutor
end

class Concurrent::ImmutabilityError
end

class Concurrent::ImmutabilityError
end

module Concurrent::ImmutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::ImmutableStruct
  def self.included(base); end

  def self.new(*args, &block); end
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::InitializationError
end

class Concurrent::InitializationError
end

class Concurrent::LifecycleError
end

class Concurrent::LifecycleError
end

class Concurrent::LockFreeStack
  include ::Enumerable
  def clear(); end

  def clear_each(&block); end

  def clear_if(head); end

  def compare_and_clear(head); end

  def compare_and_pop(head); end

  def compare_and_push(head, value); end

  def each(head=T.unsafe(nil), &blk); end

  def empty?(head=T.unsafe(nil)); end

  def initialize(head=T.unsafe(nil)); end

  def peek(); end

  def pop(); end

  def push(value); end

  def replace_if(head, new_head); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack::Node
  def initialize(value, next_node); end

  def next_node(); end

  def value(); end

  def value=(value); end
end

class Concurrent::LockFreeStack::Node
  def self.[](*_); end
end

class Concurrent::LockFreeStack
  def self.new(*args, &block); end

  def self.of1(value); end

  def self.of2(value1, value2); end
end

class Concurrent::MVar
  include ::Concurrent::Concern::Dereferenceable
  def borrow(timeout=T.unsafe(nil)); end

  def empty?(); end

  def full?(); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil)); end

  def modify(timeout=T.unsafe(nil)); end

  def modify!(); end

  def put(value, timeout=T.unsafe(nil)); end

  def set!(value); end

  def synchronize(&block); end

  def take(timeout=T.unsafe(nil)); end

  def try_put!(value); end

  def try_take!(); end
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  def self.new(*args, &block); end
end

class Concurrent::Map
  def each(&blk); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def value?(value); end

  def values(); end
end

class Concurrent::Map
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::Maybe
  include ::Comparable
  def fulfilled?(); end

  def initialize(just, nothing); end

  def just(); end

  def just?(); end

  def nothing(); end

  def nothing?(); end

  def or(other); end

  def reason(); end

  def rejected?(); end

  def value(); end
  NONE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  def self.from(*args); end

  def self.just(value); end

  def self.nothing(error=T.unsafe(nil)); end
end

class Concurrent::MultipleAssignmentError
  def initialize(message=T.unsafe(nil), inspection_data=T.unsafe(nil)); end

  def inspection_data(); end
end

class Concurrent::MultipleAssignmentError
end

class Concurrent::MultipleErrors
  def errors(); end

  def initialize(errors, message=T.unsafe(nil)); end
end

class Concurrent::MultipleErrors
end

module Concurrent::MutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::MutableStruct
  def self.new(*args, &block); end
end

class Concurrent::MutexAtomicBoolean
  def false?(); end

  def initialize(initial=T.unsafe(nil)); end

  def make_false(); end

  def make_true(); end

  def ns_initialize(initial); end

  def true?(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicBoolean
end

class Concurrent::MutexAtomicFixnum
  def compare_and_set(expect, update); end

  def decrement(delta=T.unsafe(nil)); end

  def down(delta=T.unsafe(nil)); end

  def increment(delta=T.unsafe(nil)); end

  def initialize(initial=T.unsafe(nil)); end

  def ns_initialize(initial); end

  def up(delta=T.unsafe(nil)); end

  def update(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicFixnum
end

class Concurrent::MutexAtomicReference
  include ::Concurrent::AtomicDirectUpdate
  include ::Concurrent::AtomicNumericCompareAndSetWrapper
  def _compare_and_set(old_value, new_value); end

  def compare_and_swap(old_value, new_value); end

  def get(); end

  def get_and_set(new_value); end

  def initialize(value=T.unsafe(nil)); end

  def ns_initialize(value); end

  def set(new_value); end

  def swap(new_value); end

  def value(); end

  def value=(new_value); end
end

class Concurrent::MutexAtomicReference
end

class Concurrent::MutexCountDownLatch
  def count(); end

  def count_down(); end

  def initialize(count=T.unsafe(nil)); end

  def ns_initialize(count); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::MutexCountDownLatch
end

class Concurrent::MutexSemaphore
  def acquire(permits=T.unsafe(nil)); end

  def available_permits(); end

  def drain_permits(); end

  def initialize(count); end

  def ns_initialize(count); end

  def reduce_permits(reduction); end

  def release(permits=T.unsafe(nil)); end

  def try_acquire(permits=T.unsafe(nil), timeout=T.unsafe(nil)); end
end

class Concurrent::MutexSemaphore
end

module Concurrent::Options
end

module Concurrent::Options
  def self.executor(executor_identifier); end

  def self.executor_from_options(opts=T.unsafe(nil)); end
end

class Concurrent::Promise
  def catch(&block); end

  def execute(); end

  def flat_map(&block); end

  def initialize(opts=T.unsafe(nil), &block); end

  def notify_child(child); end

  def on_error(&block); end

  def on_fulfill(result); end

  def on_reject(reason); end

  def on_success(&block); end

  def realize(task); end

  def rescue(&block); end

  def root?(); end

  def set(value=T.unsafe(nil), &block); end

  def set_pending(); end

  def set_state!(success, value, reason); end

  def synchronized_set_state!(success, value, reason); end

  def then(*args, &block); end

  def zip(*others); end
end

class Concurrent::Promise
  def self.aggregate(method, *promises); end

  def self.all?(*promises); end

  def self.any?(*promises); end

  def self.execute(opts=T.unsafe(nil), &block); end

  def self.fulfill(value, opts=T.unsafe(nil)); end

  def self.reject(reason, opts=T.unsafe(nil)); end

  def self.zip(*promises); end
end

class Concurrent::PromiseExecutionError
end

class Concurrent::PromiseExecutionError
end

module Concurrent::Promises
end

class Concurrent::Promises::AbstractEventFuture
  include ::Concurrent::Promises::InternalStates
  def add_callback_clear_delayed_node(node); end

  def add_callback_notify_blocked(promise, index); end

  def blocks(); end

  def callbacks(); end

  def chain(*args, &task); end

  def chain_on(executor, *args, &task); end

  def chain_resolvable(resolvable); end

  def default_executor(); end

  def initialize(promise, default_executor); end

  def internal_state(); end

  def on_resolution(*args, &callback); end

  def on_resolution!(*args, &callback); end

  def on_resolution_using(executor, *args, &callback); end

  def pending?(); end

  def promise(); end

  def resolve_with(state, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolved?(); end

  def state(); end

  def tangle(resolvable); end

  def touch(); end

  def touched?(); end

  def wait(timeout=T.unsafe(nil)); end

  def waiting_threads(); end

  def with_default_executor(executor); end

  def with_hidden_resolvable(); end
end

class Concurrent::Promises::AbstractEventFuture
  def self.new(*args, &block); end
end

class Concurrent::Promises::Event
  def &(other); end

  def any(event_or_future); end

  def delay(); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def to_event(); end

  def to_future(); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Event
end

module Concurrent::Promises::FactoryMethods
  include ::Concurrent::Promises::FactoryMethods::Configuration
  def any(*futures_and_or_events); end

  def any_event(*futures_and_or_events); end

  def any_event_on(default_executor, *futures_and_or_events); end

  def any_fulfilled_future(*futures_and_or_events); end

  def any_fulfilled_future_on(default_executor, *futures_and_or_events); end

  def any_resolved_future(*futures_and_or_events); end

  def any_resolved_future_on(default_executor, *futures_and_or_events); end

  def delay(*args, &task); end

  def delay_on(default_executor, *args, &task); end

  def fulfilled_future(value, default_executor=T.unsafe(nil)); end

  def future(*args, &task); end

  def future_on(default_executor, *args, &task); end

  def make_future(argument=T.unsafe(nil), default_executor=T.unsafe(nil)); end

  def rejected_future(reason, default_executor=T.unsafe(nil)); end

  def resolvable_event(); end

  def resolvable_event_on(default_executor=T.unsafe(nil)); end

  def resolvable_future(); end

  def resolvable_future_on(default_executor=T.unsafe(nil)); end

  def resolved_event(default_executor=T.unsafe(nil)); end

  def resolved_future(fulfilled, value, reason, default_executor=T.unsafe(nil)); end

  def schedule(intended_time, *args, &task); end

  def schedule_on(default_executor, intended_time, *args, &task); end

  def zip(*futures_and_or_events); end

  def zip_events(*futures_and_or_events); end

  def zip_events_on(default_executor, *futures_and_or_events); end

  def zip_futures(*futures_and_or_events); end

  def zip_futures_on(default_executor, *futures_and_or_events); end
end

module Concurrent::Promises::FactoryMethods::Configuration
  def default_executor(); end
end

module Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::Promises::FactoryMethods
  extend ::Concurrent::ReInclude
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

class Concurrent::Promises::Future
  def &(other); end

  def any(event_or_future); end

  def apply(args, block); end

  def delay(); end

  def exception(*args); end

  def flat(level=T.unsafe(nil)); end

  def flat_event(); end

  def flat_future(level=T.unsafe(nil)); end

  def fulfilled?(); end

  def on_fulfillment(*args, &callback); end

  def on_fulfillment!(*args, &callback); end

  def on_fulfillment_using(executor, *args, &callback); end

  def on_rejection(*args, &callback); end

  def on_rejection!(*args, &callback); end

  def on_rejection_using(executor, *args, &callback); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def rejected?(); end

  def rescue(*args, &task); end

  def rescue_on(executor, *args, &task); end

  def result(timeout=T.unsafe(nil)); end

  def run(run_test=T.unsafe(nil)); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def then_on(executor, *args, &task); end

  def to_event(); end

  def to_future(); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Future
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
  include ::Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
end

class Concurrent::Promises::ResolvableEvent
  include ::Concurrent::Promises::Resolvable
  def resolve(raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableEvent
end

class Concurrent::Promises::ResolvableFuture
  include ::Concurrent::Promises::Resolvable
  def evaluate_to(*args, &block); end

  def evaluate_to!(*args, &block); end

  def fulfill(value, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def reject(reason, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolve(fulfilled=T.unsafe(nil), value=T.unsafe(nil), reason=T.unsafe(nil), raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def result(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableFuture
end

module Concurrent::Promises
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::ReInclude
  def extended(base); end

  def include(*modules); end

  def included(base); end
end

module Concurrent::ReInclude
end

class Concurrent::ReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def has_waiters?(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end

  def write_locked?(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::ReentrantReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def try_read_lock(); end

  def try_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::RejectedExecutionError
end

class Concurrent::RejectedExecutionError
end

class Concurrent::ResourceLimitError
end

class Concurrent::ResourceLimitError
end

class Concurrent::RubyExchanger
  def compare_and_set_slot(expected, value); end

  def slot(); end

  def slot=(value); end

  def swap_slot(value); end

  def update_slot(&block); end
end

class Concurrent::RubyExchanger
  def self.new(*args, &block); end
end

class Concurrent::RubyExecutorService
  def initialize(*args, &block); end
end

class Concurrent::RubyExecutorService
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubyThreadLocalVar
end

class Concurrent::RubyThreadLocalVar
  def self.thread_finalizer(id); end

  def self.thread_local_finalizer(index); end
end

class Concurrent::RubyThreadPoolExecutor
  def completed_task_count(); end

  def idletime(); end

  def initialize(opts=T.unsafe(nil)); end

  def largest_length(); end

  def length(); end

  def max_length(); end

  def max_queue(); end

  def min_length(); end

  def queue_length(); end

  def ready_worker(worker); end

  def remaining_capacity(); end

  def remove_busy_worker(worker); end

  def scheduled_task_count(); end

  def worker_died(worker); end

  def worker_not_old_enough(worker); end

  def worker_task_completed(); end
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
end

class Concurrent::SafeTaskExecutor
  def execute(*args); end

  def initialize(task, opts=T.unsafe(nil)); end
end

class Concurrent::SafeTaskExecutor
end

class Concurrent::ScheduledTask
  include ::Comparable
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def executor(); end

  def initial_delay(); end

  def initialize(delay, opts=T.unsafe(nil), &task); end

  def ns_reschedule(delay); end

  def ns_schedule(delay); end

  def process_task(); end

  def processing?(); end

  def reschedule(delay); end

  def reset(); end

  def schedule_time(); end
end

class Concurrent::ScheduledTask
  def self.execute(delay, opts=T.unsafe(nil), &task); end
end

class Concurrent::Semaphore
end

class Concurrent::Semaphore
end

module Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def serialized?(); end
end

module Concurrent::SerialExecutorService
end

class Concurrent::SerializedExecution
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(); end

  def post(executor, *args, &task); end

  def posts(posts); end
end

class Concurrent::SerializedExecution::Job
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def call(); end

  def executor(); end

  def executor=(_); end
end

class Concurrent::SerializedExecution::Job
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::SerializedExecution
end

class Concurrent::SerializedExecutionDelegator
  include ::Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(executor); end
end

class Concurrent::SerializedExecutionDelegator
end

class Concurrent::Set
end

class Concurrent::Set
end

module Concurrent::SettableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::SettableStruct
  def self.new(*args, &block); end
end

class Concurrent::SimpleExecutorService
end

class Concurrent::SimpleExecutorService
  def self.<<(task); end

  def self.post(*args); end
end

class Concurrent::SingleThreadExecutor
end

class Concurrent::SingleThreadExecutor
end

module Concurrent::Synchronization
end

class Concurrent::Synchronization::AbstractLockableObject
  def ns_broadcast(); end

  def ns_signal(); end

  def ns_wait(timeout=T.unsafe(nil)); end

  def ns_wait_until(timeout=T.unsafe(nil), &condition); end

  def synchronize(); end
end

class Concurrent::Synchronization::AbstractLockableObject
end

class Concurrent::Synchronization::AbstractObject
  def full_memory_barrier(); end
end

class Concurrent::Synchronization::AbstractObject
  def self.attr_volatile(*names); end
end

module Concurrent::Synchronization::AbstractStruct
  def initialize(*values); end

  def length(); end

  def members(); end

  def ns_each(); end

  def ns_each_pair(); end

  def ns_equality(other); end

  def ns_get(member); end

  def ns_initialize_copy(); end

  def ns_inspect(); end

  def ns_merge(other, &block); end

  def ns_select(); end

  def ns_to_h(); end

  def ns_values(); end

  def ns_values_at(indexes); end

  def pr_underscore(clazz); end

  def size(); end
end

module Concurrent::Synchronization::AbstractStruct
  def self.define_struct_class(parent, base, name, members, &block); end
end

class Concurrent::Synchronization::Condition
  def broadcast(); end

  def initialize(lock); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Condition
  def self.private_new(*args, &block); end
end

module Concurrent::Synchronization::ConditionSignalling
  def ns_broadcast(); end

  def ns_signal(); end
end

module Concurrent::Synchronization::ConditionSignalling
end

class Concurrent::Synchronization::Lock
  def broadcast(); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Lock
end

class Concurrent::Synchronization::LockableObject
  def new_condition(); end
end

class Concurrent::Synchronization::LockableObject
end

class Concurrent::Synchronization::MonitorLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MonitorLockableObject
  def self.new(*args, &block); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::MriObject
  include ::Concurrent::Synchronization::MriAttrVolatile
end

class Concurrent::Synchronization::MriObject
end

class Concurrent::Synchronization::MutexLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MutexLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::Object
end

class Concurrent::Synchronization::Object
  def self.atomic_attribute?(name); end

  def self.atomic_attributes(inherited=T.unsafe(nil)); end

  def self.attr_atomic(*names); end

  def self.ensure_safe_initialization_when_final_fields_are_present(); end

  def self.safe_initialization!(); end

  def self.safe_initialization?(); end
end

module Concurrent::Synchronization::RbxAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::RbxAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::RbxLockableObject
  def initialize(*defaults); end

  def synchronize(&block); end
end

class Concurrent::Synchronization::RbxLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::RbxObject
  include ::Concurrent::Synchronization::RbxAttrVolatile
end

class Concurrent::Synchronization::RbxObject
  extend ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def self.included(base); end
end

class Concurrent::Synchronization::TruffleRubyObject
  include ::Concurrent::Synchronization::TruffleRubyAttrVolatile
end

class Concurrent::Synchronization::TruffleRubyObject
  extend ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

module Concurrent::Synchronization
end

class Concurrent::SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
end

class Concurrent::SynchronizedDelegator
end

class Concurrent::TVar
  def initialize(value); end

  def unsafe_increment_version(); end

  def unsafe_lock(); end

  def unsafe_value(); end

  def unsafe_value=(value); end

  def unsafe_version(); end

  def value(); end

  def value=(value); end
end

class Concurrent::TVar
  def self.new(*args, &block); end
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadPoolExecutor
end

class Concurrent::ThreadPoolExecutor
end

module Concurrent::ThreadSafe
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
end

module Concurrent::ThreadSafe
end

class Concurrent::TimeoutError
end

class Concurrent::TimeoutError
end

class Concurrent::TimerSet
  def initialize(opts=T.unsafe(nil)); end

  def post(delay, *args, &task); end
end

class Concurrent::TimerSet
end

class Concurrent::TimerTask
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def execute(); end

  def execution_interval(); end

  def execution_interval=(value); end

  def initialize(opts=T.unsafe(nil), &task); end

  def timeout_interval(); end

  def timeout_interval=(value); end
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  def self.execute(opts=T.unsafe(nil), &task); end
end

class Concurrent::Transaction
  def abort(); end

  def commit(); end

  def read(tvar); end

  def unlock(); end

  def valid?(); end

  def write(tvar, value); end
  ABORTED = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::ReadLogEntry
  def tvar(); end

  def tvar=(_); end

  def version(); end

  def version=(_); end
end

class Concurrent::Transaction::ReadLogEntry
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::Transaction
  def self.current(); end

  def self.current=(transaction); end
end

class Concurrent::Tuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def get(i); end

  def initialize(size); end

  def set(i, value); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class Concurrent::Tuple
end

module Concurrent::Utility
end

module Concurrent::Utility::EngineDetector
  def on_cruby?(); end

  def on_jruby?(); end

  def on_jruby_9000?(); end

  def on_linux?(); end

  def on_osx?(); end

  def on_rbx?(); end

  def on_truffleruby?(); end

  def on_windows?(); end

  def ruby_engine(); end

  def ruby_version(version=T.unsafe(nil), comparison, major, minor, patch); end
end

module Concurrent::Utility::EngineDetector
end

module Concurrent::Utility::NativeExtensionLoader
  def allow_c_extensions?(); end

  def c_extensions_loaded?(); end

  def java_extensions_loaded?(); end

  def load_native_extensions(); end
end

module Concurrent::Utility::NativeExtensionLoader
end

module Concurrent::Utility::NativeInteger
  def ensure_integer(value); end

  def ensure_integer_and_bounds(value); end

  def ensure_lower_bound(value); end

  def ensure_positive(value); end

  def ensure_positive_and_no_zero(value); end

  def ensure_upper_bound(value); end
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  extend ::Concurrent::Utility::NativeInteger
end

class Concurrent::Utility::ProcessorCounter
  def physical_processor_count(); end

  def processor_count(); end
end

class Concurrent::Utility::ProcessorCounter
end

module Concurrent::Utility
end

module Concurrent
  extend ::Concurrent::Utility::EngineDetector
  extend ::Concurrent::Utility::NativeExtensionLoader
  extend ::Concurrent::Concern::Deprecation
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
  def self.abort_transaction(); end

  def self.atomically(); end

  def self.call_dataflow(method, executor, *inputs, &block); end

  def self.create_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.create_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.dataflow(*inputs, &block); end

  def self.dataflow!(*inputs, &block); end

  def self.dataflow_with(executor, *inputs, &block); end

  def self.dataflow_with!(executor, *inputs, &block); end

  def self.disable_at_exit_handlers!(); end

  def self.executor(executor_identifier); end

  def self.global_fast_executor(); end

  def self.global_immediate_executor(); end

  def self.global_io_executor(); end

  def self.global_logger(); end

  def self.global_logger=(value); end

  def self.global_timer_set(); end

  def self.leave_transaction(); end

  def self.monotonic_time(); end

  def self.new_fast_executor(opts=T.unsafe(nil)); end

  def self.new_io_executor(opts=T.unsafe(nil)); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.processor_counter(); end

  def self.use_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.use_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end
end

module Crack
end

class Crack::JSON
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

class Crack::JSON
  def self.convert_json_to_yaml(json); end

  def self.format_dates(output, date_starts, date_ends); end

  def self.parse(json); end

  def self.parser_exceptions(); end

  def self.unescape(str); end
end

class Crack::ParseError
end

class Crack::ParseError
end

class Crack::REXMLParser
end

class Crack::REXMLParser
  def self.parse(xml); end
end

module Crack::Util
  def snake_case(str); end

  def to_xml_attributes(hash); end
end

module Crack::Util
  extend ::Crack::Util
end

class Crack::XML
end

class Crack::XML
  def self.parse(xml); end

  def self.parser(); end

  def self.parser=(parser); end
end

module Crack
end

module Crass
end

class Crass::Parser
  def consume_at_rule(input=T.unsafe(nil)); end

  def consume_component_value(input=T.unsafe(nil)); end

  def consume_declaration(input=T.unsafe(nil)); end

  def consume_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def consume_function(input=T.unsafe(nil)); end

  def consume_qualified_rule(input=T.unsafe(nil)); end

  def consume_rules(flags=T.unsafe(nil)); end

  def consume_simple_block(input=T.unsafe(nil)); end

  def create_node(type, properties=T.unsafe(nil)); end

  def create_selector(input); end

  def create_style_rule(rule); end

  def initialize(input, options=T.unsafe(nil)); end

  def parse_component_value(input=T.unsafe(nil)); end

  def parse_component_values(input=T.unsafe(nil)); end

  def parse_declaration(input=T.unsafe(nil)); end

  def parse_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def parse_properties(input=T.unsafe(nil)); end

  def parse_rule(input=T.unsafe(nil)); end

  def parse_value(nodes); end

  def tokens(); end
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  def self.parse_properties(input, options=T.unsafe(nil)); end

  def self.parse_rules(input, options=T.unsafe(nil)); end

  def self.parse_stylesheet(input, options=T.unsafe(nil)); end

  def self.stringify(nodes, options=T.unsafe(nil)); end
end

class Crass::Scanner
  def consume(); end

  def consume_rest(); end

  def current(); end

  def eos?(); end

  def initialize(input); end

  def mark(); end

  def marked(); end

  def marker(); end

  def marker=(marker); end

  def peek(length=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def reconsume(); end

  def reset(); end

  def scan(pattern); end

  def scan_until(pattern); end

  def string(); end
end

class Crass::Scanner
end

class Crass::TokenScanner
  def collect(); end

  def consume(); end

  def current(); end

  def initialize(tokens); end

  def peek(); end

  def pos(); end

  def reconsume(); end

  def reset(); end

  def tokens(); end
end

class Crass::TokenScanner
end

class Crass::Tokenizer
  def consume(); end

  def consume_bad_url(); end

  def consume_comments(); end

  def consume_escaped(); end

  def consume_ident(); end

  def consume_name(); end

  def consume_number(); end

  def consume_numeric(); end

  def consume_string(ending=T.unsafe(nil)); end

  def consume_unicode_range(); end

  def consume_url(); end

  def convert_string_to_number(str); end

  def create_token(type, properties=T.unsafe(nil)); end

  def initialize(input, options=T.unsafe(nil)); end

  def preprocess(input); end

  def start_identifier?(text=T.unsafe(nil)); end

  def start_number?(text=T.unsafe(nil)); end

  def tokenize(); end

  def valid_escape?(text=T.unsafe(nil)); end
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  def self.tokenize(input, options=T.unsafe(nil)); end
end

module Crass
  def self.parse(input, options=T.unsafe(nil)); end

  def self.parse_properties(input, options=T.unsafe(nil)); end
end

module DRb
end

class DRb::DRbArray
  def _dump(lv); end

  def initialize(ary); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbBadScheme
end

class DRb::DRbBadScheme
end

class DRb::DRbBadURI
end

class DRb::DRbBadURI
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
  POOL_SIZE = ::T.let(nil, ::T.untyped)
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbConnError
end

class DRb::DRbConnError
end

class DRb::DRbError
end

class DRb::DRbError
end

class DRb::DRbIdConv
  def to_id(obj); end

  def to_obj(ref); end
end

class DRb::DRbIdConv
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbMessage
end

class DRb::DRbObject
  def ==(other); end

  def __drbref(); end

  def __drburi(); end

  def _dump(lv); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end

  def method_missing(msg_id, *a, &b); end

  def respond_to?(msg_id, priv=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self._load(s); end

  def self.new_with(uri, ref); end

  def self.new_with_uri(uri); end

  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
end

module DRb::DRbProtocol
  def self.add_protocol(prot); end

  def self.auto_load(uri); end

  def self.open(uri, config, first=T.unsafe(nil)); end

  def self.open_server(uri, config, first=T.unsafe(nil)); end

  def self.uri_option(uri, config, first=T.unsafe(nil)); end
end

class DRb::DRbRemoteError
  def initialize(error); end

  def reason(); end
end

class DRb::DRbRemoteError
end

class DRb::DRbServer
  def alive?(); end

  def check_insecure_method(obj, msg_id); end

  def config(); end

  def front(); end

  def here?(uri); end

  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end

  def stop_service(); end

  def thread(); end

  def to_id(obj); end

  def to_obj(ref); end

  def uri(); end

  def verbose(); end

  def verbose=(v); end
  INSECURE_METHOD = ::T.let(nil, ::T.untyped)
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_acl(acl); end

  def self.default_argc_limit(argc); end

  def self.default_id_conv(idconv); end

  def self.default_load_limit(sz); end

  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end

  def self.verbose(); end

  def self.verbose=(on); end
end

class DRb::DRbServerNotFound
end

class DRb::DRbServerNotFound
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket
  def initialize(uri, soc, config=T.unsafe(nil), server_mode=T.unsafe(nil)); end
  Max_try = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def self.temp_server(); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

module DRb::DRbUndumped
end

class DRb::DRbUnknown
  def _dump(lv); end

  def buf(); end

  def exception(); end

  def initialize(err, buf); end

  def name(); end

  def reload(); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end

  def unknown(); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.config(); end

  def self.current_server(); end

  def self.fetch_server(uri); end

  def self.front(); end

  def self.here?(uri); end

  def self.install_acl(acl); end

  def self.install_id_conv(idconv); end

  def self.mutex(); end

  def self.primary_server(); end

  def self.primary_server=(primary_server); end

  def self.regist_server(server); end

  def self.remove_server(server); end

  def self.start_service(uri=T.unsafe(nil), front=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.stop_service(); end

  def self.thread(); end

  def self.to_id(obj); end

  def self.to_obj(ref); end

  def self.uri(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::Mocha::Inspect::DateMethods
  def acts_like_date?(); end

  def ago(seconds); end

  def at_beginning_of_day(); end

  def at_end_of_day(); end

  def at_midday(); end

  def at_middle_of_day(); end

  def at_midnight(); end

  def at_noon(); end

  def beginning_of_day(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def default_inspect(); end

  def end_of_day(); end

  def in(seconds); end

  def midday(); end

  def middle_of_day(); end

  def midnight(); end

  def minus_with_duration(other); end

  def minus_without_duration(_); end

  def noon(); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def readable_inspect(); end

  def since(seconds); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date
  def self.beginning_of_week(); end

  def self.beginning_of_week=(week_start); end

  def self.beginning_of_week_default(); end

  def self.beginning_of_week_default=(beginning_of_week_default); end

  def self.current(); end

  def self.find_beginning_of_week!(week_start); end

  def self.tomorrow(); end

  def self.yesterday(); end
end

module DateAndTime
end

module DateAndTime::Calculations
  def after?(date_or_time); end

  def all_day(); end

  def all_month(); end

  def all_quarter(); end

  def all_week(start_day=T.unsafe(nil)); end

  def all_year(); end

  def at_beginning_of_month(); end

  def at_beginning_of_quarter(); end

  def at_beginning_of_week(start_day=T.unsafe(nil)); end

  def at_beginning_of_year(); end

  def at_end_of_month(); end

  def at_end_of_quarter(); end

  def at_end_of_week(start_day=T.unsafe(nil)); end

  def at_end_of_year(); end

  def before?(date_or_time); end

  def beginning_of_month(); end

  def beginning_of_quarter(); end

  def beginning_of_week(start_day=T.unsafe(nil)); end

  def beginning_of_year(); end

  def days_ago(days); end

  def days_since(days); end

  def days_to_week_start(start_day=T.unsafe(nil)); end

  def end_of_month(); end

  def end_of_quarter(); end

  def end_of_week(start_day=T.unsafe(nil)); end

  def end_of_year(); end

  def future?(); end

  def last_month(); end

  def last_quarter(); end

  def last_week(start_day=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def last_weekday(); end

  def last_year(); end

  def monday(); end

  def months_ago(months); end

  def months_since(months); end

  def next_occurring(day_of_week); end

  def next_quarter(); end

  def next_week(given_day_in_next_week=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def next_weekday(); end

  def on_weekday?(); end

  def on_weekend?(); end

  def past?(); end

  def prev_occurring(day_of_week); end

  def prev_quarter(); end

  def prev_week(start_day=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def prev_weekday(); end

  def sunday(); end

  def today?(); end

  def tomorrow(); end

  def weeks_ago(weeks); end

  def weeks_since(weeks); end

  def years_ago(years); end

  def years_since(years); end

  def yesterday(); end
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
  WEEKEND_DAYS = ::T.let(nil, ::T.untyped)
end

module DateAndTime::Calculations
end

module DateAndTime::Compatibility
  def preserve_timezone(); end
end

module DateAndTime::Compatibility
  def self.preserve_timezone(); end

  def self.preserve_timezone=(obj); end
end

module DateAndTime::Zones
  def in_time_zone(zone=T.unsafe(nil)); end
end

module DateAndTime::Zones
end

module DateAndTime
end

class DateTime
  include ::DateAndTime::Compatibility
  def acts_like_time?(); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmtime(); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def nsec(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def subsec(); end

  def to_f(); end

  def to_i(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end
end

class DateTime
  def self.civil_from_format(utc_or_local, year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), min=T.unsafe(nil), sec=T.unsafe(nil)); end
end

class Delegator
  include ::ActiveSupport::Tryable
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  def self.uuid_from_hash(hash_class, uuid_namespace, name); end

  def self.uuid_v3(uuid_namespace, name); end

  def self.uuid_v4(); end

  def self.uuid_v5(uuid_namespace, name); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  def self.html_escape_once(s); end

  def self.json_escape(s); end

  def self.unwrapped_html_escape(s); end
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def as_json(options=T.unsafe(nil)); end

  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def exclude?(object); end

  def excluding(*elements); end

  def grep_v(_); end

  def including(*elements); end

  def index_with(default=T.unsafe(nil)); end

  def many?(); end

  def pluck(*keys); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(identity=T.unsafe(nil), &block); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def without(*elements); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Erubi
  RANGE_ALL = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  TEXT_END = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Erubi::Engine
  def bufvar(); end

  def filename(); end

  def initialize(input, properties=T.unsafe(nil)); end

  def src(); end
end

class Erubi::Engine
end

module Erubi
  def self.h(value); end
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  include ::ActiveSupport::Dependencies::Blamable
  def __bb_context(); end

  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

module Exception2MessageMapper
  def bind(cl); end

end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

module Faraday
  METHODS_WITH_BODY = ::T.let(nil, ::T.untyped)
  METHODS_WITH_QUERY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter
  def call(env); end

  def close(); end

  def connection(env); end

  def initialize(_app=T.unsafe(nil), opts=T.unsafe(nil), &block); end
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  TIMEOUT_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::EMHttp
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end

  def error_message(client); end

  def parallel?(env); end

  def perform_request(env); end

  def perform_single_request(env); end

  def raise_error(msg); end

  def timeout_message?(msg); end
end

class Faraday::Adapter::EMHttp::Manager
  def add(&block); end

  def check_finished(); end

  def perform_request(); end

  def reset(); end

  def run(); end

  def running?(); end
end

class Faraday::Adapter::EMHttp::Manager
end

module Faraday::Adapter::EMHttp::Options
  def configure_compression(options, env); end

  def configure_proxy(options, env); end

  def configure_socket(options, env); end

  def configure_ssl(options, env); end

  def configure_timeout(options, env); end

  def connection_config(env); end

  def read_body(env); end

  def request_config(env); end

  def request_options(env); end
end

module Faraday::Adapter::EMHttp::Options
end

class Faraday::Adapter::EMHttp
  def self.setup_parallel_manager(_options=T.unsafe(nil)); end
end

class Faraday::Adapter::EMSynchrony
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
  def add(request, method, *args, &block); end

  def run(); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
end

class Faraday::Adapter::EMSynchrony
  def self.setup_parallel_manager(_options=T.unsafe(nil)); end
end

class Faraday::Adapter::Excon
  def build_connection(env); end

  def read_body(env); end
  OPTS_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Excon
end

class Faraday::Adapter::HTTPClient
  def build_connection(env); end

  def configure_client(client); end

  def configure_proxy(client, proxy); end

  def configure_socket(client, bind); end

  def configure_ssl(client, ssl); end

  def configure_timeouts(client, req); end

  def ssl_cert_store(ssl); end

  def ssl_verify_mode(ssl); end
end

class Faraday::Adapter::HTTPClient
end

class Faraday::Adapter::NetHttp
  def build_connection(env); end

  def initialize(app=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def net_http_connection(env); end
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttp
end

class Faraday::Adapter::NetHttpPersistent
  SSL_CONFIGURATIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttpPersistent
end

module Faraday::Adapter::Parallelism
  def inherited(subclass); end

  def supports_parallel=(supports_parallel); end

  def supports_parallel?(); end
end

module Faraday::Adapter::Parallelism
end

class Faraday::Adapter::Patron
  def build_connection(env); end

  def configure_proxy(session, proxy); end

  def configure_ssl(session, ssl); end

  def configure_timeouts(session, req); end
  CURL_TIMEOUT_MESSAGES = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
end

class Faraday::Adapter::Rack
  def initialize(faraday_app, rack_app); end
  SPECIAL_HEADERS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Rack
end

class Faraday::Adapter::Test
  def configure(); end

  def initialize(app, stubs=T.unsafe(nil), &block); end

  def stubs(); end

  def stubs=(stubs); end
end

class Faraday::Adapter::Test::Stub
  def headers_match?(request_headers); end

  def initialize(host, full, headers, body, block); end

  def matches?(request_host, request_uri, request_headers, request_body); end

  def params_match?(request_params); end

  def path_match?(request_path, meta); end
end

class Faraday::Adapter::Test::Stub
end

class Faraday::Adapter::Test::Stubs
  def delete(path, headers=T.unsafe(nil), &block); end

  def empty?(); end

  def get(path, headers=T.unsafe(nil), &block); end

  def head(path, headers=T.unsafe(nil), &block); end

  def match(request_method, host, path, headers, body); end

  def matches?(stack, host, path, headers, body); end

  def new_stub(request_method, path, headers=T.unsafe(nil), body=T.unsafe(nil), &block); end

  def options(path, headers=T.unsafe(nil), &block); end

  def patch(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def post(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def put(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def verify_stubbed_calls(); end
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs
end

class Faraday::Adapter::Test
end

class Faraday::Adapter::Typhoeus
  def call(); end
end

class Faraday::Adapter::Typhoeus
end

class Faraday::Adapter
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::DependencyLoader
  extend ::Faraday::Adapter::Parallelism
  extend ::Faraday::AutoloadHelper
end

class Faraday::AdapterRegistry
  def get(name); end

  def set(klass, name=T.unsafe(nil)); end
end

class Faraday::AdapterRegistry
end

module Faraday::AutoloadHelper
  def all_loaded_constants(); end

  def autoload_all(prefix, options); end

  def load_autoloaded_constants(); end
end

module Faraday::AutoloadHelper
end

class Faraday::BadRequestError
end

class Faraday::BadRequestError
end

class Faraday::ClientError
end

class Faraday::ClientError
end

class Faraday::CompositeReadIO
  def close(); end

  def ensure_open_and_readable(); end

  def initialize(*parts); end

  def length(); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Faraday::CompositeReadIO
end

class Faraday::ConflictError
end

class Faraday::ConflictError
end

class Faraday::Connection
  def adapter(*args, &block); end

  def app(*args, &block); end

  def authorization(type, token); end

  def basic_auth(login, pass); end

  def build(*args, &block); end

  def build_exclusive_url(url=T.unsafe(nil), params=T.unsafe(nil), params_encoder=T.unsafe(nil)); end

  def build_request(method); end

  def build_url(url=T.unsafe(nil), extra_params=T.unsafe(nil)); end

  def builder(); end

  def close(); end

  def default_parallel_manager(); end

  def default_parallel_manager=(default_parallel_manager); end

  def delete(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def find_default_proxy(); end

  def get(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def head(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def headers(); end

  def headers=(hash); end

  def host(*args, &block); end

  def host=(*args, &block); end

  def in_parallel(manager=T.unsafe(nil)); end

  def in_parallel?(); end

  def initialize(url=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize_proxy(url, options); end

  def options(*args); end

  def parallel_manager(); end

  def params(); end

  def params=(hash); end

  def patch(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def path_prefix(*args, &block); end

  def path_prefix=(value); end

  def port(*args, &block); end

  def port=(*args, &block); end

  def post(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def proxy(); end

  def proxy=(new_value); end

  def proxy_for_request(url); end

  def proxy_from_env(url); end

  def put(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def request(*args, &block); end

  def response(*args, &block); end

  def run_request(method, url, body, headers); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end

  def set_authorization_header(header_type, *args); end

  def ssl(); end

  def support_parallel?(adapter); end

  def token_auth(token, options=T.unsafe(nil)); end

  def trace(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def url_prefix(); end

  def url_prefix=(url, encoder=T.unsafe(nil)); end

  def use(*args, &block); end

  def with_uri_credentials(uri); end
  METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Connection
  extend ::Forwardable
end

class Faraday::ConnectionFailed
end

class Faraday::ConnectionFailed
end

class Faraday::ConnectionOptions
  def new_builder(block); end
end

class Faraday::ConnectionOptions
end

module Faraday::DecodeMethods
  def add_to_context(is_array, context, value, subkey); end

  def decode(query); end

  def decode_pair(key, value, context); end

  def dehash(hash, depth); end

  def match_context(context, subkey); end

  def new_context(subkey, is_array, context); end

  def prepare_context(context, subkey, is_array, last_subkey); end
  SUBKEYS_REGEX = ::T.let(nil, ::T.untyped)
end

module Faraday::DecodeMethods
end

module Faraday::DependencyLoader
  def dependency(lib=T.unsafe(nil)); end

  def inherited(subclass); end

  def load_error(); end

  def loaded?(); end

  def new(*_); end
end

module Faraday::DependencyLoader
end

module Faraday::EncodeMethods
  def encode(params); end

  def encode_array(parent, value); end

  def encode_hash(parent, value); end

  def encode_pair(parent, value); end
end

module Faraday::EncodeMethods
end

class Faraday::Env
  def []=(key, value); end

  def body(); end

  def body=(value); end

  def clear_body(); end

  def current_body(); end

  def custom_members(); end

  def in_member_set?(key); end

  def needs_body?(); end

  def parallel?(); end

  def params_encoder(*args, &block); end

  def parse_body?(); end

  def success?(); end
  ContentLength = ::T.let(nil, ::T.untyped)
  MethodsWithBodies = ::T.let(nil, ::T.untyped)
  StatusesWithoutBody = ::T.let(nil, ::T.untyped)
  SuccessfulStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Env
  extend ::Forwardable
  def self.member_set(); end
end

class Faraday::Error
  def exc_msg_and_response(exc, response=T.unsafe(nil)); end

  def exc_msg_and_response!(exc, response=T.unsafe(nil)); end

  def initialize(exc, response=T.unsafe(nil)); end

  def response(); end

  def wrapped_exception(); end
end

class Faraday::Error
end

Faraday::FilePart = UploadIO

module Faraday::FlatParamsEncoder
end

module Faraday::FlatParamsEncoder
  def self.decode(query); end

  def self.encode(params); end

  def self.escape(*args, &block); end

  def self.unescape(*args, &block); end
end

class Faraday::ForbiddenError
end

class Faraday::ForbiddenError
end

class Faraday::Middleware
  def close(); end

  def initialize(app=T.unsafe(nil)); end
end

class Faraday::Middleware
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::DependencyLoader
end

module Faraday::MiddlewareRegistry
  def fetch_middleware(key); end

  def load_middleware(key); end

  def lookup_middleware(key); end

  def middleware_mutex(&block); end

  def register_middleware(autoload_path=T.unsafe(nil), mapping=T.unsafe(nil)); end

  def unregister_middleware(key); end
end

module Faraday::MiddlewareRegistry
end

module Faraday::NestedParamsEncoder
end

module Faraday::NestedParamsEncoder
  extend ::Faraday::EncodeMethods
  extend ::Faraday::DecodeMethods
  def self.escape(*args, &block); end

  def self.unescape(*args, &block); end
end

class Faraday::NilStatusError
end

class Faraday::NilStatusError
end

class Faraday::Options
  def [](key); end

  def clear(); end

  def delete(key); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, *args); end

  def has_key?(key); end

  def has_value?(value); end

  def key?(key); end

  def keys(); end

  def merge(other); end

  def merge!(other); end

  def symbolized_key_set(); end

  def to_hash(); end

  def update(obj); end

  def value?(value); end

  def values_at(*keys); end
end

class Faraday::Options
  def self.attribute_options(); end

  def self.fetch_error_class(); end

  def self.from(value); end

  def self.inherited(subclass); end

  def self.memoized(key, &block); end

  def self.memoized_attributes(); end

  def self.options(mapping); end

  def self.options_for(key); end
end

class Faraday::ParamPart
  def content_id(); end

  def content_type(); end

  def headers(); end

  def initialize(value, content_type, content_id=T.unsafe(nil)); end

  def to_part(boundary, key); end

  def value(); end
end

class Faraday::ParamPart
end

class Faraday::ParsingError
end

class Faraday::ParsingError
end

Faraday::Parts = Parts

class Faraday::ProxyAuthError
end

class Faraday::ProxyAuthError
end

class Faraday::ProxyOptions
  def host(*args, &block); end

  def host=(*args, &block); end

  def path(*args, &block); end

  def path=(*args, &block); end

  def port(*args, &block); end

  def port=(*args, &block); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end
end

class Faraday::ProxyOptions
  extend ::Forwardable
end

class Faraday::RackBuilder
  def ==(other); end

  def [](idx); end

  def adapter(klass=T.unsafe(nil), *args, &block); end

  def app(); end

  def build(options=T.unsafe(nil)); end

  def build_env(connection, request); end

  def build_response(connection, request); end

  def delete(handler); end

  def handlers(); end

  def handlers=(handlers); end

  def initialize(handlers=T.unsafe(nil), adapter=T.unsafe(nil), &block); end

  def insert(index, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, *args, &block); end

  def lock!(); end

  def locked?(); end

  def request(key, *args, &block); end

  def response(key, *args, &block); end

  def swap(index, *args, &block); end

  def to_app(); end

  def use(klass, *args, &block); end
  LOCK_ERR = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder::Handler
  def ==(other); end

  def build(app=T.unsafe(nil)); end

  def initialize(klass, *args, &block); end

  def klass(); end

  def name(); end
  REGISTRY = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder::Handler
end

class Faraday::RackBuilder::StackLocked
end

class Faraday::RackBuilder::StackLocked
end

class Faraday::RackBuilder
end

class Faraday::Request
  def [](key); end

  def []=(key, value); end

  def headers=(hash); end

  def marshal_dump(); end

  def marshal_load(serialised); end

  def params=(hash); end

  def to_env(connection); end

  def url(path, params=T.unsafe(nil)); end
end

class Faraday::Request::Authorization
  def call(env); end

  def initialize(app, type, token); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def self.build_hash(type, hash); end

  def self.header(type, token); end
end

class Faraday::Request::BasicAuthentication
end

class Faraday::Request::BasicAuthentication
  def self.header(login, pass); end
end

class Faraday::Request::Instrumentation
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation
end

class Faraday::Request::Multipart
  def create_multipart(env, params); end

  def has_multipart?(obj); end

  def part(boundary, key, value); end

  def process_params(params, prefix=T.unsafe(nil), pieces=T.unsafe(nil), &block); end

  def unique_boundary(); end
  DEFAULT_BOUNDARY_PREFIX = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Multipart
end

class Faraday::Request::Retry
  def build_exception_matcher(exceptions); end

  def calculate_sleep_amount(retries, env); end

  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  DEFAULT_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
  DEFAULT_CHECK = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
end

class Faraday::Request::Retry
end

class Faraday::Request::TokenAuthentication
  def initialize(app, token, options=T.unsafe(nil)); end
end

class Faraday::Request::TokenAuthentication
  def self.header(token, options=T.unsafe(nil)); end
end

class Faraday::Request::UrlEncoded
  def call(env); end

  def match_content_type(env); end

  def process_request?(env); end

  def request_type(env); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::UrlEncoded
  def self.mime_type(); end

  def self.mime_type=(mime_type); end
end

class Faraday::Request
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper
  def self.create(request_method); end
end

class Faraday::RequestOptions
  def []=(key, value); end

  def stream_response?(); end
end

class Faraday::RequestOptions
end

class Faraday::ResourceNotFound
end

class Faraday::ResourceNotFound
end

class Faraday::Response
  def [](*args, &block); end

  def apply_request(request_env); end

  def body(); end

  def env(); end

  def finish(env); end

  def finished?(); end

  def headers(); end

  def initialize(env=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(env); end

  def on_complete(&block); end

  def reason_phrase(); end

  def status(); end

  def success?(); end

  def to_hash(); end
end

class Faraday::Response::Logger
  def initialize(app, logger=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Faraday::Response::Logger
end

class Faraday::Response::Middleware
  def call(env); end

  def on_complete(env); end
end

class Faraday::Response::Middleware
end

class Faraday::Response::RaiseError
  def response_values(env); end
  ClientErrorStatuses = ::T.let(nil, ::T.untyped)
  ServerErrorStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::RaiseError
end

class Faraday::Response
  extend ::Forwardable
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper
end

class Faraday::RetriableResponse
end

class Faraday::RetriableResponse
end

class Faraday::SSLError
end

class Faraday::SSLError
end

class Faraday::SSLOptions
  def disable?(); end

  def verify?(); end
end

class Faraday::SSLOptions
end

class Faraday::ServerError
end

class Faraday::ServerError
end

class Faraday::TimeoutError
  def initialize(exc=T.unsafe(nil), response=T.unsafe(nil)); end
end

class Faraday::TimeoutError
end

Faraday::Timer = Timeout

class Faraday::UnauthorizedError
end

class Faraday::UnauthorizedError
end

class Faraday::UnprocessableEntityError
end

class Faraday::UnprocessableEntityError
end

Faraday::UploadIO = UploadIO

module Faraday::Utils
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  def [](key); end

  def []=(key, val); end

  def delete(key); end

  def fetch(key, *args, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(hash=T.unsafe(nil)); end

  def initialize_names(); end

  def key?(key); end

  def member?(key); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def parse(header_string); end

  def replace(other); end

  def update(other); end
  KeyMap = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  def self.from(value); end
end

class Faraday::Utils::ParamsHash
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def has_key?(key); end

  def include?(key); end

  def key?(key); end

  def member?(key); end

  def merge(params); end

  def merge!(params); end

  def merge_query(query, encoder=T.unsafe(nil)); end

  def replace(other); end

  def to_query(encoder=T.unsafe(nil)); end

  def update(params); end
end

class Faraday::Utils::ParamsHash
end

module Faraday::Utils
  def self.URI(url); end

  def self.build_nested_query(params); end

  def self.build_query(params); end

  def self.deep_merge(source, hash); end

  def self.deep_merge!(target, hash); end

  def self.default_params_encoder(); end

  def self.default_params_encoder=(default_params_encoder); end

  def self.default_uri_parser(); end

  def self.default_uri_parser=(parser); end

  def self.escape(str); end

  def self.normalize_path(url); end

  def self.parse_nested_query(query); end

  def self.parse_query(query); end

  def self.sort_query_params(query); end

  def self.unescape(str); end
end

module Faraday
  def self.default_adapter(); end

  def self.default_adapter=(adapter); end

  def self.default_connection(); end

  def self.default_connection=(default_connection); end

  def self.default_connection_options(); end

  def self.default_connection_options=(options); end

  def self.ignore_env_proxy(); end

  def self.ignore_env_proxy=(ignore_env_proxy); end

  def self.lib_path(); end

  def self.lib_path=(lib_path); end

  def self.new(url=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.require_lib(*libs); end

  def self.require_libs(*libs); end

  def self.respond_to_missing?(symbol, include_private=T.unsafe(nil)); end

  def self.root_path(); end

  def self.root_path=(root_path); end
end

class Fiber
  def resume(*_); end

  def transfer(*_); end
end

class Fiber
  def self.current(); end

  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

  def self.probe_stat_in(dir); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, **options, &block); end

  def safe_ln(*args, **options); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  include ::ActiveSupport::NumericWithFormat
  def to_d(precision=T.unsafe(nil)); end
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

class Gem::RemoteFetcher::FetchError
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Specification
  extend ::Enumerable
end

class GlobalID
  def ==(other); end

  def app(*args, &block); end

  def eql?(other); end

  def find(options=T.unsafe(nil)); end

  def initialize(gid, options=T.unsafe(nil)); end

  def model_class(); end

  def model_id(*args, &block); end

  def model_name(*args, &block); end

  def params(*args, &block); end

  def to_s(*args, &block); end

  def uri(); end
end

module GlobalID::Identification
  def to_gid(options=T.unsafe(nil)); end

  def to_gid_param(options=T.unsafe(nil)); end

  def to_global_id(options=T.unsafe(nil)); end

  def to_sgid(options=T.unsafe(nil)); end

  def to_sgid_param(options=T.unsafe(nil)); end

  def to_signed_global_id(options=T.unsafe(nil)); end
end

module GlobalID::Identification
  extend ::ActiveSupport::Concern
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

class GlobalID::Railtie
end

class GlobalID::Railtie
end

class GlobalID::Verifier
end

class GlobalID::Verifier
end

class GlobalID
  extend ::ActiveSupport::Autoload
  def self.app(); end

  def self.app=(app); end

  def self.create(model, options=T.unsafe(nil)); end

  def self.find(gid, options=T.unsafe(nil)); end

  def self.parse(gid, options=T.unsafe(nil)); end
end

module GraphQL
  BOOLEAN_TYPE = ::T.let(nil, ::T.untyped)
  FLOAT_TYPE = ::T.let(nil, ::T.untyped)
  ID_TYPE = ::T.let(nil, ::T.untyped)
  INT_TYPE = ::T.let(nil, ::T.untyped)
  STRING_TYPE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module GraphQL::Analysis
end

module GraphQL::Analysis::AST
end

class GraphQL::Analysis::AST::Analyzer
  def analyze?(); end

  def initialize(subject); end

  def multiplex(); end

  def on_enter_abstract_node(node, parent, visitor); end

  def on_enter_argument(node, parent, visitor); end

  def on_enter_directive(node, parent, visitor); end

  def on_enter_document(node, parent, visitor); end

  def on_enter_enum(node, parent, visitor); end

  def on_enter_field(node, parent, visitor); end

  def on_enter_fragment_spread(node, parent, visitor); end

  def on_enter_inline_fragment(node, parent, visitor); end

  def on_enter_input_object(node, parent, visitor); end

  def on_enter_list_type(node, parent, visitor); end

  def on_enter_non_null_type(node, parent, visitor); end

  def on_enter_null_value(node, parent, visitor); end

  def on_enter_operation_definition(node, parent, visitor); end

  def on_enter_type_name(node, parent, visitor); end

  def on_enter_variable_definition(node, parent, visitor); end

  def on_enter_variable_identifier(node, parent, visitor); end

  def on_leave_abstract_node(node, parent, visitor); end

  def on_leave_argument(node, parent, visitor); end

  def on_leave_directive(node, parent, visitor); end

  def on_leave_document(node, parent, visitor); end

  def on_leave_enum(node, parent, visitor); end

  def on_leave_field(node, parent, visitor); end

  def on_leave_fragment_spread(node, parent, visitor); end

  def on_leave_inline_fragment(node, parent, visitor); end

  def on_leave_input_object(node, parent, visitor); end

  def on_leave_list_type(node, parent, visitor); end

  def on_leave_non_null_type(node, parent, visitor); end

  def on_leave_null_value(node, parent, visitor); end

  def on_leave_operation_definition(node, parent, visitor); end

  def on_leave_type_name(node, parent, visitor); end

  def on_leave_variable_definition(node, parent, visitor); end

  def on_leave_variable_identifier(node, parent, visitor); end

  def query(); end

  def result(); end

  def subject(); end
end

class GraphQL::Analysis::AST::Analyzer
end

class GraphQL::Analysis::AST::FieldUsage
  def initialize(query); end
end

class GraphQL::Analysis::AST::FieldUsage
end

class GraphQL::Analysis::AST::MaxQueryComplexity
end

class GraphQL::Analysis::AST::MaxQueryComplexity
end

class GraphQL::Analysis::AST::MaxQueryDepth
end

class GraphQL::Analysis::AST::MaxQueryDepth
end

class GraphQL::Analysis::AST::QueryComplexity
  def initialize(query); end
end

class GraphQL::Analysis::AST::QueryComplexity::ScopedTypeComplexity
  def field_definition(); end

  def initialize(node, field_definition, query, response_path); end

  def own_complexity(child_complexity); end

  def query(); end

  def response_path(); end

  def scoped_children(); end

  def terminal?(); end
  HASH_CHILDREN = ::T.let(nil, ::T.untyped)
end

class GraphQL::Analysis::AST::QueryComplexity::ScopedTypeComplexity
end

class GraphQL::Analysis::AST::QueryComplexity
end

class GraphQL::Analysis::AST::QueryDepth
  def initialize(query); end
end

class GraphQL::Analysis::AST::QueryDepth
end

class GraphQL::Analysis::AST::Visitor
  def argument_definition(); end

  def arguments_for(ast_node, field_definition); end

  def directive_definition(); end

  def field_definition(); end

  def initialize(query:, analyzers:); end

  def object_types(); end

  def parent_type_definition(); end

  def previous_argument_definition(); end

  def previous_field_definition(); end

  def query(); end

  def response_path(); end

  def skipping?(); end

  def type_definition(); end

  def visiting_fragment_definition?(); end
end

class GraphQL::Analysis::AST::Visitor
end

module GraphQL::Analysis::AST
  def self.analysis_errors(results); end

  def self.analyze_multiplex(multiplex, analyzers); end

  def self.analyze_query(query, analyzers, multiplex_analyzers: T.unsafe(nil)); end

  def self.use(schema_class); end
end

class GraphQL::Analysis::FieldUsage
  def call(memo, visit_type, irep_node); end

  def final_value(memo); end

  def initial_value(query); end

  def initialize(&block); end
end

class GraphQL::Analysis::FieldUsage
end

class GraphQL::Analysis::MaxQueryComplexity
  def initialize(max_complexity); end
end

class GraphQL::Analysis::MaxQueryComplexity
end

class GraphQL::Analysis::MaxQueryDepth
  def initialize(max_depth); end
end

class GraphQL::Analysis::MaxQueryDepth
end

class GraphQL::Analysis::QueryComplexity
  def call(memo, visit_type, irep_node); end

  def final_value(reduced_value); end

  def initial_value(target); end

  def initialize(&block); end
end

class GraphQL::Analysis::QueryComplexity::TypeComplexity
  def max_possible_complexity(); end

  def merge(type_defn, complexity); end
end

class GraphQL::Analysis::QueryComplexity::TypeComplexity
end

class GraphQL::Analysis::QueryComplexity
end

class GraphQL::Analysis::QueryDepth
  def call(memo, visit_type, irep_node); end

  def final_value(memo); end

  def initial_value(query); end

  def initialize(&block); end
end

class GraphQL::Analysis::QueryDepth
end

class GraphQL::Analysis::ReducerState
  def call(visit_type, irep_node); end

  def errors(); end

  def errors=(errors); end

  def finalize_reducer(); end

  def initialize(reducer, query); end

  def memo(); end

  def memo=(memo); end

  def reducer(); end
end

class GraphQL::Analysis::ReducerState
end

module GraphQL::Analysis
  def self.analysis_errors(results); end

  def self.analyze_multiplex(multiplex, analyzers); end

  def self.analyze_query(query, analyzers, multiplex_states: T.unsafe(nil)); end

  def self.reduce_node(irep_node, reducer_states); end

  def self.visit_analyzers(visit_type, irep_node, reducer_states); end
end

class GraphQL::AnalysisError
end

class GraphQL::AnalysisError
end

class GraphQL::Argument
  include ::GraphQL::Define::InstanceDefinable
  def as(); end

  def as=(as); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def default_value(); end

  def default_value=(new_default_value); end

  def default_value?(); end

  def description(); end

  def description=(description); end

  def expose_as(); end

  def graphql_name(); end

  def keyword(); end

  def method_access(); end

  def method_access=(method_access); end

  def method_access?(); end

  def name(); end

  def name=(name); end

  def prepare(value, ctx); end

  def prepare=(prepare_proc); end

  def type(); end

  def type=(new_input_type); end

  def type_class(); end
  NO_DEFAULT_VALUE = ::T.let(nil, ::T.untyped)
end

module GraphQL::Argument::DefaultPrepare
end

module GraphQL::Argument::DefaultPrepare
  def self.call(value, ctx); end
end

class GraphQL::Argument
  def self.deep_stringify(val); end

  def self.from_dsl(name, type_or_argument=T.unsafe(nil), description=T.unsafe(nil), default_value: T.unsafe(nil), as: T.unsafe(nil), prepare: T.unsafe(nil), **kwargs, &block); end
end

module GraphQL::Authorization
end

module GraphQL::Authorization::Analyzer
end

module GraphQL::Authorization::Analyzer
  def self.call(memo, visit_type, irep_node); end

  def self.final_value(memo); end

  def self.initial_value(query); end
end

class GraphQL::Authorization::InaccessibleFieldsError
  def context(); end

  def fields(); end

  def initialize(fields:, irep_nodes:, context:); end

  def irep_nodes(); end
end

class GraphQL::Authorization::InaccessibleFieldsError
end

module GraphQL::Authorization
end

class GraphQL::Backtrace
  include ::Enumerable
  def [](*args, &block); end

  def each(*args, &block); end

  def initialize(context, value: T.unsafe(nil)); end

  def to_a(); end
end

module GraphQL::Backtrace::InspectResult
end

module GraphQL::Backtrace::InspectResult
  def self.inspect_result(obj); end

  def self.inspect_truncated(obj); end
end

class GraphQL::Backtrace::Table
  def initialize(context, value:); end

  def to_backtrace(); end

  def to_table(); end
  HEADERS = ::T.let(nil, ::T.untyped)
  MAX_COL_WIDTH = ::T.let(nil, ::T.untyped)
  MIN_COL_WIDTH = ::T.let(nil, ::T.untyped)
end

class GraphQL::Backtrace::Table
end

class GraphQL::Backtrace::TracedError
  def context(); end

  def graphql_backtrace(); end

  def initialize(err, current_ctx); end
  CAUSE_BACKTRACE_PREVIEW_LENGTH = ::T.let(nil, ::T.untyped)
  MESSAGE_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class GraphQL::Backtrace::TracedError
end

module GraphQL::Backtrace::Tracer
end

module GraphQL::Backtrace::Tracer
  def self.trace(key, metadata); end
end

class GraphQL::Backtrace
  extend ::Forwardable
  def self.disable(); end

  def self.enable(); end

  def self.use(schema_defn); end
end

module GraphQL::BackwardsCompatibility
end

class GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
  def call(*args); end

  def initialize(callable, old_arity); end
end

class GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
end

class GraphQL::BackwardsCompatibility::LastArgumentsWrapper
end

class GraphQL::BackwardsCompatibility::LastArgumentsWrapper
end

module GraphQL::BackwardsCompatibility
  def self.get_arity(callable); end

  def self.wrap_arity(callable, from:, to:, name:, last: T.unsafe(nil)); end
end

class GraphQL::BaseType
  include ::GraphQL::Define::NonNullWithBang
  include ::GraphQL::Define::InstanceDefinable
  include ::GraphQL::Relay::TypeExtensions
  def ==(other); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def coerce_input(value, ctx=T.unsafe(nil)); end

  def coerce_isolated_input(value); end

  def coerce_isolated_result(value); end

  def coerce_result(value, ctx); end

  def default_relay=(default_relay); end

  def default_relay?(); end

  def default_scalar=(default_scalar); end

  def default_scalar?(); end

  def description(); end

  def description=(description); end

  def get_field(name); end

  def graphql_definition(); end

  def graphql_name(); end

  def introspection=(introspection); end

  def introspection?(); end

  def list?(); end

  def name(); end

  def name=(name); end

  def non_null?(); end

  def resolve_type(value, ctx); end

  def to_definition(schema, printer: T.unsafe(nil), **args); end

  def to_list_type(); end

  def to_non_null_type(); end

  def to_type_signature(); end

  def type_class(); end

  def unwrap(); end

  def valid_input?(value, ctx=T.unsafe(nil)); end

  def valid_isolated_input?(value); end

  def validate_input(value, ctx=T.unsafe(nil)); end

  def validate_isolated_input(value); end
end

module GraphQL::BaseType::ModifiesAnotherType
  def ==(other); end

  def unwrap(); end
end

module GraphQL::BaseType::ModifiesAnotherType
end

class GraphQL::BaseType
  def self.resolve_related_type(type_arg); end
end

class GraphQL::Client
  def allow_dynamic_queries(); end

  def allow_dynamic_queries=(allow_dynamic_queries); end

  def create_operation(fragment, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def document(); end

  def document_tracking_enabled(); end

  def document_tracking_enabled=(document_tracking_enabled); end

  def enforce_collocated_callers(); end

  def execute(); end

  def get_type(type_name); end

  def initialize(schema:, execute: T.unsafe(nil), enforce_collocated_callers: T.unsafe(nil)); end

  def parse(str, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def query(definition, variables: T.unsafe(nil), context: T.unsafe(nil)); end

  def schema(); end

  def types(); end
  IntrospectionDocument = ::T.let(nil, ::T.untyped)
  WHITELISTED_GEM_NAMES = ::T.let(nil, ::T.untyped)
end

module GraphQL::Client::CollocatedEnforcement
  def allow_noncollocated_callers(); end

  def enforce_collocated_callers(mod, methods, path); end
end

module GraphQL::Client::CollocatedEnforcement
end

class GraphQL::Client::Definition
  def client(); end

  def definition_name(); end

  def definition_node(); end

  def document(); end

  def indexes(); end

  def initialize(client:, document:, source_document:, ast_node:, source_location:); end

  def new(obj, errors=T.unsafe(nil)); end

  def schema_class(); end

  def source_document(); end

  def source_location(); end
  EMPTY_SET = ::T.let(nil, ::T.untyped)
end

class GraphQL::Client::Definition
  def self.for(ast_node:, **kargs); end
end

module GraphQL::Client::DefinitionVariables
end

module GraphQL::Client::DefinitionVariables
  def self.operation_variables(schema, document, definition_name=T.unsafe(nil)); end

  def self.variable_node(type); end

  def self.variables(schema, document, definition_name=T.unsafe(nil)); end
end

module GraphQL::Client::DocumentTypes
end

module GraphQL::Client::DocumentTypes
  def self.analyze_types(schema, document); end
end

class GraphQL::Client::DynamicQueryError
end

class GraphQL::Client::DynamicQueryError
end

class GraphQL::Client::Error
end

class GraphQL::Client::Error
end

class GraphQL::Client::Errors
  include ::Enumerable
  def [](key); end

  def all(); end

  def count(); end

  def details(); end

  def each(&blk); end

  def empty?(); end

  def filter_by_path(field); end

  def has_key?(field); end

  def include?(field); end

  def initialize(errors=T.unsafe(nil), path=T.unsafe(nil), all=T.unsafe(nil)); end

  def key?(field); end

  def keys(); end

  def messages(); end

  def size(); end

  def values(); end
end

class GraphQL::Client::Errors
  def self.normalize_error_paths(data=T.unsafe(nil), errors=T.unsafe(nil)); end
end

class GraphQL::Client::FragmentDefinition
  def new(obj, *args); end
end

class GraphQL::Client::FragmentDefinition
end

class GraphQL::Client::HTTP
  def connection(); end

  def execute(document:, operation_name: T.unsafe(nil), variables: T.unsafe(nil), context: T.unsafe(nil)); end

  def headers(_context); end

  def initialize(uri, &block); end

  def uri(); end
end

class GraphQL::Client::HTTP
end

class GraphQL::Client::HashWithIndifferentAccess
  include ::Enumerable
  def [](key); end

  def each(*args, &block); end

  def each_key(&block); end

  def empty?(*args, &block); end

  def fetch(key, *args, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(hash=T.unsafe(nil)); end

  def inspect(*args, &block); end

  def key?(key); end

  def keys(*args, &block); end

  def length(*args, &block); end

  def member?(key); end

  def size(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Client::HashWithIndifferentAccess
  extend ::Forwardable
end

class GraphQL::Client::ImplicitlyFetchedFieldError
end

class GraphQL::Client::ImplicitlyFetchedFieldError
end

class GraphQL::Client::InvariantError
end

class GraphQL::Client::InvariantError
end

module GraphQL::Client::LazyName
  def _definition=(_definition); end

  def name(); end
end

module GraphQL::Client::LazyName
end

class GraphQL::Client::List
  def errors(); end

  def initialize(values, errors=T.unsafe(nil)); end
end

class GraphQL::Client::List
end

class GraphQL::Client::NonCollocatedCallerError
end

class GraphQL::Client::NonCollocatedCallerError
end

class GraphQL::Client::NotImplementedError
end

class GraphQL::Client::NotImplementedError
end

class GraphQL::Client::OperationDefinition
  def operation_name(); end
end

class GraphQL::Client::OperationDefinition
end

module GraphQL::Client::QueryTypename
end

class GraphQL::Client::QueryTypename::InsertTypenameVisitor
  def add_typename(node, parent); end

  def initialize(document, types:); end
end

class GraphQL::Client::QueryTypename::InsertTypenameVisitor
end

module GraphQL::Client::QueryTypename
  def self.insert_typename_fields(document, types: T.unsafe(nil)); end

  def self.node_flatten_selections(selections); end
end

class GraphQL::Client::RenameNodeHook
  def initialize(definitions); end

  def rename_node(node, _parent); end
end

class GraphQL::Client::RenameNodeHook
end

class GraphQL::Client::RenameNodeVisitor
  def initialize(document, definitions:); end

  def on_fragment_definition(node, _parent); end

  def on_fragment_spread(node, _parent); end

  def on_operation_definition(node, _parent); end
end

class GraphQL::Client::RenameNodeVisitor
end

class GraphQL::Client::Response
  def data(); end

  def errors(); end

  def extensions(); end

  def initialize(hash, data: T.unsafe(nil), errors: T.unsafe(nil), extensions: T.unsafe(nil)); end

  def original_hash(); end

  def to_h(); end
end

class GraphQL::Client::Response
end

module GraphQL::Client::Schema
end

module GraphQL::Client::Schema::BaseType
  def cast(value, errors); end

  def schema_module(); end

  def schema_module=(schema_module); end

  def to_list_type(); end

  def to_non_null_type(); end

  def type(); end
end

module GraphQL::Client::Schema::BaseType
end

module GraphQL::Client::Schema::ClassMethods
  def define_class(definition, ast_nodes, type); end

  def directives(); end

  def get_class(type_name); end

  def set_class(type_name, klass); end
  DIRECTIVES = ::T.let(nil, ::T.untyped)
end

module GraphQL::Client::Schema::ClassMethods
end

class GraphQL::Client::Schema::EnumType
  include ::GraphQL::Client::Schema::BaseType
  def [](value); end

  def cast(value, _errors=T.unsafe(nil)); end

  def define_class(definition, ast_nodes); end

  def initialize(type); end
end

class GraphQL::Client::Schema::EnumType::EnumValue
  def initialize(obj, enum_value, enum); end

  def method_missing(method_name, *args); end
end

class GraphQL::Client::Schema::EnumType::EnumValue
end

class GraphQL::Client::Schema::EnumType
end

class GraphQL::Client::Schema::IncludeDirective
  include ::GraphQL::Client::Schema::BaseType
  def initialize(of_klass); end

  def of_klass(); end
end

class GraphQL::Client::Schema::IncludeDirective
end

class GraphQL::Client::Schema::InterfaceType
  include ::GraphQL::Client::Schema::BaseType
  def define_class(definition, ast_nodes); end

  def initialize(type); end

  def new(types); end
end

class GraphQL::Client::Schema::InterfaceType
end

class GraphQL::Client::Schema::ListType
  include ::GraphQL::Client::Schema::BaseType
  def cast(values, errors); end

  def initialize(of_klass); end

  def of_klass(); end
end

class GraphQL::Client::Schema::ListType
end

class GraphQL::Client::Schema::NonNullType
  include ::GraphQL::Client::Schema::BaseType
  def initialize(of_klass); end

  def of_klass(); end
end

class GraphQL::Client::Schema::NonNullType
end

class GraphQL::Client::Schema::ObjectClass
  def errors(); end

  def initialize(data=T.unsafe(nil), errors=T.unsafe(nil)); end

  def method_missing(*args); end

  def to_h(); end
end

module GraphQL::Client::Schema::ObjectClass::ClassMethods
  def _spreads(); end

  def source_definition(); end
end

module GraphQL::Client::Schema::ObjectClass::ClassMethods
end

class GraphQL::Client::Schema::ObjectClass
  extend ::GraphQL::Client::Schema::ObjectClass::ClassMethods
end

module GraphQL::Client::Schema::ObjectType
  def cast(value, errors); end

  def define_class(definition, ast_nodes); end

  def define_field(name, type); end

  def define_fields(fields); end
  FIELDS_CACHE = ::T.let(nil, ::T.untyped)
  METHOD_CACHE = ::T.let(nil, ::T.untyped)
  MODULE_CACHE = ::T.let(nil, ::T.untyped)
  PREDICATE_CACHE = ::T.let(nil, ::T.untyped)
end

module GraphQL::Client::Schema::ObjectType
  def self.define_cached_field(name, ctx); end

  def self.new(type, fields=T.unsafe(nil)); end
end

class GraphQL::Client::Schema::PossibleTypes
  include ::GraphQL::Client::Schema::BaseType
  def initialize(type, types); end

  def possible_types(); end
end

class GraphQL::Client::Schema::PossibleTypes
end

class GraphQL::Client::Schema::ScalarType
  include ::GraphQL::Client::Schema::BaseType
  def cast(value, _errors=T.unsafe(nil)); end

  def define_class(definition, ast_nodes); end

  def initialize(type); end
end

class GraphQL::Client::Schema::ScalarType
end

class GraphQL::Client::Schema::SkipDirective
  include ::GraphQL::Client::Schema::BaseType
  def initialize(of_klass); end

  def of_klass(); end
end

class GraphQL::Client::Schema::SkipDirective
end

class GraphQL::Client::Schema::UnionType
  include ::GraphQL::Client::Schema::BaseType
  def define_class(definition, ast_nodes); end

  def initialize(type); end

  def new(types); end
end

class GraphQL::Client::Schema::UnionType
end

module GraphQL::Client::Schema
  def self.class_for(schema, type, cache); end

  def self.generate(schema); end
end

class GraphQL::Client::UnfetchedFieldError
end

class GraphQL::Client::UnfetchedFieldError
end

class GraphQL::Client::UnimplementedFieldError
end

class GraphQL::Client::UnimplementedFieldError
end

class GraphQL::Client::ValidationError
end

class GraphQL::Client::ValidationError
end

class GraphQL::Client
  extend ::GraphQL::Client::CollocatedEnforcement
  def self.dump_schema(schema, io=T.unsafe(nil), context: T.unsafe(nil)); end

  def self.load_schema(schema); end
end

class GraphQL::CoercionError
  def extensions(); end

  def extensions=(extensions); end

  def initialize(message, extensions: T.unsafe(nil)); end
end

class GraphQL::CoercionError
end

module GraphQL::Compatibility
end

module GraphQL::Compatibility::ExecutionSpecification
end

module GraphQL::Compatibility::ExecutionSpecification::CounterSchema
end

module GraphQL::Compatibility::ExecutionSpecification::CounterSchema
  def self.build(execution_strategy); end
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema
  BOGUS_NODE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
end

class GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::CustomCollection
  def each(&blk); end

  def initialize(storage); end
end

class GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::CustomCollection
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::TestMiddleware
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::TestMiddleware
  def self.call(parent_type, parent_object, field_definition, field_args, query_context, &next_middleware); end
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema
  def self.build(execution_strategy); end
end

module GraphQL::Compatibility::ExecutionSpecification
  def self.build_suite(execution_strategy); end
end

module GraphQL::Compatibility::LazyExecutionSpecification
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyInstrumentation
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyInstrumentation
  def self.instrument(type, field); end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPush
  def initialize(ctx, value); end

  def push(); end

  def value(); end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPush
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPushCollection
  def initialize(ctx, values); end

  def push(); end

  def value(); end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPushCollection
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema
  def self.build(execution_strategy); end
end

module GraphQL::Compatibility::LazyExecutionSpecification
  def self.build_suite(execution_strategy); end
end

module GraphQL::Compatibility::QueryParserSpecification
  QUERY_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Compatibility::QueryParserSpecification::ParseErrorSpecification
  def assert_raises_parse_error(query_string); end

  def assert_rejects_character(char); end

  def test_it_includes_line_and_column(); end

  def test_it_rejects_bad_unicode(); end

  def test_it_rejects_blank_queries(); end

  def test_it_rejects_empty_inline_fragments(); end

  def test_it_rejects_invalid_characters(); end

  def test_it_rejects_unexpected_ends(); end

  def test_it_rejects_unterminated_strings(); end

  def test_it_restricts_on(); end
end

module GraphQL::Compatibility::QueryParserSpecification::ParseErrorSpecification
end

module GraphQL::Compatibility::QueryParserSpecification::QueryAssertions
  def assert_valid_directive(directive); end

  def assert_valid_field(field); end

  def assert_valid_fragment(fragment_def); end

  def assert_valid_fragment_spread(fragment_spread); end

  def assert_valid_literal_argument(argument); end

  def assert_valid_query(query); end

  def assert_valid_typed_inline_fragment(inline_fragment); end

  def assert_valid_typeless_inline_fragment(inline_fragment); end

  def assert_valid_variable(variable); end

  def assert_valid_variable_argument(argument); end
end

module GraphQL::Compatibility::QueryParserSpecification::QueryAssertions
end

module GraphQL::Compatibility::QueryParserSpecification
  def self.build_suite(&block); end
end

module GraphQL::Compatibility::SchemaParserSpecification
  SCHEMA_DEFINITION_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Compatibility::SchemaParserSpecification
  def self.build_suite(&block); end
end

module GraphQL::Compatibility
end

module GraphQL::Define
end

module GraphQL::Define::AssignArgument
end

module GraphQL::Define::AssignArgument
  def self.call(target, *args, **kwargs, &block); end
end

module GraphQL::Define::AssignConnection
end

module GraphQL::Define::AssignConnection
  def self.call(type_defn, *field_args, max_page_size: T.unsafe(nil), **field_kwargs, &field_block); end
end

module GraphQL::Define::AssignEnumValue
end

module GraphQL::Define::AssignEnumValue
  def self.call(enum_type, name, desc=T.unsafe(nil), deprecation_reason: T.unsafe(nil), value: T.unsafe(nil), &block); end
end

module GraphQL::Define::AssignGlobalIdField
end

module GraphQL::Define::AssignGlobalIdField
  def self.call(type_defn, field_name); end
end

module GraphQL::Define::AssignMutationFunction
end

class GraphQL::Define::AssignMutationFunction::ResultProxy
  def client_mutation_id(); end

  def initialize(target, client_mutation_id); end
end

class GraphQL::Define::AssignMutationFunction::ResultProxy
end

module GraphQL::Define::AssignMutationFunction
  def self.call(target, function); end
end

module GraphQL::Define::AssignObjectField
end

module GraphQL::Define::AssignObjectField
  def self.call(owner_type, name, type_or_field=T.unsafe(nil), desc=T.unsafe(nil), function: T.unsafe(nil), field: T.unsafe(nil), relay_mutation_function: T.unsafe(nil), **kwargs, &block); end
end

class GraphQL::Define::DefinedObjectProxy
  def initialize(target); end

  def method_missing(name, *args, &block); end

  def target(); end

  def types(); end

  def use(plugin, **kwargs); end
end

class GraphQL::Define::DefinedObjectProxy
  extend ::GraphQL::Ruby2Keywords
end

module GraphQL::Define::InstanceDefinable
  def define(**kwargs, &block); end

  def metadata(); end

  def redefine(**kwargs, &block); end
end

module GraphQL::Define::InstanceDefinable
  def self.included(base); end
end

class GraphQL::Define::NoDefinitionError
end

class GraphQL::Define::NoDefinitionError
end

module GraphQL::Define::NonNullWithBang
  def !(); end
end

module GraphQL::Define::NonNullWithBang
end

class GraphQL::Define::TypeDefiner
  include ::Singleton
  def Boolean(); end

  def Float(); end

  def ID(); end

  def Int(); end

  def String(); end

  def [](type); end
end

class GraphQL::Define::TypeDefiner
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module GraphQL::Define
  def self.assign_metadata_key(key); end
end

module GraphQL::DeprecatedDSL
  TYPE_CLASSES = ::T.let(nil, ::T.untyped)
end

module GraphQL::DeprecatedDSL::Methods
  def !(); end
end

module GraphQL::DeprecatedDSL::Methods
end

module GraphQL::DeprecatedDSL
  def self.activate(); end
end

module GraphQL::Dig
  def dig(own_key, *rest_keys); end
end

module GraphQL::Dig
end

class GraphQL::Directive
  include ::GraphQL::Define::InstanceDefinable
  def arguments(); end

  def arguments=(arguments); end

  def arguments_class(); end

  def arguments_class=(arguments_class); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def default_directive=(default_directive); end

  def default_directive?(); end

  def description(); end

  def description=(description); end

  def graphql_definition(); end

  def graphql_name(); end

  def locations(); end

  def locations=(locations); end

  def name(); end

  def name=(name); end

  def on_field?(); end

  def on_fragment?(); end

  def on_operation?(); end

  def type_class(); end
  ARGUMENT_DEFINITION = ::T.let(nil, ::T.untyped)
  DeprecatedDirective = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_VALUE = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FIELD_DEFINITION = ::T.let(nil, ::T.untyped)
  FRAGMENT_DEFINITION = ::T.let(nil, ::T.untyped)
  FRAGMENT_SPREAD = ::T.let(nil, ::T.untyped)
  INLINE_FRAGMENT = ::T.let(nil, ::T.untyped)
  INPUT_FIELD_DEFINITION = ::T.let(nil, ::T.untyped)
  INPUT_OBJECT = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  IncludeDirective = ::T.let(nil, ::T.untyped)
  LOCATIONS = ::T.let(nil, ::T.untyped)
  LOCATION_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
  MUTATION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  SCALAR = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  SUBSCRIPTION = ::T.let(nil, ::T.untyped)
  SkipDirective = ::T.let(nil, ::T.untyped)
  UNION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Directive
end

class GraphQL::EnumType
  def add_value(enum_value); end

  def coerce_result(value, ctx=T.unsafe(nil)); end

  def kind(); end

  def values(); end

  def values=(new_values); end
end

class GraphQL::EnumType::EnumValue
  include ::GraphQL::Define::InstanceDefinable
  def ast_node(); end

  def ast_node=(ast_node); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(); end

  def description=(description); end

  def graphql_name(); end

  def name(); end

  def name=(new_name); end

  def type_class(); end

  def value(); end

  def value=(value); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class GraphQL::EnumType::EnumValue
end

class GraphQL::EnumType::UnresolvedValueError
end

class GraphQL::EnumType::UnresolvedValueError
end

class GraphQL::EnumType
end

class GraphQL::Error
end

class GraphQL::Error
end

module GraphQL::Execution
end

module GraphQL::Execution::DirectiveChecks
  INCLUDE = ::T.let(nil, ::T.untyped)
  SKIP = ::T.let(nil, ::T.untyped)
end

module GraphQL::Execution::DirectiveChecks
  def self.include?(directive_ast_nodes, query); end
end

class GraphQL::Execution::Errors
  def initialize(schema); end

  def with_error_handling(ctx); end
end

class GraphQL::Execution::Errors::NullErrorHandler
end

class GraphQL::Execution::Errors::NullErrorHandler
  def self.with_error_handling(_ctx); end
end

class GraphQL::Execution::Errors
  def self.use(schema); end
end

class GraphQL::Execution::Execute
  include ::GraphQL::Execution::Execute::ExecutionFunctions
  def execute(ast_operation, root_type, query); end
  PROPAGATE_NULL = ::T.let(nil, ::T.untyped)
  SKIP = ::T.let(nil, ::T.untyped)
end

module GraphQL::Execution::Execute::ExecutionFunctions
end

module GraphQL::Execution::Execute::ExecutionFunctions
  def self.continue_or_wait(raw_value, field_type, field_ctx); end

  def self.continue_resolve_field(raw_value, field_type, field_ctx); end

  def self.lazy_resolve_root_selection(result, query: T.unsafe(nil), multiplex: T.unsafe(nil)); end

  def self.resolve_field(object, field_ctx); end

  def self.resolve_root_selection(query); end

  def self.resolve_selection(object, current_type, current_ctx, mutation: T.unsafe(nil)); end

  def self.resolve_value(value, field_type, field_ctx); end
end

module GraphQL::Execution::Execute::FieldResolveStep
end

module GraphQL::Execution::Execute::FieldResolveStep
  def self.call(_parent_type, parent_object, field_definition, field_args, context, _next=T.unsafe(nil)); end
end

class GraphQL::Execution::Execute::PropagateNull
end

class GraphQL::Execution::Execute::PropagateNull
end

class GraphQL::Execution::Execute::Skip
end

class GraphQL::Execution::Execute::Skip
end

class GraphQL::Execution::Execute
  def self.begin_multiplex(_multiplex); end

  def self.begin_query(query, _multiplex); end

  def self.finish_multiplex(results, multiplex); end

  def self.finish_query(query, _multiplex); end
end

module GraphQL::Execution::Flatten
end

module GraphQL::Execution::Flatten
  def self.call(ctx); end
end

module GraphQL::Execution::Instrumentation
end

module GraphQL::Execution::Instrumentation
  def self.apply_instrumenters(multiplex); end
end

class GraphQL::Execution::Interpreter
  def evaluate(query); end

  def execute(_operation, _root_type, query); end

  def sync_lazies(query: T.unsafe(nil), multiplex: T.unsafe(nil)); end
end

class GraphQL::Execution::Interpreter::ArgumentsCache
  def fetch(ast_node, argument_owner, parent_object); end

  def initialize(query); end
  NO_VALUE_GIVEN = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Interpreter::ArgumentsCache
end

class GraphQL::Execution::Interpreter::ExecutionErrors
  def add(err_or_msg); end

  def initialize(ctx, ast_node, path); end
end

class GraphQL::Execution::Interpreter::ExecutionErrors
end

module GraphQL::Execution::Interpreter::HandlesRawValue
  def raw_value(obj); end
end

module GraphQL::Execution::Interpreter::HandlesRawValue
end

class GraphQL::Execution::Interpreter::HashResponse
  def final_value(); end

  def write(path, value); end
end

class GraphQL::Execution::Interpreter::HashResponse
end

class GraphQL::Execution::Interpreter::RawValue
  def initialize(obj=T.unsafe(nil)); end

  def resolve(); end
end

class GraphQL::Execution::Interpreter::RawValue
end

module GraphQL::Execution::Interpreter::Resolve
end

module GraphQL::Execution::Interpreter::Resolve
  def self.resolve(results); end

  def self.resolve_all(results); end
end

class GraphQL::Execution::Interpreter::Runtime
  def add_dead_path(path); end

  def after_lazy(lazy_obj, owner:, field:, path:, scoped_context:, owner_object:, arguments:, eager: T.unsafe(nil), trace: T.unsafe(nil)); end

  def arguments(graphql_object, arg_owner, ast_node); end

  def authorized_new(type, value, context, path); end

  def context(); end

  def continue_field(path, value, field, type, ast_node, next_selections, is_non_null, owner_object, arguments); end

  def continue_value(path, value, field, is_non_null, ast_node); end

  def dead_path?(path); end

  def directives_include?(node, graphql_object, parent_type); end

  def evaluate_selections(path, scoped_context, owner_object, owner_type, selections, root_operation_type: T.unsafe(nil)); end

  def final_value(); end

  def gather_selections(owner_object, owner_type, selections, selections_by_name); end

  def initialize(query:, response:); end

  def query(); end

  def resolve_type(type, value, path); end

  def resolve_with_directives(object, ast_node); end

  def run_directive(object, ast_node, idx); end

  def run_eager(); end

  def schema(); end

  def set_type_at_path(path, type); end

  def type_at(path); end

  def write_execution_errors_in_response(path, errors); end

  def write_in_response(path, value); end

  def write_invalid_null_in_response(path, invalid_null_error); end
  HALT = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Interpreter::Runtime
end

class GraphQL::Execution::Interpreter
  def self.begin_multiplex(multiplex); end

  def self.begin_query(query, multiplex); end

  def self.finish_multiplex(_results, multiplex); end

  def self.finish_query(query, _multiplex); end

  def self.use(schema_class); end
end

class GraphQL::Execution::Lazy
  def field(); end

  def initialize(path: T.unsafe(nil), field: T.unsafe(nil), &get_value_func); end

  def path(); end

  def value(); end
  NullResult = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Lazy::LazyMethodMap
  def each(&blk); end

  def get(value); end

  def initialize(use_concurrent: T.unsafe(nil)); end

  def set(lazy_class, lazy_value_method); end

  def storage(); end
end

class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  def []=(key, value); end

  def compute_if_absent(key); end

  def copy_storage(); end

  def each_pair(*args, &block); end

  def size(*args, &block); end
end

class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  extend ::Forwardable
end

class GraphQL::Execution::Lazy::LazyMethodMap
end

module GraphQL::Execution::Lazy::Resolve
end

module GraphQL::Execution::Lazy::Resolve::NullAccumulator
end

module GraphQL::Execution::Lazy::Resolve::NullAccumulator
  def self.<<(item); end

  def self.empty?(); end
end

module GraphQL::Execution::Lazy::Resolve
  def self.deep_sync(val); end

  def self.each_lazy(acc, value); end

  def self.resolve(value); end

  def self.resolve_in_place(value); end
end

class GraphQL::Execution::Lazy
  def self.all(lazies); end

  def self.resolve(val); end
end

class GraphQL::Execution::Lookahead
  def arguments(); end

  def ast_nodes(); end

  def field(); end

  def initialize(query:, ast_nodes:, field: T.unsafe(nil), root_type: T.unsafe(nil), owner_type: T.unsafe(nil)); end

  def name(); end

  def owner_type(); end

  def selected?(); end

  def selection(field_name, selected_type: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def selections(arguments: T.unsafe(nil)); end

  def selects?(field_name, arguments: T.unsafe(nil)); end
  NULL_LOOKAHEAD = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Lookahead::NullLookahead
  def initialize(); end

  def selection(*_); end

  def selections(*_); end

  def selects?(*_); end
end

class GraphQL::Execution::Lookahead::NullLookahead
end

class GraphQL::Execution::Lookahead
end

class GraphQL::Execution::Multiplex
  include ::GraphQL::Tracing::Traceable
  def context(); end

  def initialize(schema:, queries:, context:, max_complexity:); end

  def max_complexity(); end

  def queries(); end

  def schema(); end
  NO_OPERATION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Multiplex
  def self.run_all(schema, query_options, **kwargs); end

  def self.run_queries(schema, queries, context: T.unsafe(nil), max_complexity: T.unsafe(nil)); end
end

module GraphQL::Execution::Typecast
end

module GraphQL::Execution::Typecast
  def self.subtype?(parent_type, child_type); end
end

module GraphQL::Execution
end

class GraphQL::ExecutionError
  def ast_node(); end

  def ast_node=(ast_node); end

  def extensions(); end

  def extensions=(extensions); end

  def initialize(message, ast_node: T.unsafe(nil), options: T.unsafe(nil), extensions: T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def path(); end

  def path=(path); end

  def to_h(); end
end

class GraphQL::ExecutionError
end

class GraphQL::Field
  include ::GraphQL::Define::InstanceDefinable
  def arguments(); end

  def arguments=(arguments); end

  def arguments_class(); end

  def arguments_class=(arguments_class); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def complexity(); end

  def complexity=(complexity); end

  def connection=(connection); end

  def connection?(); end

  def connection_max_page_size(); end

  def connection_max_page_size=(connection_max_page_size); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(); end

  def description=(description); end

  def edge_class(); end

  def edge_class=(edge_class); end

  def edges?(); end

  def function(); end

  def function=(function); end

  def graphql_definition(); end

  def graphql_name(); end

  def hash_key(); end

  def hash_key=(new_hash_key); end

  def introspection=(introspection); end

  def introspection?(); end

  def lazy_resolve(obj, args, ctx); end

  def lazy_resolve=(new_lazy_resolve_proc); end

  def lazy_resolve_proc(); end

  def mutation(); end

  def mutation=(mutation); end

  def name(); end

  def name=(new_name); end

  def prepare_lazy(obj, args, ctx); end

  def property(); end

  def property=(new_property); end

  def relay_node_field(); end

  def relay_node_field=(relay_node_field); end

  def relay_nodes_field(); end

  def relay_nodes_field=(relay_nodes_field); end

  def resolve(object, arguments, context); end

  def resolve=(new_resolve_proc); end

  def resolve_proc(); end

  def subscription_scope(); end

  def subscription_scope=(subscription_scope); end

  def trace(); end

  def trace=(trace); end

  def type(); end

  def type=(new_return_type); end

  def type_class(); end
end

module GraphQL::Field::DefaultLazyResolve
end

module GraphQL::Field::DefaultLazyResolve
  def self.call(obj, args, ctx); end
end

module GraphQL::Field::Resolve
end

class GraphQL::Field::Resolve::BuiltInResolve
end

class GraphQL::Field::Resolve::BuiltInResolve
end

class GraphQL::Field::Resolve::HashKeyResolve
  def call(obj, args, ctx); end

  def initialize(hash_key); end
end

class GraphQL::Field::Resolve::HashKeyResolve
end

class GraphQL::Field::Resolve::MethodResolve
  def call(obj, args, ctx); end

  def initialize(field); end
end

class GraphQL::Field::Resolve::MethodResolve
end

class GraphQL::Field::Resolve::NameResolve
  def call(obj, args, ctx); end

  def initialize(field); end
end

class GraphQL::Field::Resolve::NameResolve
end

module GraphQL::Field::Resolve
  def self.create_proc(field); end
end

class GraphQL::Field
end

class GraphQL::Filter
  def call(member, ctx); end

  def initialize(only: T.unsafe(nil), except: T.unsafe(nil)); end

  def merge(only: T.unsafe(nil), except: T.unsafe(nil)); end
end

class GraphQL::Filter::MergedExcept
end

class GraphQL::Filter::MergedExcept
end

class GraphQL::Filter::MergedOnly
  def call(member, ctx); end

  def initialize(first, second); end
end

class GraphQL::Filter::MergedOnly
  def self.build(onlies); end
end

class GraphQL::Filter
end

class GraphQL::Function
  def arguments(); end

  def call(obj, args, ctx); end

  def complexity(); end

  def deprecation_reason(); end

  def description(); end

  def type(); end
end

class GraphQL::Function
  def self.argument(*args, **kwargs, &block); end

  def self.arguments(); end

  def self.build_field(function); end

  def self.complexity(new_value=T.unsafe(nil)); end

  def self.deprecation_reason(new_value=T.unsafe(nil)); end

  def self.description(new_value=T.unsafe(nil)); end

  def self.type(premade_type=T.unsafe(nil), &block); end

  def self.types(); end
end

class GraphQL::InputObjectType
  def arguments(); end

  def arguments=(arguments); end

  def arguments_class(); end

  def arguments_class=(arguments_class); end

  def coerce_result(value, ctx=T.unsafe(nil)); end

  def input_fields(); end

  def kind(); end

  def mutation(); end

  def mutation=(mutation); end
  INVALID_OBJECT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class GraphQL::InputObjectType
end

class GraphQL::IntegerEncodingError
  def initialize(value); end

  def integer_value(); end
end

class GraphQL::IntegerEncodingError
end

class GraphQL::InterfaceType
  def all_fields(); end

  def fields(); end

  def fields=(fields); end

  def get_field(field_name); end

  def get_possible_type(type_name, ctx); end

  def kind(); end

  def orphan_types(); end

  def orphan_types=(orphan_types); end

  def possible_type?(type, ctx); end

  def resolve_type=(resolve_type_callable); end

  def resolve_type_proc(); end

  def resolve_type_proc=(resolve_type_proc); end
end

class GraphQL::InterfaceType
end

module GraphQL::InternalRepresentation
end

class GraphQL::InternalRepresentation::Document
  def [](key); end

  def each(&block); end

  def fragment_definitions(); end

  def operation_definitions(); end
end

class GraphQL::InternalRepresentation::Document
end

class GraphQL::InternalRepresentation::Node
  def ==(other); end

  def arguments(); end

  def ast_node(); end

  def ast_nodes(); end

  def deep_merge_node(new_parent, scope: T.unsafe(nil), merge_self: T.unsafe(nil)); end

  def definition(); end

  def definition_name(); end

  def definitions(); end

  def initialize(name:, owner_type:, query:, return_type:, parent:, ast_nodes: T.unsafe(nil), definitions: T.unsafe(nil)); end

  def name(); end

  def owner_type(); end

  def owner_type=(owner_type); end

  def parent(); end

  def parent=(parent); end

  def query(); end

  def return_type(); end

  def scoped_children(); end

  def subscription_topic(); end

  def typed_children(); end
  DEFAULT_TYPED_CHILDREN = ::T.let(nil, ::T.untyped)
  NO_TYPED_CHILDREN = ::T.let(nil, ::T.untyped)
end

class GraphQL::InternalRepresentation::Node
end

module GraphQL::InternalRepresentation::Print
end

module GraphQL::InternalRepresentation::Print
  def self.print(schema, query_string); end

  def self.print_node(node, indent: T.unsafe(nil)); end
end

module GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::Language
  def initialize(*_); end

  def on_field(ast_node, ast_parent); end

  def on_fragment_definition(ast_node, parent); end

  def on_fragment_spread(ast_node, ast_parent); end

  def on_inline_fragment(node, parent); end

  def on_operation_definition(ast_node, parent); end

  def operations(); end

  def push_root_node(ast_node, definitions); end

  def rewrite_document(); end

  def skip?(ast_node); end
  NO_DIRECTIVES = ::T.let(nil, ::T.untyped)
end

module GraphQL::InternalRepresentation::Rewrite
end

class GraphQL::InternalRepresentation::Scope
  def each(&blk); end

  def enter(other_type_defn); end

  def initialize(query, type_defn); end
  NO_TYPES = ::T.let(nil, ::T.untyped)
end

class GraphQL::InternalRepresentation::Scope
end

module GraphQL::InternalRepresentation::Visit
end

module GraphQL::InternalRepresentation::Visit
  def self.each_node(node); end

  def self.visit_each_node(operations, handlers); end
end

module GraphQL::InternalRepresentation
end

module GraphQL::Introspection
  INTROSPECTION_QUERY = ::T.let(nil, ::T.untyped)
end

class GraphQL::Introspection::BaseObject
end

class GraphQL::Introspection::BaseObject
end

class GraphQL::Introspection::DirectiveLocationEnum
end

class GraphQL::Introspection::DirectiveLocationEnum
end

class GraphQL::Introspection::DirectiveType
  def args(); end
end

class GraphQL::Introspection::DirectiveType
end

class GraphQL::Introspection::DynamicFields
  def __typename(irep_node: T.unsafe(nil)); end
end

class GraphQL::Introspection::DynamicFields
end

class GraphQL::Introspection::EntryPoints
  def __schema(); end

  def __type(name:); end
end

class GraphQL::Introspection::EntryPoints
end

class GraphQL::Introspection::EnumValueType
  def is_deprecated(); end

  def name(); end
end

class GraphQL::Introspection::EnumValueType
end

class GraphQL::Introspection::FieldType
  def args(); end

  def is_deprecated(); end
end

class GraphQL::Introspection::FieldType
end

class GraphQL::Introspection::InputValueType
  def default_value(); end
end

class GraphQL::Introspection::InputValueType
end

class GraphQL::Introspection::SchemaType
  def directives(); end

  def mutation_type(); end

  def query_type(); end

  def subscription_type(); end

  def types(); end
end

class GraphQL::Introspection::SchemaType
end

class GraphQL::Introspection::TypeKindEnum
end

class GraphQL::Introspection::TypeKindEnum
end

class GraphQL::Introspection::TypeType
  def enum_values(include_deprecated:); end

  def fields(include_deprecated:); end

  def input_fields(); end

  def interfaces(); end

  def kind(); end

  def name(); end

  def of_type(); end

  def possible_types(); end
end

class GraphQL::Introspection::TypeType
end

module GraphQL::Introspection
end

class GraphQL::InvalidNameError
  def initialize(name, valid_regex); end

  def name(); end

  def valid_regex(); end
end

class GraphQL::InvalidNameError
end

class GraphQL::InvalidNullError
  def field(); end

  def initialize(parent_type, field, value); end

  def parent_error?(); end

  def parent_type(); end

  def to_h(); end

  def value(); end
end

class GraphQL::InvalidNullError
end

module GraphQL::Language
end

module GraphQL::Language::BlockString
end

module GraphQL::Language::BlockString
  def self.break_line(line, length); end

  def self.print(str, indent: T.unsafe(nil)); end

  def self.trim_whitespace(str); end
end

module GraphQL::Language::DefinitionSlice
  def slice(document, name); end
end

class GraphQL::Language::DefinitionSlice::DependencyVisitor
  def initialize(doc, definitions, names); end
end

class GraphQL::Language::DefinitionSlice::DependencyVisitor
  def self.find_definition_dependencies(definitions, name, names); end
end

module GraphQL::Language::DefinitionSlice
  extend ::GraphQL::Language::DefinitionSlice
end

class GraphQL::Language::DocumentFromSchemaDefinition
  def build_argument_node(argument); end

  def build_argument_nodes(arguments); end

  def build_default_value(default_value, type); end

  def build_definition_nodes(); end

  def build_directive_location_node(location); end

  def build_directive_location_nodes(locations); end

  def build_directive_node(directive); end

  def build_directive_nodes(directives); end

  def build_enum_type_node(enum_type); end

  def build_enum_value_node(enum_value); end

  def build_field_node(field); end

  def build_field_nodes(fields); end

  def build_input_object_node(input_object); end

  def build_interface_type_node(interface_type); end

  def build_object_type_node(object_type); end

  def build_scalar_type_node(scalar_type); end

  def build_schema_node(); end

  def build_type_definition_node(type); end

  def build_type_definition_nodes(types); end

  def build_type_name_node(type); end

  def build_union_type_node(union_type); end

  def document(); end

  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), include_introspection_types: T.unsafe(nil), include_built_in_directives: T.unsafe(nil), include_built_in_scalars: T.unsafe(nil), always_include_schema: T.unsafe(nil)); end
end

class GraphQL::Language::DocumentFromSchemaDefinition
end

module GraphQL::Language::Generation
  def generate(node, indent: T.unsafe(nil), printer: T.unsafe(nil)); end
end

module GraphQL::Language::Generation
  extend ::GraphQL::Language::Generation
end

module GraphQL::Language::Lexer
  ESCAPES = ::T.let(nil, ::T.untyped)
  ESCAPES_REPLACE = ::T.let(nil, ::T.untyped)
  PACK_DIRECTIVE = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
  UTF_8_ENCODING = ::T.let(nil, ::T.untyped)
  UTF_8_REPLACE = ::T.let(nil, ::T.untyped)
  VALID_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Language::Lexer
  def self.emit(token_name, ts, te, meta, token_value=T.unsafe(nil)); end

  def self.emit_string(ts, te, meta, block:); end

  def self.graphql_lexer_en_main(); end

  def self.graphql_lexer_en_main=(graphql_lexer_en_main); end

  def self.graphql_lexer_en_str(); end

  def self.graphql_lexer_en_str=(graphql_lexer_en_str); end

  def self.graphql_lexer_error(); end

  def self.graphql_lexer_error=(graphql_lexer_error); end

  def self.graphql_lexer_first_final(); end

  def self.graphql_lexer_first_final=(graphql_lexer_first_final); end

  def self.graphql_lexer_start(); end

  def self.graphql_lexer_start=(graphql_lexer_start); end

  def self.record_comment(ts, te, meta); end

  def self.replace_escaped_characters_in_place(raw_string); end

  def self.run_lexer(query_string); end

  def self.tokenize(query_string); end
end

module GraphQL::Language::Nodes
end

class GraphQL::Language::Nodes::AbstractNode
  def children(); end

  def children_method_name(); end

  def col(); end

  def delete_child(previous_child); end

  def eql?(other); end

  def filename(); end

  def initialize(options=T.unsafe(nil)); end

  def line(); end

  def merge(new_options); end

  def merge!(new_options); end

  def position(); end

  def replace_child(previous_child, new_child); end

  def scalars(); end

  def to_query_string(printer: T.unsafe(nil)); end
  NO_CHILDREN = ::T.let(nil, ::T.untyped)
end

module GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def definition_line(); end

  def initialize(options=T.unsafe(nil)); end
end

module GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end

class GraphQL::Language::Nodes::AbstractNode
  def self.inherited(child_class); end
end

class GraphQL::Language::Nodes::Argument
  def initialize_node(name: T.unsafe(nil), value: T.unsafe(nil)); end

  def name(); end

  def value(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::Argument
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::Directive
  def arguments(); end

  def initialize_node(name: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::Directive
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::DirectiveDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def arguments(); end

  def description(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), locations: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def locations(); end

  def merge_argument(node_opts); end

  def merge_location(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::DirectiveDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::DirectiveLocation
end

class GraphQL::Language::Nodes::DirectiveLocation
end

class GraphQL::Language::Nodes::Document
  def definitions(); end

  def initialize_node(definitions: T.unsafe(nil)); end

  def slice_definition(name); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::Document
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::Enum
end

class GraphQL::Language::Nodes::Enum
end

class GraphQL::Language::Nodes::EnumTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_value(node_opts); end

  def name(); end

  def values(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::EnumTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::EnumTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_value(node_opts); end

  def name(); end

  def values(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::EnumTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::EnumValueDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::EnumValueDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::Field
  def alias(); end

  def arguments(); end

  def directives(); end

  def initialize_node(attributes); end

  def merge_argument(node_opts); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def name(); end

  def selections(); end

  def visit_method(); end
  NONE = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::Nodes::Field
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::FieldDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def arguments(); end

  def description(); end

  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def merge_directive(node_opts); end

  def name(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::FieldDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::FragmentDefinition
  def directives(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def name(); end

  def selections(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::FragmentDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::FragmentSpread
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::FragmentSpread
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InlineFragment
  def directives(); end

  def initialize_node(type: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def selections(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InlineFragment
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputObject
  def arguments(); end

  def initialize_node(arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def to_h(options=T.unsafe(nil)); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputObject
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputValueDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def default_value(); end

  def description(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputValueDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ListType
end

class GraphQL::Language::Nodes::ListType
end

class GraphQL::Language::Nodes::NameOnlyNode
  def initialize_node(name: T.unsafe(nil)); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::NameOnlyNode
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::NonNullType
end

class GraphQL::Language::Nodes::NonNullType
end

class GraphQL::Language::Nodes::NullValue
end

class GraphQL::Language::Nodes::NullValue
end

class GraphQL::Language::Nodes::ObjectTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def interfaces(); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ObjectTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ObjectTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def interfaces(); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ObjectTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::OperationDefinition
  def directives(); end

  def initialize_node(operation_type: T.unsafe(nil), name: T.unsafe(nil), variables: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def merge_variable(node_opts); end

  def name(); end

  def operation_type(); end

  def selections(); end

  def variables(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::OperationDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ScalarTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ScalarTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::SchemaDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def directives(); end

  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def mutation(); end

  def query(); end

  def subscription(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::SchemaDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::SchemaExtension
  def directives(); end

  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def mutation(); end

  def query(); end

  def subscription(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::SchemaExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::TypeName
end

class GraphQL::Language::Nodes::TypeName
end

class GraphQL::Language::Nodes::UnionTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def types(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::UnionTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::UnionTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def types(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::UnionTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::VariableDefinition
  def default_value(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil)); end

  def name(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::VariableDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::VariableIdentifier
end

class GraphQL::Language::Nodes::VariableIdentifier
end

class GraphQL::Language::Nodes::WrapperType
  def initialize_node(of_type: T.unsafe(nil)); end

  def of_type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::WrapperType
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

module GraphQL::Language::Nodes
end

class GraphQL::Language::Parser
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_132(val, _values, result); end

  def _reduce_133(val, _values, result); end

  def _reduce_134(val, _values, result); end

  def _reduce_135(val, _values, result); end

  def _reduce_136(val, _values, result); end

  def _reduce_137(val, _values, result); end

  def _reduce_138(val, _values, result); end

  def _reduce_139(val, _values, result); end

  def _reduce_140(val, _values, result); end

  def _reduce_141(val, _values, result); end

  def _reduce_142(val, _values, result); end

  def _reduce_143(val, _values, result); end

  def _reduce_144(val, _values, result); end

  def _reduce_148(val, _values, result); end

  def _reduce_149(val, _values, result); end

  def _reduce_150(val, _values, result); end

  def _reduce_152(val, _values, result); end

  def _reduce_153(val, _values, result); end

  def _reduce_154(val, _values, result); end

  def _reduce_155(val, _values, result); end

  def _reduce_156(val, _values, result); end

  def _reduce_157(val, _values, result); end

  def _reduce_158(val, _values, result); end

  def _reduce_159(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_160(val, _values, result); end

  def _reduce_161(val, _values, result); end

  def _reduce_162(val, _values, result); end

  def _reduce_163(val, _values, result); end

  def _reduce_164(val, _values, result); end

  def _reduce_165(val, _values, result); end

  def _reduce_166(val, _values, result); end

  def _reduce_167(val, _values, result); end

  def _reduce_168(val, _values, result); end

  def _reduce_169(val, _values, result); end

  def _reduce_170(val, _values, result); end

  def _reduce_171(val, _values, result); end

  def _reduce_172(val, _values, result); end

  def _reduce_173(val, _values, result); end

  def _reduce_174(val, _values, result); end

  def _reduce_175(val, _values, result); end

  def _reduce_176(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(query_string, filename:, tracer: T.unsafe(nil)); end

  def parse_document(); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::Parser
  def self.parse(query_string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end
end

class GraphQL::Language::Printer
  def print(node, indent: T.unsafe(nil)); end

  def print_argument(argument); end

  def print_arguments(arguments, indent: T.unsafe(nil)); end

  def print_description(node, indent: T.unsafe(nil), first_in_block: T.unsafe(nil)); end

  def print_directive(directive); end

  def print_directive_definition(directive); end

  def print_directives(directives); end

  def print_document(document); end

  def print_enum(enum); end

  def print_enum_type_definition(enum_type); end

  def print_enum_value_definition(enum_value); end

  def print_field(field, indent: T.unsafe(nil)); end

  def print_field_definition(field); end

  def print_field_definitions(fields); end

  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end

  def print_fragment_spread(fragment_spread, indent: T.unsafe(nil)); end

  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end

  def print_input_object(input_object); end

  def print_input_object_type_definition(input_object_type); end

  def print_input_value_definition(input_value); end

  def print_interface_type_definition(interface_type); end

  def print_list_type(list_type); end

  def print_node(node, indent: T.unsafe(nil)); end

  def print_non_null_type(non_null_type); end

  def print_null_value(); end

  def print_object_type_definition(object_type); end

  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end

  def print_scalar_type_definition(scalar_type); end

  def print_schema_definition(schema); end

  def print_selections(selections, indent: T.unsafe(nil)); end

  def print_type_name(type_name); end

  def print_union_type_definition(union_type); end

  def print_variable_definition(variable_definition); end

  def print_variable_identifier(variable_identifier); end
end

class GraphQL::Language::Printer
end

class GraphQL::Language::SanitizedPrinter
  def initialize(query); end

  def print_variable_identifier(variable_id); end

  def sanitized_query_string(); end
  REDACTED = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::SanitizedPrinter
end

class GraphQL::Language::Token
  def col(); end

  def initialize(name, value, line, col, prev_token); end

  def line(); end

  def line_and_column(); end

  def name(); end

  def prev_token(); end

  def to_f(); end

  def to_i(); end

  def value(); end
end

class GraphQL::Language::Token
end

class GraphQL::Language::Visitor
  def [](node_class); end

  def initialize(document); end

  def on_abstract_node(node, parent); end

  def on_argument(node, parent); end

  def on_directive(node, parent); end

  def on_directive_definition(node, parent); end

  def on_directive_location(node, parent); end

  def on_document(node, parent); end

  def on_enum(node, parent); end

  def on_enum_type_definition(node, parent); end

  def on_enum_type_extension(node, parent); end

  def on_enum_value_definition(node, parent); end

  def on_field(node, parent); end

  def on_field_definition(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end

  def on_input_object(node, parent); end

  def on_input_object_type_definition(node, parent); end

  def on_input_object_type_extension(node, parent); end

  def on_input_value_definition(node, parent); end

  def on_interface_type_definition(node, parent); end

  def on_interface_type_extension(node, parent); end

  def on_list_type(node, parent); end

  def on_non_null_type(node, parent); end

  def on_null_value(node, parent); end

  def on_object_type_definition(node, parent); end

  def on_object_type_extension(node, parent); end

  def on_operation_definition(node, parent); end

  def on_scalar_type_definition(node, parent); end

  def on_scalar_type_extension(node, parent); end

  def on_schema_definition(node, parent); end

  def on_schema_extension(node, parent); end

  def on_type_name(node, parent); end

  def on_union_type_definition(node, parent); end

  def on_union_type_extension(node, parent); end

  def on_variable_definition(node, parent); end

  def on_variable_identifier(node, parent); end

  def result(); end

  def visit(); end

  def visit_node(node, parent); end
  DELETE_NODE = ::T.let(nil, ::T.untyped)
  SKIP = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::Visitor
  def self.apply_hooks(hooks, node, parent); end

  def self.make_visit_method(node_method); end
end

module GraphQL::Language
  def self.serialize(value); end
end

class GraphQL::ListType
  include ::GraphQL::BaseType::ModifiesAnotherType
  def coerce_result(value, ctx=T.unsafe(nil)); end

  def initialize(of_type:); end

  def kind(); end

  def of_type(); end
end

class GraphQL::ListType
end

class GraphQL::LoadApplicationObjectFailedError
  def argument(); end

  def id(); end

  def initialize(argument:, id:, object:); end

  def object(); end
end

class GraphQL::LoadApplicationObjectFailedError
end

class GraphQL::NameValidator
  VALID_NAME_REGEX = ::T.let(nil, ::T.untyped)
end

class GraphQL::NameValidator
  def self.valid?(name); end

  def self.validate!(name); end
end

class GraphQL::NonNullType
  include ::GraphQL::BaseType::ModifiesAnotherType
  def coerce_input(*args, &block); end

  def coerce_result(*args, &block); end

  def initialize(of_type:); end

  def kind(); end

  def list?(*args, &block); end

  def of_type(); end

  def valid_input?(value, ctx); end

  def validate_input(value, ctx); end
end

class GraphQL::NonNullType
  extend ::Forwardable
end

class GraphQL::ObjectType
  def all_fields(); end

  def dirty_inherited_interfaces(); end

  def dirty_interfaces(); end

  def fields(); end

  def fields=(fields); end

  def get_field(field_name); end

  def implements(interfaces, inherit: T.unsafe(nil)); end

  def interfaces(); end

  def interfaces=(new_interfaces); end

  def kind(); end

  def mutation(); end

  def mutation=(mutation); end

  def relay_node_type(); end

  def relay_node_type=(relay_node_type); end

  def resolve_type_proc(); end
end

class GraphQL::ObjectType
end

module GraphQL::Pagination
end

class GraphQL::Pagination::ActiveRecordRelationConnection
end

class GraphQL::Pagination::ActiveRecordRelationConnection
end

class GraphQL::Pagination::ArrayConnection
end

class GraphQL::Pagination::ArrayConnection
end

class GraphQL::Pagination::Connection
  def after(); end

  def after_value(); end

  def after_value=(after_value); end

  def before(); end

  def before_value(); end

  def before_value=(before_value); end

  def context(); end

  def context=(context); end

  def cursor_for(item); end

  def edge_nodes(); end

  def edges(); end

  def end_cursor(); end

  def first(); end

  def first=(first); end

  def first_value(); end

  def first_value=(first_value); end

  def has_next_page(); end

  def has_previous_page(); end

  def initialize(items, context: T.unsafe(nil), first: T.unsafe(nil), after: T.unsafe(nil), max_page_size: T.unsafe(nil), last: T.unsafe(nil), before: T.unsafe(nil)); end

  def items(); end

  def last(); end

  def last=(last); end

  def last_value(); end

  def last_value=(last_value); end

  def max_page_size(); end

  def max_page_size=(max_page_size); end

  def nodes(); end

  def page_info(); end

  def start_cursor(); end
end

class GraphQL::Pagination::Connection::Edge
  def cursor(); end

  def initialize(item, connection); end

  def node(); end
end

class GraphQL::Pagination::Connection::Edge
end

class GraphQL::Pagination::Connection::PaginationImplementationMissingError
end

class GraphQL::Pagination::Connection::PaginationImplementationMissingError
end

class GraphQL::Pagination::Connection
  def self.edge_class(); end
end

class GraphQL::Pagination::Connections
  def add(nodes_class, implementation); end

  def all_wrappers(); end

  def delete(nodes_class); end

  def initialize(schema:); end

  def wrap(field, object, arguments, context, wrappers: T.unsafe(nil)); end

  def wrappers(); end
end

class GraphQL::Pagination::Connections::ImplementationMissingError
end

class GraphQL::Pagination::Connections::ImplementationMissingError
end

class GraphQL::Pagination::Connections
  def self.use(schema_defn); end
end

class GraphQL::Pagination::MongoidRelationConnection
end

class GraphQL::Pagination::MongoidRelationConnection
end

class GraphQL::Pagination::RelationConnection
end

class GraphQL::Pagination::RelationConnection
end

class GraphQL::Pagination::SequelDatasetConnection
end

class GraphQL::Pagination::SequelDatasetConnection
end

module GraphQL::Pagination
end

class GraphQL::ParseError
  def col(); end

  def initialize(message, line, col, query, filename: T.unsafe(nil)); end

  def line(); end

  def query(); end

  def to_h(); end
end

class GraphQL::ParseError
end

class GraphQL::Query
  include ::GraphQL::Tracing::Traceable
  def analysis_errors(); end

  def analysis_errors=(analysis_errors); end

  def analyzers(*args, &block); end

  def arguments_for(ast_node, definition, parent_object: T.unsafe(nil)); end

  def ast_analyzers(*args, &block); end

  def context(); end

  def document(); end

  def executed?(); end

  def fragments(); end

  def get_field(*args, &block); end

  def get_type(*args, &block); end

  def initialize(schema, query_string=T.unsafe(nil), query: T.unsafe(nil), document: T.unsafe(nil), context: T.unsafe(nil), variables: T.unsafe(nil), validate: T.unsafe(nil), subscription_topic: T.unsafe(nil), operation_name: T.unsafe(nil), root_value: T.unsafe(nil), max_depth: T.unsafe(nil), max_complexity: T.unsafe(nil), except: T.unsafe(nil), only: T.unsafe(nil), warden: T.unsafe(nil)); end

  def internal_representation(*args, &block); end

  def interpreter?(*args, &block); end

  def irep_selection(); end

  def lookahead(); end

  def max_complexity(*args, &block); end

  def max_depth(*args, &block); end

  def merge_filters(only: T.unsafe(nil), except: T.unsafe(nil)); end

  def mutation?(); end

  def operation_name(); end

  def operation_name=(operation_name); end

  def operations(); end

  def possible_types(*args, &block); end

  def provided_variables(); end

  def query?(); end

  def query_string(); end

  def query_string=(query_string); end

  def resolve_type(abstract_type, value=T.unsafe(nil)); end

  def result(); end

  def result_values(); end

  def result_values=(result_hash); end

  def root_type_for_operation(*args, &block); end

  def root_value(); end

  def root_value=(root_value); end

  def sanitized_query_string(); end

  def schema(); end

  def selected_operation(); end

  def selected_operation_name(); end

  def static_errors(); end

  def subscription?(); end

  def subscription_topic(); end

  def subscription_update?(); end

  def tracers(); end

  def valid?(); end

  def validate(); end

  def validate=(validate); end

  def validation_errors(*args, &block); end

  def validation_pipeline(); end

  def variables(); end

  def warden(); end

  def with_error_handling(); end
end

class GraphQL::Query::Arguments
  include ::GraphQL::Dig
  def [](key); end

  def any?(*args, &block); end

  def argument_values(); end

  def default_used?(key); end

  def each(*args, &block); end

  def each_value(); end

  def initialize(values, context:, defaults_used:); end

  def key?(key); end

  def keys(*args, &block); end

  def prepare(); end

  def to_h(); end

  def to_hash(); end

  def to_kwargs(); end

  def values(*args, &block); end
  NO_ARGS = ::T.let(nil, ::T.untyped)
  NULL_ARGUMENT_VALUE = ::T.let(nil, ::T.untyped)
end

class GraphQL::Query::Arguments::ArgumentValue
  def default_used=(default_used); end

  def default_used?(); end

  def definition(); end

  def initialize(key, value, definition, default_used); end

  def key(); end

  def value(); end
end

class GraphQL::Query::Arguments::ArgumentValue
end

class GraphQL::Query::Arguments::NoArguments
end

class GraphQL::Query::Arguments::NoArguments
end

class GraphQL::Query::Arguments
  extend ::Forwardable
  def self.argument_definitions(); end

  def self.argument_definitions=(argument_definitions); end

  def self.argument_owner(); end

  def self.argument_owner=(argument_owner); end

  def self.construct_arguments_class(argument_owner); end
end

module GraphQL::Query::ArgumentsCache
end

module GraphQL::Query::ArgumentsCache
  def self.build(query); end
end

class GraphQL::Query::Context
  include ::GraphQL::Query::Context::SharedMethods
  def [](key); end

  def []=(*args, &block); end

  def ast_node(); end

  def dig(*args, &block); end

  def errors(); end

  def execution_strategy(); end

  def execution_strategy=(new_strategy); end

  def fetch(*args, &block); end

  def initialize(query:, values:, object:, schema: T.unsafe(nil)); end

  def interpreter=(interpreter); end

  def interpreter?(*args, &block); end

  def irep_node(); end

  def key?(key); end

  def namespace(ns); end

  def path(); end

  def query(); end

  def received_null_child(); end

  def schema(); end

  def scoped_context(); end

  def scoped_context=(scoped_context); end

  def scoped_merge!(hash); end

  def scoped_set!(key, value); end

  def strategy(); end

  def to_h(); end

  def to_hash(); end

  def trace(*args, &block); end

  def value=(value); end

  def warden(); end
end

class GraphQL::Query::Context::ExecutionErrors
  def >>(err_or_msg); end

  def add(err_or_msg); end

  def initialize(ctx); end

  def push(err_or_msg); end
end

class GraphQL::Query::Context::ExecutionErrors
end

class GraphQL::Query::Context::FieldResolutionContext
  include ::GraphQL::Query::Context::SharedMethods
  include ::GraphQL::Tracing::Traceable
  def [](*args, &block); end

  def []=(*args, &block); end

  def ast_node(); end

  def dig(*args, &block); end

  def errors(*args, &block); end

  def execution_strategy(*args, &block); end

  def fetch(*args, &block); end

  def field(); end

  def initialize(context, key, irep_node, parent, object); end

  def interpreter?(*args, &block); end

  def irep_node(); end

  def key(); end

  def key?(*args, &block); end

  def namespace(*args, &block); end

  def parent(); end

  def parent_type(); end

  def path(); end

  def query(); end

  def received_null_child(); end

  def schema(); end

  def selection(); end

  def spawn(*args, &block); end

  def strategy(*args, &block); end

  def to_h(*args, &block); end

  def type(); end

  def value=(new_value); end

  def warden(*args, &block); end

  def wrapped_connection(); end

  def wrapped_connection=(wrapped_connection); end

  def wrapped_object(); end

  def wrapped_object=(wrapped_object); end
end

class GraphQL::Query::Context::FieldResolutionContext
  extend ::Forwardable
end

module GraphQL::Query::Context::SharedMethods
  def add_error(error); end

  def backtrace(); end

  def delete(child_ctx); end

  def execution_errors(); end

  def invalid_null?(); end

  def lookahead(); end

  def object(); end

  def object=(object); end

  def skip(); end

  def skipped(); end

  def skipped=(skipped); end

  def skipped?(); end

  def spawn_child(key:, irep_node:, object:); end

  def value(); end
end

module GraphQL::Query::Context::SharedMethods
end

class GraphQL::Query::Context
  extend ::Forwardable
end

class GraphQL::Query::Executor
  def initialize(query); end

  def query(); end

  def result(); end
end

class GraphQL::Query::Executor::PropagateNull
end

class GraphQL::Query::Executor::PropagateNull
end

class GraphQL::Query::Executor
end

class GraphQL::Query::InputValidationResult
  def add_problem(explanation, path=T.unsafe(nil), extensions: T.unsafe(nil), message: T.unsafe(nil)); end

  def initialize(valid: T.unsafe(nil), problems: T.unsafe(nil)); end

  def merge_result!(path, inner_result); end

  def problems(); end

  def problems=(problems); end

  def valid?(); end
end

class GraphQL::Query::InputValidationResult
end

class GraphQL::Query::LiteralInput
end

class GraphQL::Query::LiteralInput
  def self.coerce(type, ast_node, variables); end

  def self.from_arguments(ast_arguments, argument_owner, variables); end
end

class GraphQL::Query::NullContext
  def [](key); end

  def interpreter?(); end

  def query(); end

  def schema(); end

  def warden(); end
end

class GraphQL::Query::NullContext::NullWarden
  def visible?(t); end

  def visible_field?(t); end

  def visible_type?(t); end
end

class GraphQL::Query::NullContext::NullWarden
end

class GraphQL::Query::NullContext
  def self.[](key); end

  def self.instance(); end

  def self.interpreter?(*args, &block); end

  def self.query(*args, &block); end

  def self.schema(*args, &block); end

  def self.warden(*args, &block); end
end

class GraphQL::Query::OperationNameMissingError
  def initialize(name); end
end

class GraphQL::Query::OperationNameMissingError
end

class GraphQL::Query::Result
  def ==(other); end

  def [](*args, &block); end

  def as_json(*args, &block); end

  def context(*args, &block); end

  def initialize(query:, values:); end

  def keys(*args, &block); end

  def method_missing(method_name, *args, &block); end

  def mutation?(*args, &block); end

  def query(); end

  def query?(*args, &block); end

  def subscription?(*args, &block); end

  def to_h(); end

  def to_json(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Query::Result
  extend ::Forwardable
end

class GraphQL::Query::SerialExecution
  def execute(ast_operation, root_type, query_object); end

  def field_resolution(); end

  def operation_resolution(); end

  def selection_resolution(); end
end

class GraphQL::Query::SerialExecution::FieldResolution
  def arguments(); end

  def execution_context(); end

  def field(); end

  def initialize(selection, parent_type, target, query_ctx); end

  def irep_node(); end

  def parent_type(); end

  def query(); end

  def result(); end

  def target(); end
end

class GraphQL::Query::SerialExecution::FieldResolution
end

module GraphQL::Query::SerialExecution::OperationResolution
end

module GraphQL::Query::SerialExecution::OperationResolution
  def self.resolve(selection, target, query); end
end

module GraphQL::Query::SerialExecution::SelectionResolution
end

module GraphQL::Query::SerialExecution::SelectionResolution
  def self.resolve(target, current_type, selection, query_ctx); end
end

module GraphQL::Query::SerialExecution::ValueResolution
end

module GraphQL::Query::SerialExecution::ValueResolution
  def self.resolve(parent_type, field_defn, field_type, value, selection, query_ctx); end
end

class GraphQL::Query::SerialExecution
end

class GraphQL::Query::ValidationPipeline
  def analyzers(); end

  def initialize(query:, validate:, parse_error:, operation_name_error:, max_depth:, max_complexity:); end

  def internal_representation(); end

  def max_complexity(); end

  def max_depth(); end

  def valid?(); end

  def validation_errors(); end
end

class GraphQL::Query::ValidationPipeline
end

class GraphQL::Query::VariableValidationError
  def initialize(variable_ast, type, value, validation_result); end

  def validation_result(); end

  def validation_result=(validation_result); end

  def value(); end

  def value=(value); end
end

class GraphQL::Query::VariableValidationError
end

class GraphQL::Query::Variables
  def [](*args, &block); end

  def context(); end

  def errors(); end

  def fetch(*args, &block); end

  def initialize(ctx, ast_variables, provided_variables); end

  def key?(*args, &block); end

  def length(*args, &block); end

  def to_h(*args, &block); end
end

class GraphQL::Query::Variables
  extend ::Forwardable
end

class GraphQL::Query
  extend ::Forwardable
end

class GraphQL::Railtie
end

class GraphQL::Railtie
end

module GraphQL::Relay
  PageInfo = ::T.let(nil, ::T.untyped)
end

class GraphQL::Relay::ArrayConnection
  def cursor_from_node(item); end
end

class GraphQL::Relay::ArrayConnection
end

class GraphQL::Relay::BaseConnection
  def after(); end

  def arguments(); end

  def before(); end

  def context(); end

  def cursor_from_node(object); end

  def decode(data); end

  def edge_nodes(); end

  def encode(data); end

  def end_cursor(); end

  def field(); end

  def first(); end

  def has_next_page(); end

  def has_previous_page(); end

  def initialize(nodes, arguments, field: T.unsafe(nil), max_page_size: T.unsafe(nil), parent: T.unsafe(nil), context: T.unsafe(nil)); end

  def last(); end

  def max_page_size(); end

  def nodes(); end

  def page_info(); end

  def parent(); end

  def start_cursor(); end
  CONNECTION_IMPLEMENTATIONS = ::T.let(nil, ::T.untyped)
  CURSOR_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class GraphQL::Relay::BaseConnection
  def self.connection_for_nodes(nodes); end

  def self.register_connection_implementation(nodes_class, connection_class); end
end

module GraphQL::Relay::ConnectionInstrumentation
end

module GraphQL::Relay::ConnectionInstrumentation
  def self.default_arguments(); end

  def self.instrument(type, field); end
end

class GraphQL::Relay::ConnectionResolve
  def call(obj, args, ctx); end

  def initialize(field, underlying_resolve); end
end

class GraphQL::Relay::ConnectionResolve
end

module GraphQL::Relay::ConnectionType
end

module GraphQL::Relay::ConnectionType
  def self.bidirectional_pagination(); end

  def self.bidirectional_pagination=(bidirectional_pagination); end

  def self.create_type(wrapped_type, edge_type: T.unsafe(nil), edge_class: T.unsafe(nil), nodes_field: T.unsafe(nil), &block); end

  def self.default_nodes_field(); end

  def self.default_nodes_field=(default_nodes_field); end
end

class GraphQL::Relay::Edge
  def connection(); end

  def cursor(); end

  def initialize(node, connection); end

  def node(); end

  def parent(); end
end

class GraphQL::Relay::Edge
end

module GraphQL::Relay::EdgeType
end

module GraphQL::Relay::EdgeType
  def self.create_type(wrapped_type, name: T.unsafe(nil), &block); end
end

module GraphQL::Relay::EdgesInstrumentation
end

class GraphQL::Relay::EdgesInstrumentation::EdgesResolve
  def call(obj, args, ctx); end

  def initialize(edge_class:, resolve:); end
end

class GraphQL::Relay::EdgesInstrumentation::EdgesResolve
end

module GraphQL::Relay::EdgesInstrumentation
  def self.instrument(type, field); end
end

class GraphQL::Relay::GlobalIdResolve
  def call(obj, args, ctx); end

  def initialize(type:); end
end

class GraphQL::Relay::GlobalIdResolve
end

class GraphQL::Relay::MongoRelationConnection
end

class GraphQL::Relay::MongoRelationConnection
end

class GraphQL::Relay::Mutation
  include ::GraphQL::Define::InstanceDefinable
  def arguments(); end

  def arguments=(arguments); end

  def description(); end

  def description=(description); end

  def field(); end

  def fields(); end

  def fields=(fields); end

  def has_generated_return_type?(); end

  def input_fields(); end

  def input_type(); end

  def name(); end

  def name=(name); end

  def resolve=(new_resolve_proc); end

  def result_class(); end

  def return_fields(); end

  def return_interfaces(); end

  def return_interfaces=(return_interfaces); end

  def return_type(); end

  def return_type=(return_type); end
end

module GraphQL::Relay::Mutation::Instrumentation
end

module GraphQL::Relay::Mutation::Instrumentation
  def self.instrument(type, field); end
end

class GraphQL::Relay::Mutation::Resolve
  def call(obj, args, ctx); end

  def initialize(mutation, resolve); end
end

class GraphQL::Relay::Mutation::Resolve
end

class GraphQL::Relay::Mutation::Result
  def client_mutation_id(); end

  def initialize(client_mutation_id:, result:); end
end

class GraphQL::Relay::Mutation::Result
  def self.define_subclass(mutation_defn); end

  def self.mutation(); end

  def self.mutation=(mutation); end
end

class GraphQL::Relay::Mutation
end

module GraphQL::Relay::Node
end

module GraphQL::Relay::Node
  def self.field(**kwargs, &block); end

  def self.interface(); end

  def self.plural_field(**kwargs, &block); end
end

class GraphQL::Relay::RangeAdd
  def connection(); end

  def edge(); end

  def initialize(collection:, item:, parent: T.unsafe(nil), context: T.unsafe(nil), edge_class: T.unsafe(nil)); end

  def parent(); end
end

class GraphQL::Relay::RangeAdd
end

class GraphQL::Relay::RelationConnection
  def cursor_from_node(item); end
end

class GraphQL::Relay::RelationConnection
end

module GraphQL::Relay::TypeExtensions
  def connection_type(); end

  def define_connection(**kwargs, &block); end

  def define_edge(**kwargs, &block); end

  def edge_type(); end
end

module GraphQL::Relay::TypeExtensions
end

module GraphQL::Relay
end

class GraphQL::RequiredImplementationMissingError
end

class GraphQL::RequiredImplementationMissingError
end

module GraphQL::Ruby2Keywords
  def ruby2_keywords(*_); end
end

module GraphQL::Ruby2Keywords
end

class GraphQL::RuntimeTypeError
end

class GraphQL::RuntimeTypeError
end

class GraphQL::ScalarType
  def coerce=(proc); end

  def coerce_input=(coerce_input_fn); end

  def coerce_result(value, ctx=T.unsafe(nil)); end

  def coerce_result=(coerce_result_fn); end

  def kind(); end
end

module GraphQL::ScalarType::NoOpCoerce
end

module GraphQL::ScalarType::NoOpCoerce
  def self.call(val, ctx); end
end

class GraphQL::ScalarType
end

class GraphQL::Schema
  include ::GraphQL::Define::InstanceDefinable
  def _schema_class(); end

  def accessible?(member, context); end

  def after_lazy(value); end

  def analysis_engine(); end

  def analysis_engine=(analysis_engine); end

  def as_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def call_on_type_class(member, method_name, context, default:); end

  def check_resolved_type(type, object, ctx=T.unsafe(nil)); end

  def connections(); end

  def connections=(connections); end

  def context_class(); end

  def context_class=(context_class); end

  def cursor_encoder(); end

  def cursor_encoder=(cursor_encoder); end

  def default_filter(); end

  def default_mask(); end

  def default_mask=(default_mask); end

  def default_max_page_size(); end

  def default_max_page_size=(default_max_page_size); end

  def directive(*args, &block); end

  def directives(); end

  def directives=(directives); end

  def disable_introspection_entry_points(); end

  def disable_introspection_entry_points=(disable_introspection_entry_points); end

  def disable_introspection_entry_points?(); end

  def disable_schema_introspection_entry_point(); end

  def disable_schema_introspection_entry_point=(disable_schema_introspection_entry_point); end

  def disable_schema_introspection_entry_point?(); end

  def disable_type_introspection_entry_point(); end

  def disable_type_introspection_entry_point=(disable_type_introspection_entry_point); end

  def disable_type_introspection_entry_point?(); end

  def error_bubbling(); end

  def error_bubbling=(error_bubbling); end

  def error_handler(*args, &block); end

  def execute(query_str=T.unsafe(nil), **kwargs); end

  def execution_strategy_for_operation(operation); end

  def find(path); end

  def get_field(parent_type, field_name); end

  def get_fields(type); end

  def get_type(type_name); end

  def graphql_definition(); end

  def id_from_object(object, type, ctx); end

  def id_from_object=(new_proc); end

  def id_from_object_proc(); end

  def inaccessible_fields(*args, &block); end

  def instrument(instrumentation_type, instrumenter); end

  def instrumenters(); end

  def instrumenters=(instrumenters); end

  def interpreter=(interpreter); end

  def interpreter?(); end

  def introspection_namespace(); end

  def introspection_namespace=(introspection_namespace); end

  def introspection_system(); end

  def lazy?(obj); end

  def lazy_method_name(obj); end

  def lazy_methods(); end

  def lazy_methods=(lazy_methods); end

  def max_complexity(); end

  def max_complexity=(max_complexity); end

  def max_depth(); end

  def max_depth=(max_depth); end

  def middleware(); end

  def middleware=(middleware); end

  def multiplex(queries, **kwargs); end

  def multiplex_analyzers(); end

  def multiplex_analyzers=(multiplex_analyzers); end

  def mutation(); end

  def mutation=(mutation); end

  def mutation_execution_strategy(); end

  def mutation_execution_strategy=(mutation_execution_strategy); end

  def new_connections?(); end

  def object_from_id(id, ctx); end

  def object_from_id=(new_proc); end

  def object_from_id_proc(); end

  def orphan_types(); end

  def orphan_types=(orphan_types); end

  def parse_error(err, ctx); end

  def parse_error=(new_proc); end

  def possible_types(type_defn, context=T.unsafe(nil)); end

  def query(); end

  def query=(query); end

  def query_analyzers(); end

  def query_analyzers=(query_analyzers); end

  def query_execution_strategy(); end

  def query_execution_strategy=(query_execution_strategy); end

  def raise_definition_error(); end

  def raise_definition_error=(raise_definition_error); end

  def references_to(type_name=T.unsafe(nil)); end

  def remove_handler(*args, &block); end

  def rescue_from(*args, &block); end

  def rescue_middleware(); end

  def rescues?(); end

  def resolve_type(type, object, ctx=T.unsafe(nil)); end

  def resolve_type=(new_resolve_type_proc); end

  def resolve_type_proc(); end

  def root_type_for_operation(operation); end

  def root_types(); end

  def static_validator(); end

  def subscription(); end

  def subscription=(subscription); end

  def subscription_execution_strategy(); end

  def subscription_execution_strategy=(subscription_execution_strategy); end

  def subscriptions(); end

  def subscriptions=(subscriptions); end

  def sync_lazy(value); end

  def to_definition(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def to_document(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def to_json(*args); end

  def tracers(); end

  def type_error(err, ctx); end

  def type_error=(new_proc); end

  def type_from_ast(ast_node, context:); end

  def types(); end

  def unauthorized_field(*args, &block); end

  def unauthorized_object(*args, &block); end

  def union_memberships(type); end

  def using_ast_analysis?(); end

  def validate(string_or_document, rules: T.unsafe(nil), context: T.unsafe(nil)); end

  def visible?(member, context); end
  BUILT_IN_TYPES = ::T.let(nil, ::T.untyped)
  DYNAMIC_FIELDS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Argument
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accessible?(context); end

  def authorized?(obj, value, ctx); end

  def authorized_as_type?(obj, value, ctx, as_type:); end

  def default_value(); end

  def default_value?(); end

  def description(text=T.unsafe(nil)); end

  def description=(description); end

  def from_resolver?(); end

  def graphql_name(); end

  def keyword(); end

  def loads(); end

  def name(); end

  def owner(); end

  def prepare(); end

  def prepare_value(obj, value, context: T.unsafe(nil)); end

  def type(); end

  def type=(type); end

  def visible?(context); end
  NO_DEFAULT = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Argument
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

module GraphQL::Schema::Base64Encoder
end

module GraphQL::Schema::Base64Encoder
  def self.decode(encoded_text, nonce: T.unsafe(nil)); end

  def self.encode(unencoded_text, nonce: T.unsafe(nil)); end
end

module GraphQL::Schema::BuildFromDefinition
end

GraphQL::Schema::BuildFromDefinition::DefaultParser = GraphQL::Language::Parser

class GraphQL::Schema::BuildFromDefinition::ResolveMap
  def call(type, field, obj, args, ctx); end

  def coerce_input(type, value, ctx); end

  def coerce_result(type, value, ctx); end

  def initialize(user_resolve_hash); end
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap::DefaultResolve
  def call(obj, args, ctx); end

  def initialize(field_map, field_name); end
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap::DefaultResolve
end

module GraphQL::Schema::BuildFromDefinition::ResolveMap::NullScalarCoerce
end

module GraphQL::Schema::BuildFromDefinition::ResolveMap::NullScalarCoerce
  def self.call(val, _ctx); end
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap
end

module GraphQL::Schema::BuildFromDefinition
  def self.from_definition(definition_string, default_resolve:, using: T.unsafe(nil), relay: T.unsafe(nil), interpreter: T.unsafe(nil), parser: T.unsafe(nil)); end
end

module GraphQL::Schema::CatchallMiddleware
  MESSAGE = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::CatchallMiddleware
  def self.call(parent_type, parent_object, field_definition, field_args, query_context); end
end

class GraphQL::Schema::CyclicalDefinitionError
end

class GraphQL::Schema::CyclicalDefinitionError
end

module GraphQL::Schema::DefaultParseError
end

module GraphQL::Schema::DefaultParseError
  def self.call(parse_error, ctx); end
end

module GraphQL::Schema::DefaultTypeError
end

module GraphQL::Schema::DefaultTypeError
  def self.call(type_error, ctx); end
end

class GraphQL::Schema::Directive
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  ARGUMENT_DEFINITION = ::T.let(nil, ::T.untyped)
  DEFAULT_DEPRECATION_REASON = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_VALUE = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FIELD_DEFINITION = ::T.let(nil, ::T.untyped)
  FRAGMENT_DEFINITION = ::T.let(nil, ::T.untyped)
  FRAGMENT_SPREAD = ::T.let(nil, ::T.untyped)
  INLINE_FRAGMENT = ::T.let(nil, ::T.untyped)
  INPUT_FIELD_DEFINITION = ::T.let(nil, ::T.untyped)
  INPUT_OBJECT = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  LOCATIONS = ::T.let(nil, ::T.untyped)
  LOCATION_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
  MUTATION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  SCALAR = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  SUBSCRIPTION = ::T.let(nil, ::T.untyped)
  UNION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Directive::Deprecated
end

class GraphQL::Schema::Directive::Deprecated
end

class GraphQL::Schema::Directive::Feature
end

class GraphQL::Schema::Directive::Feature
  def self.enabled?(flag_name, object, context); end

  def self.include?(object, arguments, context); end
end

class GraphQL::Schema::Directive::Include
end

class GraphQL::Schema::Directive::Include
  def self.static_include?(args, ctx); end
end

class GraphQL::Schema::Directive::Skip
end

class GraphQL::Schema::Directive::Skip
  def self.static_include?(args, ctx); end
end

class GraphQL::Schema::Directive::Transform
  TRANSFORMS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Directive::Transform
end

class GraphQL::Schema::Directive
  extend ::GraphQL::Schema::Member::HasArguments
  def self.default_directive(new_default_directive=T.unsafe(nil)); end

  def self.default_directive?(); end

  def self.include?(_object, arguments, context); end

  def self.locations(*new_locations); end

  def self.on_field?(); end

  def self.on_fragment?(); end

  def self.on_operation?(); end

  def self.resolve(object, arguments, context); end

  def self.static_include?(_arguments, _context); end
end

class GraphQL::Schema::DuplicateTypeNamesError
  def initialize(type_name:, first_definition:, second_definition:, path:); end
end

class GraphQL::Schema::DuplicateTypeNamesError
end

class GraphQL::Schema::Enum
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.coerce_input(value_name, ctx); end

  def self.coerce_result(value, ctx); end

  def self.enum_value_class(new_enum_value_class=T.unsafe(nil)); end

  def self.validate_non_null_input(value_name, ctx); end

  def self.values(); end
end

class GraphQL::Schema::EnumValue
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accessible?(_ctx); end

  def authorized?(_ctx); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(new_desc=T.unsafe(nil)); end

  def graphql_name(); end

  def owner(); end

  def value(new_val=T.unsafe(nil)); end

  def visible?(_ctx); end
end

class GraphQL::Schema::EnumValue
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

class GraphQL::Schema::Field
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accessible?(context); end

  def authorized?(object, args, context); end

  def complexity(new_complexity=T.unsafe(nil)); end

  def connection?(); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(text=T.unsafe(nil)); end

  def description=(description); end

  def extension(extension, options=T.unsafe(nil)); end

  def extensions(new_extensions=T.unsafe(nil)); end

  def extras(new_extras=T.unsafe(nil)); end

  def fetch_extra(extra_name, ctx); end

  def graphql_name(); end

  def max_page_size(); end

  def method_conflict_warning?(); end

  def method_str(); end

  def method_sym(); end

  def mutation(); end

  def name(); end

  def original_name(); end

  def owner(); end

  def owner=(owner); end

  def relay_node_field(); end

  def resolve(object, args, ctx); end

  def resolve_field(obj, args, ctx); end

  def resolve_field_method(obj, ruby_kwargs, ctx); end

  def resolver(); end

  def resolver_method(); end

  def scoped?(); end

  def subscription_scope(); end

  def subscription_scope=(subscription_scope); end

  def trace(); end

  def type(); end

  def type=(type); end

  def visible?(context); end
  NO_ARGS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Field::ConnectionExtension
  def after_resolve(value:, object:, arguments:, context:, memo:); end
end

class GraphQL::Schema::Field::ConnectionExtension
end

class GraphQL::Schema::Field::ScopeExtension
  def after_resolve(value:, context:, **rest); end
end

class GraphQL::Schema::Field::ScopeExtension
end

class GraphQL::Schema::Field
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  def self.connection_extension(new_extension_class=T.unsafe(nil)); end

  def self.from_options(name=T.unsafe(nil), type=T.unsafe(nil), desc=T.unsafe(nil), resolver: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), **kwargs, &block); end
end

class GraphQL::Schema::FieldExtension
  def after_resolve(object:, arguments:, context:, value:, memo:); end

  def apply(); end

  def field(); end

  def initialize(field:, options:); end

  def options(); end

  def resolve(object:, arguments:, context:); end
end

class GraphQL::Schema::FieldExtension
end

module GraphQL::Schema::FindInheritedValue
end

module GraphQL::Schema::FindInheritedValue::EmptyObjects
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::FindInheritedValue::EmptyObjects
end

module GraphQL::Schema::FindInheritedValue
  def self.extended(child_cls); end

  def self.included(child_cls); end
end

class GraphQL::Schema::Finder
  def find(path); end

  def initialize(schema); end
end

class GraphQL::Schema::Finder::MemberNotFoundError
end

class GraphQL::Schema::Finder::MemberNotFoundError
end

class GraphQL::Schema::Finder
end

class GraphQL::Schema::InputObject
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Dig
  def [](key); end

  def any?(*args, &block); end

  def arguments(); end

  def context(); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def initialize(values=T.unsafe(nil), context:, defaults_used:, ruby_kwargs: T.unsafe(nil)); end

  def key?(key); end

  def keys(*args, &block); end

  def map(*args, &block); end

  def prepare(); end

  def to_h(); end

  def to_hash(); end

  def to_kwargs(); end

  def unwrap_value(value); end

  def values(*args, &block); end
end

class GraphQL::Schema::InputObject
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.arguments_class(); end

  def self.arguments_class=(arguments_class); end

  def self.coerce_input(value, ctx); end

  def self.coerce_result(value, ctx); end

  def self.validate_non_null_input(input, ctx); end
end

module GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  def unwrap(); end
end

module GraphQL::Schema::Interface::DefinitionMethods
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Relay::TypeExtensions
  include ::GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::TypeSystemHelpers
  include ::GraphQL::Schema::Member::HasFields
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::RelayShortcuts
  include ::GraphQL::Schema::Member::Scoped
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def accessible?(context); end

  def definition_methods(&block); end

  def included(child_class); end

  def interfaces(); end

  def kind(); end

  def orphan_types(*types); end

  def own_interfaces(); end

  def to_graphql(); end

  def visible?(context); end
end

module GraphQL::Schema::Interface::DefinitionMethods
end

module GraphQL::Schema::Interface
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

class GraphQL::Schema::IntrospectionSystem
  def dynamic_field(name:); end

  def dynamic_fields(); end

  def entry_point(name:); end

  def entry_points(); end

  def initialize(schema); end

  def possible_types(); end

  def resolve_late_bindings(); end

  def types(); end
end

class GraphQL::Schema::IntrospectionSystem::PerFieldProxyResolve
  def call(obj, args, ctx); end

  def initialize(object_class:, inner_resolve:); end
end

class GraphQL::Schema::IntrospectionSystem::PerFieldProxyResolve
end

class GraphQL::Schema::IntrospectionSystem
end

class GraphQL::Schema::InvalidDocumentError
end

class GraphQL::Schema::InvalidDocumentError
end

class GraphQL::Schema::InvalidTypeError
end

class GraphQL::Schema::InvalidTypeError
end

class GraphQL::Schema::LateBoundType
  def graphql_name(); end

  def initialize(local_name); end

  def name(); end

  def to_list_type(); end

  def to_non_null_type(); end

  def unwrap(); end
end

class GraphQL::Schema::LateBoundType
end

class GraphQL::Schema::List
  include ::GraphQL::Schema::Member::ValidatesInput
  def coerce_input(value, ctx); end

  def coerce_result(value, ctx); end

  def graphql_name(); end

  def validate_non_null_input(value, ctx); end
end

class GraphQL::Schema::List
end

module GraphQL::Schema::Loader
  def load(introspection_result); end
  NullResolveType = ::T.let(nil, ::T.untyped)
  NullScalarCoerce = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Loader
  extend ::GraphQL::Schema::Loader
end

class GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::GraphQLTypeNames
end

module GraphQL::Schema::Member::AcceptsDefinition
end

module GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  def accepts_definition(name); end

  def accepts_definition_methods(); end

  def own_accepts_definition_methods(); end
end

module GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

module GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accepts_definition_methods(); end

  def initialize(*args, **kwargs, &block); end
end

module GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
end

module GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def to_graphql(); end
end

module GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

module GraphQL::Schema::Member::AcceptsDefinition
  def self.extended(child); end

  def self.included(child); end
end

module GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  def accessible?(context); end

  def authorized?(object, context); end

  def default_graphql_name(); end

  def description(new_description=T.unsafe(nil)); end

  def graphql_name(new_name=T.unsafe(nil)); end

  def introspection(new_introspection=T.unsafe(nil)); end

  def introspection?(); end

  def mutation(mutation_class=T.unsafe(nil)); end

  def name(new_name=T.unsafe(nil)); end

  def overridden_graphql_name(); end

  def to_graphql(); end

  def unwrap(); end

  def visible?(context); end
end

module GraphQL::Schema::Member::BaseDSLMethods
end

module GraphQL::Schema::Member::CachedGraphQLDefinition
  def graphql_definition(); end

  def type_class(); end
end

module GraphQL::Schema::Member::CachedGraphQLDefinition
end

module GraphQL::Schema::Member::GraphQLTypeNames
  Boolean = ::T.let(nil, ::T.untyped)
  ID = ::T.let(nil, ::T.untyped)
  Int = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Member::GraphQLTypeNames
end

module GraphQL::Schema::Member::HasArguments
  def add_argument(arg_defn); end

  def argument_class(new_arg_class=T.unsafe(nil)); end

  def arguments(); end

  def coerce_arguments(parent_object, values, context); end

  def own_arguments(); end
end

module GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  def load_application_object(argument, lookup_as_type, id, context); end

  def load_application_object_failed(err); end

  def object_from_id(type, id, context); end
end

module GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
end

module GraphQL::Schema::Member::HasArguments
  def self.extended(cls); end

  def self.included(cls); end
end

module GraphQL::Schema::Member::HasAstNode
  def ast_node(new_ast_node=T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasAstNode
end

module GraphQL::Schema::Member::HasFields
  def add_field(field_defn); end

  def field_class(new_field_class=T.unsafe(nil)); end

  def fields(); end

  def get_field(field_name); end

  def global_id_field(field_name); end

  def own_fields(); end
  CONFLICT_FIELD_NAMES = ::T.let(nil, ::T.untyped)
  GRAPHQL_RUBY_KEYWORDS = ::T.let(nil, ::T.untyped)
  RUBY_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Member::HasPath
  def path(); end
end

module GraphQL::Schema::Member::HasPath
end

module GraphQL::Schema::Member::RelayShortcuts
  def connection_type(); end

  def connection_type_class(new_connection_type_class=T.unsafe(nil)); end

  def edge_type(); end

  def edge_type_class(new_edge_type_class=T.unsafe(nil)); end
end

module GraphQL::Schema::Member::RelayShortcuts
end

module GraphQL::Schema::Member::Scoped
  def scope_items(items, context); end
end

module GraphQL::Schema::Member::Scoped
end

module GraphQL::Schema::Member::TypeSystemHelpers
  def kind(); end

  def list?(); end

  def non_null?(); end

  def to_list_type(); end

  def to_non_null_type(); end

  def to_type_signature(); end
end

module GraphQL::Schema::Member::TypeSystemHelpers
end

module GraphQL::Schema::Member::ValidatesInput
  def coerce_isolated_input(v); end

  def coerce_isolated_result(v); end

  def valid_input?(val, ctx); end

  def valid_isolated_input?(v); end

  def validate_input(val, ctx); end
end

module GraphQL::Schema::Member::ValidatesInput
end

class GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::HasAstNode
end

class GraphQL::Schema::MiddlewareChain
  def <<(callable); end

  def ==(other); end

  def [](*args, &block); end

  def concat(callables); end

  def delete(*args, &block); end

  def final_step(); end

  def first(*args, &block); end

  def initialize(steps: T.unsafe(nil), final_step: T.unsafe(nil)); end

  def insert(*args, &block); end

  def invoke(arguments); end

  def push(callable); end

  def steps(); end
end

class GraphQL::Schema::MiddlewareChain::MiddlewareWrapper
  def call(*args, &next_middleware); end

  def callable(); end

  def initialize(callable); end
end

class GraphQL::Schema::MiddlewareChain::MiddlewareWrapper
end

class GraphQL::Schema::MiddlewareChain
  extend ::Forwardable
end

class GraphQL::Schema::Mutation
end

class GraphQL::Schema::Mutation
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Resolver::HasPayloadType
end

class GraphQL::Schema::NonNull
  include ::GraphQL::Schema::Member::ValidatesInput
  def coerce_input(value, ctx); end

  def coerce_result(value, ctx); end

  def graphql_name(); end

  def validate_input(value, ctx); end
end

class GraphQL::Schema::NonNull
end

module GraphQL::Schema::NullMask
end

module GraphQL::Schema::NullMask
  def self.call(member, ctx); end
end

class GraphQL::Schema::Object
  def context(); end

  def initialize(object, context); end

  def object(); end
end

class GraphQL::Schema::Object
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.authorized_new(object, context); end

  def self.implements(*new_interfaces); end

  def self.interfaces(); end

  def self.own_interfaces(); end
end

class GraphQL::Schema::PossibleTypes
  def initialize(schema); end

  def possible_types(type_defn, ctx); end
end

class GraphQL::Schema::PossibleTypes
end

class GraphQL::Schema::Printer
  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), introspection: T.unsafe(nil)); end

  def print_schema(); end

  def print_type(type); end

  def schema(); end

  def warden(); end
end

class GraphQL::Schema::Printer::IntrospectionPrinter
end

class GraphQL::Schema::Printer::IntrospectionPrinter
end

class GraphQL::Schema::Printer
  def self.print_introspection_schema(); end

  def self.print_schema(schema, **args); end
end

class GraphQL::Schema::RelayClassicMutation
  def resolve_with_support(**inputs); end
end

class GraphQL::Schema::RelayClassicMutation
  def self.input_object_class(new_class=T.unsafe(nil)); end

  def self.input_type(new_input_type=T.unsafe(nil)); end
end

class GraphQL::Schema::RescueMiddleware
  def call(*args); end

  def remove_handler(*error_classes); end

  def rescue_from(*error_classes, &block); end

  def rescue_table(); end
end

class GraphQL::Schema::RescueMiddleware
end

class GraphQL::Schema::Resolver
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasPath
  def authorized?(**inputs); end

  def context(); end

  def field(); end

  def initialize(object:, context:, field:); end

  def object(); end

  def ready?(**args); end

  def resolve(**args); end

  def resolve_with_support(**args); end
end

module GraphQL::Schema::Resolver::HasPayloadType
  def field_class(new_class=T.unsafe(nil)); end

  def object_class(new_class=T.unsafe(nil)); end

  def payload_type(new_payload_type=T.unsafe(nil)); end

  def type(new_payload_type=T.unsafe(nil)); end

  def type_expr(new_payload_type=T.unsafe(nil)); end
end

module GraphQL::Schema::Resolver::HasPayloadType
end

class GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasPath
  def self.arguments_loads_as_type(); end

  def self.complexity(new_complexity=T.unsafe(nil)); end

  def self.extension(extension, **options); end

  def self.extensions(); end

  def self.extras(new_extras=T.unsafe(nil)); end

  def self.field_options(); end

  def self.null(allow_null=T.unsafe(nil)); end

  def self.resolve_method(new_method=T.unsafe(nil)); end

  def self.type(new_type=T.unsafe(nil), null: T.unsafe(nil)); end

  def self.type_expr(); end
end

class GraphQL::Schema::Scalar
end

class GraphQL::Schema::Scalar
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.coerce_input(val, ctx); end

  def self.coerce_result(val, ctx); end

  def self.default_scalar(is_default=T.unsafe(nil)); end

  def self.default_scalar?(); end

  def self.validate_non_null_input(value, ctx); end
end

class GraphQL::Schema::Subscription
  def resolve_subscribe(**args); end

  def resolve_update(**args); end

  def subscribe(args=T.unsafe(nil)); end

  def unsubscribe(); end

  def update(args=T.unsafe(nil)); end
  READING_SCOPE = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Subscription::EarlyTerminationError
end

class GraphQL::Schema::Subscription::EarlyTerminationError
end

class GraphQL::Schema::Subscription::NoUpdateError
end

class GraphQL::Schema::Subscription::NoUpdateError
end

class GraphQL::Schema::Subscription::UnsubscribedError
end

class GraphQL::Schema::Subscription::UnsubscribedError
end

class GraphQL::Schema::Subscription
  extend ::GraphQL::Schema::Resolver::HasPayloadType
  extend ::GraphQL::Schema::Member::HasFields
  def self.subscription_scope(new_scope=T.unsafe(nil)); end
end

class GraphQL::Schema::Timeout
  def handle_timeout(error, query); end

  def initialize(max_seconds:); end

  def max_seconds(); end

  def trace(key, data); end
end

class GraphQL::Schema::Timeout::TimeoutError
  def initialize(parent_type, field); end
end

class GraphQL::Schema::Timeout::TimeoutError
end

class GraphQL::Schema::Timeout
  def self.use(schema, **options); end
end

class GraphQL::Schema::TimeoutMiddleware
  def call(parent_type, parent_object, field_definition, field_args, query_context); end

  def initialize(max_seconds:, context_key: T.unsafe(nil), &block); end

  def on_timeout(parent_type, parent_object, field_definition, field_args, field_context); end
end

class GraphQL::Schema::TimeoutMiddleware::TimeoutError
  def initialize(parent_type, field_defn); end
end

class GraphQL::Schema::TimeoutMiddleware::TimeoutError
end

class GraphQL::Schema::TimeoutMiddleware::TimeoutQueryProxy
  def context(); end

  def initialize(query, ctx); end
end

class GraphQL::Schema::TimeoutMiddleware::TimeoutQueryProxy
end

class GraphQL::Schema::TimeoutMiddleware
end

class GraphQL::Schema::Traversal
  def initialize(schema, introspection: T.unsafe(nil)); end

  def instrumented_field_map(); end

  def type_map(); end

  def type_reference_map(); end

  def union_memberships(); end
end

class GraphQL::Schema::Traversal
end

module GraphQL::Schema::TypeExpression
end

module GraphQL::Schema::TypeExpression
  def self.build_type(type_owner, ast_node); end
end

class GraphQL::Schema::TypeMembership
  def abstract_type(); end

  def initialize(abstract_type, object_type, **options); end

  def object_type(); end

  def object_type=(object_type); end

  def visible?(_ctx); end
end

class GraphQL::Schema::TypeMembership
end

class GraphQL::Schema::Union
end

class GraphQL::Schema::Union
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.possible_types(*types, context: T.unsafe(nil), **options); end

  def self.type_membership_class(membership_class=T.unsafe(nil)); end

  def self.type_memberships(); end
end

module GraphQL::Schema::UniqueWithinType
end

module GraphQL::Schema::UniqueWithinType
  def self.decode(node_id, separator: T.unsafe(nil)); end

  def self.default_id_separator(); end

  def self.default_id_separator=(default_id_separator); end

  def self.encode(type_name, object_value, separator: T.unsafe(nil)); end
end

class GraphQL::Schema::UnresolvedLateBoundTypeError
  def initialize(type:); end

  def type(); end
end

class GraphQL::Schema::UnresolvedLateBoundTypeError
end

class GraphQL::Schema::Validation
  RULES = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Validation::Rules
  ARGUMENTS_ARE_STRING_TO_ARGUMENT = ::T.let(nil, ::T.untyped)
  ARGUMENTS_ARE_VALID = ::T.let(nil, ::T.untyped)
  DEFAULT_VALUE_IS_VALID_FOR_TYPE = ::T.let(nil, ::T.untyped)
  DESCRIPTION_IS_STRING_OR_NIL = ::T.let(nil, ::T.untyped)
  FIELDS_ARE_VALID = ::T.let(nil, ::T.untyped)
  HAS_AT_LEAST_ONE_ARGUMENT = ::T.let(nil, ::T.untyped)
  HAS_AT_LEAST_ONE_FIELD = ::T.let(nil, ::T.untyped)
  HAS_ONE_OR_MORE_POSSIBLE_TYPES = ::T.let(nil, ::T.untyped)
  INTERFACES_ARE_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NAME_IS_STRING = ::T.let(nil, ::T.untyped)
  RESERVED_NAME = ::T.let(nil, ::T.untyped)
  RESERVED_TYPE_NAME = ::T.let(nil, ::T.untyped)
  SCHEMA_CAN_FETCH_IDS = ::T.let(nil, ::T.untyped)
  SCHEMA_CAN_GENERATE_IDS = ::T.let(nil, ::T.untyped)
  SCHEMA_CAN_RESOLVE_TYPES = ::T.let(nil, ::T.untyped)
  SCHEMA_INSTRUMENTERS_ARE_VALID = ::T.let(nil, ::T.untyped)
  TYPE_IS_VALID_INPUT_TYPE = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Validation::Rules
  def self.assert_named_items_are_valid(item_name, get_items_proc); end

  def self.assert_property(property_name, *allowed_classes); end

  def self.assert_property_list_of(property_name, list_member_class); end

  def self.assert_property_mapping(property_name, from_class, to_class); end

  def self.count_at_least(item_name, minimum_count, get_items_proc); end
end

class GraphQL::Schema::Validation
  def self.validate(object); end
end

class GraphQL::Schema::Warden
  def arguments(argument_owner); end

  def directives(); end

  def enum_values(enum_defn); end

  def fields(type_defn); end

  def get_field(parent_type, field_name); end

  def get_type(type_name); end

  def initialize(filter, context:, schema:); end

  def interfaces(obj_type); end

  def possible_types(type_defn); end

  def reachable_type?(type_name); end

  def reachable_types(); end

  def root_type_for_operation(op_name); end

  def types(); end
  NO_REFERENCES = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Warden
end

class GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::TypeSystemHelpers
  def ==(other); end

  def initialize(of_type); end

  def of_type(); end

  def to_graphql(); end

  def unwrap(); end
end

class GraphQL::Schema::Wrapper
end

class GraphQL::Schema
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.accessible?(member, ctx); end

  def self.after_lazy(value); end

  def self.analysis_engine(); end

  def self.analysis_engine=(analysis_engine); end

  def self.as_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def self.connections(); end

  def self.connections=(connections); end

  def self.context_class(new_context_class=T.unsafe(nil)); end

  def self.cursor_encoder(new_encoder=T.unsafe(nil)); end

  def self.default_directives(); end

  def self.default_execution_strategy(); end

  def self.default_execution_strategy=(default_execution_strategy); end

  def self.default_filter(); end

  def self.default_mask(new_mask=T.unsafe(nil)); end

  def self.default_max_page_size(new_default_max_page_size=T.unsafe(nil)); end

  def self.directive(new_directive); end

  def self.directives(new_directives=T.unsafe(nil)); end

  def self.disable_introspection_entry_points(); end

  def self.disable_introspection_entry_points?(); end

  def self.disable_schema_introspection_entry_point(); end

  def self.disable_schema_introspection_entry_point?(); end

  def self.disable_type_introspection_entry_point(); end

  def self.disable_type_introspection_entry_point?(); end

  def self.error_bubbling(new_error_bubbling=T.unsafe(nil)); end

  def self.error_bubbling=(error_bubbling); end

  def self.error_handler(); end

  def self.error_handler=(error_handler); end

  def self.execute(query_str=T.unsafe(nil), **kwargs); end

  def self.execution_strategy_for_operation(*args, &block); end

  def self.find(path); end

  def self.from_definition(definition_or_path, default_resolve: T.unsafe(nil), interpreter: T.unsafe(nil), parser: T.unsafe(nil), using: T.unsafe(nil)); end

  def self.from_introspection(introspection_result); end

  def self.get_field(type_or_name, field_name); end

  def self.get_fields(type); end

  def self.get_type(type_name); end

  def self.graphql_definition(); end

  def self.id_from_object(object, type, ctx); end

  def self.id_from_object=(*args, &block); end

  def self.id_from_object_proc(*args, &block); end

  def self.inaccessible_fields(error); end

  def self.inherited(child_class); end

  def self.instrument(instrument_step, instrumenter, options=T.unsafe(nil)); end

  def self.instrumenters(); end

  def self.interpreter=(interpreter); end

  def self.interpreter?(); end

  def self.introspection(new_introspection_namespace=T.unsafe(nil)); end

  def self.introspection_system(); end

  def self.lazy?(obj); end

  def self.lazy_method_name(obj); end

  def self.lazy_resolve(lazy_class, value_method); end

  def self.max_complexity(max_complexity=T.unsafe(nil)); end

  def self.max_complexity=(max_complexity); end

  def self.max_depth(new_max_depth=T.unsafe(nil)); end

  def self.max_depth=(max_depth); end

  def self.metadata(*args, &block); end

  def self.middleware(new_middleware=T.unsafe(nil)); end

  def self.multiplex(queries, **kwargs); end

  def self.multiplex_analyzer(new_analyzer); end

  def self.multiplex_analyzers(); end

  def self.mutation(new_mutation_object=T.unsafe(nil)); end

  def self.mutation_execution_strategy(new_mutation_execution_strategy=T.unsafe(nil)); end

  def self.new_connections?(); end

  def self.object_from_id(node_id, ctx); end

  def self.object_from_id=(*args, &block); end

  def self.object_from_id_proc(*args, &block); end

  def self.orphan_types(*new_orphan_types); end

  def self.parse_error(parse_err, ctx); end

  def self.plugins(); end

  def self.possible_types(type=T.unsafe(nil), context=T.unsafe(nil)); end

  def self.query(new_query_object=T.unsafe(nil)); end

  def self.query_analyzer(new_analyzer); end

  def self.query_analyzers(); end

  def self.query_execution_strategy(new_query_execution_strategy=T.unsafe(nil)); end

  def self.redefine(*args, &block); end

  def self.references_to(to_type=T.unsafe(nil), from: T.unsafe(nil)); end

  def self.remove_handler(*args, &block); end

  def self.rescue_from(*err_classes, &handler_block); end

  def self.rescues(); end

  def self.resolve_type(type, obj, ctx); end

  def self.root_type_for_operation(operation); end

  def self.root_types(); end

  def self.static_validator(); end

  def self.subscription(new_subscription_object=T.unsafe(nil)); end

  def self.subscription_execution_strategy(new_subscription_execution_strategy=T.unsafe(nil)); end

  def self.subscriptions(); end

  def self.subscriptions=(subscriptions); end

  def self.sync_lazy(value); end

  def self.to_definition(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def self.to_document(); end

  def self.to_json(*args); end

  def self.tracer(new_tracer); end

  def self.tracers(); end

  def self.type_error(type_err, ctx); end

  def self.type_from_ast(ast_node, context: T.unsafe(nil)); end

  def self.types(); end

  def self.unauthorized_field(unauthorized_error); end

  def self.unauthorized_object(unauthorized_error); end

  def self.union_memberships(type=T.unsafe(nil)); end

  def self.use(plugin, **kwargs); end

  def self.using_ast_analysis?(); end

  def self.validate(*args, &block); end

  def self.visible?(member, ctx); end
end

module GraphQL::StaticValidation
  ALL_RULES = ::T.let(nil, ::T.untyped)
end

module GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  def on_argument(node, parent); end
end

module GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
end

class GraphQL::StaticValidation::ArgumentLiteralsAreCompatibleError
  def argument_name(); end

  def code(); end

  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil), argument: T.unsafe(nil), extensions: T.unsafe(nil), coerce_extensions: T.unsafe(nil)); end

  def type_name(); end
end

class GraphQL::StaticValidation::ArgumentLiteralsAreCompatibleError
end

module GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  def on_directive(node, parent); end

  def on_field(node, parent); end

  def validate_arguments(node); end
end

module GraphQL::StaticValidation::ArgumentNamesAreUnique
end

class GraphQL::StaticValidation::ArgumentNamesAreUniqueError
  def code(); end

  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def name(); end
end

class GraphQL::StaticValidation::ArgumentNamesAreUniqueError
end

module GraphQL::StaticValidation::ArgumentsAreDefined
  def on_argument(node, parent); end
end

module GraphQL::StaticValidation::ArgumentsAreDefined
end

class GraphQL::StaticValidation::ArgumentsAreDefinedError
  def argument_name(); end

  def code(); end

  def initialize(message, name:, type:, argument:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def name(); end

  def type_name(); end
end

class GraphQL::StaticValidation::ArgumentsAreDefinedError
end

class GraphQL::StaticValidation::BaseVisitor
  def context(); end

  def initialize(document, context); end

  def object_types(); end

  def path(); end

  def rewrite_document(); end
end

module GraphQL::StaticValidation::BaseVisitor::ContextMethods
  def argument_definition(); end

  def directive_definition(); end

  def field_definition(); end

  def on_argument(node, parent); end

  def on_directive(node, parent); end

  def on_field(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end

  def on_input_object(node, parent); end

  def on_operation_definition(node, parent); end

  def parent_type_definition(); end

  def type_definition(); end
end

module GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

class GraphQL::StaticValidation::BaseVisitor
  def self.including_rules(rules, rewrite: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::DefaultVisitor
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  include ::GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

class GraphQL::StaticValidation::DefaultVisitor
end

module GraphQL::StaticValidation::DefinitionDependencies
  def dependencies(); end

  def dependency_map(&block); end

  def initialize(*_); end

  def on_document(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_operation_definition(node, prev_node); end
end

class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
  def [](definition_node); end

  def cyclical_definitions(); end

  def unmet_dependencies(); end

  def unused_dependencies(); end
end

class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  def eql?(*args, &block); end

  def hash(*args, &block); end

  def initialize(node, path); end

  def name(*args, &block); end

  def node(); end

  def path(); end
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  extend ::Forwardable
end

module GraphQL::StaticValidation::DefinitionDependencies
end

module GraphQL::StaticValidation::DirectivesAreDefined
  def initialize(*_); end

  def on_directive(node, parent); end
end

module GraphQL::StaticValidation::DirectivesAreDefined
end

class GraphQL::StaticValidation::DirectivesAreDefinedError
  def code(); end

  def directive_name(); end

  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::DirectivesAreDefinedError
end

module GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::Language
  def on_directive(node, parent); end
  LOCATION_MESSAGE_NAMES = ::T.let(nil, ::T.untyped)
  SIMPLE_LOCATIONS = ::T.let(nil, ::T.untyped)
  SIMPLE_LOCATION_NODES = ::T.let(nil, ::T.untyped)
end

module GraphQL::StaticValidation::DirectivesAreInValidLocations
end

class GraphQL::StaticValidation::DirectivesAreInValidLocationsError
  def code(); end

  def initialize(message, target:, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def name(); end

  def target_name(); end
end

class GraphQL::StaticValidation::DirectivesAreInValidLocationsError
end

class GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def message(); end

  def path(); end

  def path=(path); end

  def to_h(); end
end

module GraphQL::StaticValidation::Error::ErrorHelper
  def error(error_message, nodes, context: T.unsafe(nil), path: T.unsafe(nil), extensions: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::Error::ErrorHelper
end

class GraphQL::StaticValidation::Error
end

module GraphQL::StaticValidation::FieldsAreDefinedOnType
  def on_field(node, parent); end
end

module GraphQL::StaticValidation::FieldsAreDefinedOnType
end

class GraphQL::StaticValidation::FieldsAreDefinedOnTypeError
  def code(); end

  def field_name(); end

  def initialize(message, type:, field:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def type_name(); end
end

class GraphQL::StaticValidation::FieldsAreDefinedOnTypeError
end

module GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  def on_field(node, parent); end

  def on_operation_definition(node, _parent); end
end

module GraphQL::StaticValidation::FieldsHaveAppropriateSelections
end

class GraphQL::StaticValidation::FieldsHaveAppropriateSelectionsError
  def code(); end

  def initialize(message, node_name:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def node_name(); end

  def type_name(); end
end

class GraphQL::StaticValidation::FieldsHaveAppropriateSelectionsError
end

module GraphQL::StaticValidation::FieldsWillMerge
  def initialize(*_); end

  def on_field(node, _parent); end

  def on_operation_definition(node, _parent); end
  NO_ARGS = ::T.let(nil, ::T.untyped)
  NO_SELECTIONS = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::FieldsWillMerge::Field
  def definition(); end

  def definition=(_); end

  def node(); end

  def node=(_); end

  def owner_type(); end

  def owner_type=(_); end

  def parents(); end

  def parents=(_); end
end

class GraphQL::StaticValidation::FieldsWillMerge::Field
  def self.[](*_); end

  def self.members(); end
end

class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread
  def name(); end

  def name=(_); end

  def parents(); end

  def parents=(_); end
end

class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread
  def self.[](*_); end

  def self.members(); end
end

module GraphQL::StaticValidation::FieldsWillMerge
end

class GraphQL::StaticValidation::FieldsWillMergeError
  def code(); end

  def conflicts(); end

  def field_name(); end

  def initialize(message, field_name:, conflicts:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::FieldsWillMergeError
end

module GraphQL::StaticValidation::FragmentNamesAreUnique
  def initialize(*_); end

  def on_document(_n, _p); end

  def on_fragment_definition(node, parent); end
end

module GraphQL::StaticValidation::FragmentNamesAreUnique
end

class GraphQL::StaticValidation::FragmentNamesAreUniqueError
  def code(); end

  def fragment_name(); end

  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::FragmentNamesAreUniqueError
end

module GraphQL::StaticValidation::FragmentSpreadsArePossible
  def initialize(*_); end

  def on_document(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
  def initialize(node:, parent_type:, path:); end

  def node(); end

  def parent_type(); end

  def path(); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
end

module GraphQL::StaticValidation::FragmentSpreadsArePossible
end

class GraphQL::StaticValidation::FragmentSpreadsArePossibleError
  def code(); end

  def fragment_name(); end

  def initialize(message, type:, fragment_name:, parent:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def parent_name(); end

  def type_name(); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossibleError
end

module GraphQL::StaticValidation::FragmentTypesExist
  def on_fragment_definition(node, _parent); end

  def on_inline_fragment(node, _parent); end
end

module GraphQL::StaticValidation::FragmentTypesExist
end

class GraphQL::StaticValidation::FragmentTypesExistError
  def code(); end

  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def type_name(); end
end

class GraphQL::StaticValidation::FragmentTypesExistError
end

module GraphQL::StaticValidation::FragmentsAreFinite
  def on_document(_n, _p); end
end

module GraphQL::StaticValidation::FragmentsAreFinite
end

class GraphQL::StaticValidation::FragmentsAreFiniteError
  def code(); end

  def fragment_name(); end

  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::FragmentsAreFiniteError
end

module GraphQL::StaticValidation::FragmentsAreNamed
  def on_fragment_definition(node, _parent); end
end

module GraphQL::StaticValidation::FragmentsAreNamed
end

class GraphQL::StaticValidation::FragmentsAreNamedError
  def code(); end
end

class GraphQL::StaticValidation::FragmentsAreNamedError
end

module GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  def on_fragment_definition(node, parent); end

  def on_inline_fragment(node, parent); end
end

module GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
end

class GraphQL::StaticValidation::FragmentsAreOnCompositeTypesError
  def argument_name(); end

  def code(); end

  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def type_name(); end
end

class GraphQL::StaticValidation::FragmentsAreOnCompositeTypesError
end

module GraphQL::StaticValidation::FragmentsAreUsed
  def on_document(node, parent); end
end

module GraphQL::StaticValidation::FragmentsAreUsed
end

class GraphQL::StaticValidation::FragmentsAreUsedError
  def code(); end

  def fragment_name(); end

  def initialize(message, fragment:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::FragmentsAreUsedError
end

class GraphQL::StaticValidation::InterpreterVisitor
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

class GraphQL::StaticValidation::InterpreterVisitor
end

class GraphQL::StaticValidation::LiteralValidator
  def initialize(context:); end

  def validate(ast_value, type); end
end

class GraphQL::StaticValidation::LiteralValidator
end

module GraphQL::StaticValidation::MutationRootExists
  def on_operation_definition(node, _parent); end
end

module GraphQL::StaticValidation::MutationRootExists
end

class GraphQL::StaticValidation::MutationRootExistsError
  def code(); end
end

class GraphQL::StaticValidation::MutationRootExistsError
end

module GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  def initialize(*_); end

  def on_directive_definition(node, parent); end

  def on_document(node, parent); end

  def on_enum_type_definition(node, parent); end

  def on_enum_type_extension(node, parent); end

  def on_input_object_type_definition(node, parent); end

  def on_input_object_type_extension(node, parent); end

  def on_interface_type_definition(node, parent); end

  def on_interface_type_extension(node, parent); end

  def on_invalid_node(node, parent); end

  def on_object_type_definition(node, parent); end

  def on_object_type_extension(node, parent); end

  def on_scalar_type_definition(node, parent); end

  def on_scalar_type_extension(node, parent); end

  def on_schema_definition(node, parent); end

  def on_schema_extension(node, parent); end

  def on_union_type_definition(node, parent); end

  def on_union_type_extension(node, parent); end
end

module GraphQL::StaticValidation::NoDefinitionsArePresent
end

class GraphQL::StaticValidation::NoDefinitionsArePresentError
  def code(); end
end

class GraphQL::StaticValidation::NoDefinitionsArePresentError
end

class GraphQL::StaticValidation::NoValidateVisitor
  include ::GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

class GraphQL::StaticValidation::NoValidateVisitor
end

module GraphQL::StaticValidation::OperationNamesAreValid
  def initialize(*_); end

  def on_document(node, parent); end

  def on_operation_definition(node, parent); end
end

module GraphQL::StaticValidation::OperationNamesAreValid
end

class GraphQL::StaticValidation::OperationNamesAreValidError
  def code(); end

  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def operation_name(); end
end

class GraphQL::StaticValidation::OperationNamesAreValidError
end

module GraphQL::StaticValidation::RequiredArgumentsArePresent
  def on_directive(node, _parent); end

  def on_field(node, _parent); end
end

module GraphQL::StaticValidation::RequiredArgumentsArePresent
end

class GraphQL::StaticValidation::RequiredArgumentsArePresentError
  def arguments(); end

  def class_name(); end

  def code(); end

  def initialize(message, class_name:, name:, arguments:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def name(); end
end

class GraphQL::StaticValidation::RequiredArgumentsArePresentError
end

module GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  def on_input_object(node, parent); end
end

module GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
end

class GraphQL::StaticValidation::RequiredInputObjectAttributesArePresentError
  def argument_name(); end

  def argument_type(); end

  def code(); end

  def initialize(message, path:, nodes:, argument_type:, argument_name:, input_object_type:); end

  def input_object_type(); end
end

class GraphQL::StaticValidation::RequiredInputObjectAttributesArePresentError
end

module GraphQL::StaticValidation::SubscriptionRootExists
  def on_operation_definition(node, _parent); end
end

module GraphQL::StaticValidation::SubscriptionRootExists
end

class GraphQL::StaticValidation::SubscriptionRootExistsError
  def code(); end
end

class GraphQL::StaticValidation::SubscriptionRootExistsError
end

class GraphQL::StaticValidation::TypeStack
  def argument_definitions(); end

  def directive_definitions(); end

  def field_definitions(); end

  def initialize(schema, visitor); end

  def object_types(); end

  def path(); end

  def schema(); end
  PUSH_STRATEGIES = ::T.let(nil, ::T.untyped)
  TYPE_INFERRENCE_ROOTS = ::T.let(nil, ::T.untyped)
end

module GraphQL::StaticValidation::TypeStack::ArgumentStrategy
end

module GraphQL::StaticValidation::TypeStack::ArgumentStrategy
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::DirectiveStrategy
end

module GraphQL::StaticValidation::TypeStack::DirectiveStrategy
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

class GraphQL::StaticValidation::TypeStack::EnterWithStrategy
  def call(node, parent); end

  def initialize(stack, strategy); end
end

class GraphQL::StaticValidation::TypeStack::EnterWithStrategy
end

module GraphQL::StaticValidation::TypeStack::FieldStrategy
end

module GraphQL::StaticValidation::TypeStack::FieldStrategy
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentDefinitionStrategy
end

module GraphQL::StaticValidation::TypeStack::FragmentDefinitionStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def self.push_path_member(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentSpreadStrategy
end

module GraphQL::StaticValidation::TypeStack::FragmentSpreadStrategy
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def pop(stack, node); end

  def push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
end

module GraphQL::StaticValidation::TypeStack::InlineFragmentStrategy
end

module GraphQL::StaticValidation::TypeStack::InlineFragmentStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def self.push_path_member(stack, node); end
end

class GraphQL::StaticValidation::TypeStack::LeaveWithStrategy
  def call(node, parent); end

  def initialize(stack, strategy); end
end

class GraphQL::StaticValidation::TypeStack::LeaveWithStrategy
end

module GraphQL::StaticValidation::TypeStack::OperationDefinitionStrategy
end

module GraphQL::StaticValidation::TypeStack::OperationDefinitionStrategy
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

class GraphQL::StaticValidation::TypeStack
end

module GraphQL::StaticValidation::UniqueDirectivesPerLocation
  def on_enum_type_definition(node, parent); end

  def on_enum_value_definition(node, parent); end

  def on_field(node, parent); end

  def on_field_definition(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end

  def on_input_object_type_definition(node, parent); end

  def on_input_value_definition(node, parent); end

  def on_interface_type_definition(node, parent); end

  def on_object_type_definition(node, parent); end

  def on_operation_definition(node, parent); end

  def on_scalar_type_definition(node, parent); end

  def on_union_type_definition(node, parent); end
  DIRECTIVE_NODE_HOOKS = ::T.let(nil, ::T.untyped)
end

module GraphQL::StaticValidation::UniqueDirectivesPerLocation
end

class GraphQL::StaticValidation::UniqueDirectivesPerLocationError
  def code(); end

  def directive_name(); end

  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::UniqueDirectivesPerLocationError
end

class GraphQL::StaticValidation::ValidationContext
  def argument_definition(*args, &block); end

  def dependencies(*args, &block); end

  def directive_definition(*args, &block); end

  def document(*args, &block); end

  def errors(); end

  def field_definition(*args, &block); end

  def fragments(*args, &block); end

  def initialize(query, visitor_class); end

  def object_types(*args, &block); end

  def on_dependency_resolve(&handler); end

  def on_dependency_resolve_handlers(); end

  def operations(*args, &block); end

  def parent_type_definition(*args, &block); end

  def path(*args, &block); end

  def query(); end

  def schema(*args, &block); end

  def type_definition(*args, &block); end

  def validate_literal(ast_value, type); end

  def visitor(); end

  def warden(*args, &block); end
end

class GraphQL::StaticValidation::ValidationContext
  extend ::Forwardable
end

class GraphQL::StaticValidation::Validator
  def initialize(schema:, rules: T.unsafe(nil)); end

  def validate(query, validate: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::Validator
end

module GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  def on_variable_definition(node, parent); end
end

module GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
end

class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError
  def code(); end

  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def type_name(); end

  def variable_name(); end

  def violation(); end
  VIOLATIONS = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError
end

module GraphQL::StaticValidation::VariableNamesAreUnique
  def on_operation_definition(node, parent); end
end

module GraphQL::StaticValidation::VariableNamesAreUnique
end

class GraphQL::StaticValidation::VariableNamesAreUniqueError
  def code(); end

  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def variable_name(); end
end

class GraphQL::StaticValidation::VariableNamesAreUniqueError
end

module GraphQL::StaticValidation::VariableUsagesAreAllowed
  def initialize(*_); end

  def on_argument(node, parent); end

  def on_operation_definition(node, parent); end
end

module GraphQL::StaticValidation::VariableUsagesAreAllowed
end

class GraphQL::StaticValidation::VariableUsagesAreAllowedError
  def argument_name(); end

  def code(); end

  def error_message(); end

  def initialize(message, type:, name:, argument:, error:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def type_name(); end

  def variable_name(); end
end

class GraphQL::StaticValidation::VariableUsagesAreAllowedError
end

module GraphQL::StaticValidation::VariablesAreInputTypes
  def on_variable_definition(node, parent); end
end

module GraphQL::StaticValidation::VariablesAreInputTypes
end

class GraphQL::StaticValidation::VariablesAreInputTypesError
  def code(); end

  def initialize(message, type:, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def type_name(); end

  def variable_name(); end
end

class GraphQL::StaticValidation::VariablesAreInputTypesError
end

module GraphQL::StaticValidation::VariablesAreUsedAndDefined
  def initialize(*_); end

  def on_document(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_operation_definition(node, parent); end

  def on_variable_identifier(node, parent); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
  def ast_node(); end

  def ast_node=(ast_node); end

  def declared?(); end

  def declared_by(); end

  def declared_by=(declared_by); end

  def path(); end

  def path=(path); end

  def used?(); end

  def used_by(); end

  def used_by=(used_by); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
end

module GraphQL::StaticValidation::VariablesAreUsedAndDefined
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefinedError
  def code(); end

  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def variable_name(); end

  def violation(); end
  VIOLATIONS = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefinedError
end

module GraphQL::StaticValidation
end

module GraphQL::StringDedupBackport
end

module GraphQL::StringDedupBackport
end

class GraphQL::StringEncodingError
  def initialize(str); end

  def string(); end
end

class GraphQL::StringEncodingError
end

class GraphQL::Subscriptions
  def build_id(); end

  def delete_subscription(subscription_id); end

  def deliver(subscription_id, result); end

  def each_subscription_id(event); end

  def execute(subscription_id, event, object); end

  def execute_all(event, object); end

  def initialize(schema:, **rest); end

  def normalize_name(event_or_arg_name); end

  def read_subscription(subscription_id); end

  def trigger(event_name, args, object, scope: T.unsafe(nil)); end

  def write_subscription(query, events); end
end

class GraphQL::Subscriptions::Event
  def arguments(); end

  def context(); end

  def initialize(name:, arguments:, field: T.unsafe(nil), context: T.unsafe(nil), scope: T.unsafe(nil)); end

  def name(); end

  def topic(); end
end

class GraphQL::Subscriptions::Event
  def self.serialize(name, arguments, field, scope:); end
end

class GraphQL::Subscriptions::Instrumentation
  def after_query(query); end

  def before_query(query); end

  def initialize(schema:); end

  def instrument(type, field); end
end

class GraphQL::Subscriptions::Instrumentation::SubscriptionRegistrationResolve
  def call(obj, args, ctx); end

  def initialize(inner_proc); end
end

class GraphQL::Subscriptions::Instrumentation::SubscriptionRegistrationResolve
end

class GraphQL::Subscriptions::Instrumentation
end

class GraphQL::Subscriptions::InvalidTriggerError
end

class GraphQL::Subscriptions::InvalidTriggerError
end

module GraphQL::Subscriptions::Serialize
  GLOBALID_KEY = ::T.let(nil, ::T.untyped)
  SYMBOL_KEY = ::T.let(nil, ::T.untyped)
  SYMBOL_KEYS_KEY = ::T.let(nil, ::T.untyped)
end

module GraphQL::Subscriptions::Serialize
  def self.dump(obj); end

  def self.dump_recursive(obj); end

  def self.load(str); end
end

module GraphQL::Subscriptions::SubscriptionRoot
  def field(*args, extensions: T.unsafe(nil), **rest, &block); end
end

class GraphQL::Subscriptions::SubscriptionRoot::Extension
  def after_resolve(value:, context:, object:, arguments:, **rest); end
end

class GraphQL::Subscriptions::SubscriptionRoot::Extension
end

module GraphQL::Subscriptions::SubscriptionRoot::InstanceMethods
  def skip_subscription_root(*_); end
end

module GraphQL::Subscriptions::SubscriptionRoot::InstanceMethods
end

module GraphQL::Subscriptions::SubscriptionRoot
  def self.extended(child_cls); end
end

class GraphQL::Subscriptions
  def self.use(defn, options=T.unsafe(nil)); end
end

module GraphQL::Tracing
end

module GraphQL::Tracing::ActiveSupportNotificationsTracing
  KEYS = ::T.let(nil, ::T.untyped)
end

module GraphQL::Tracing::ActiveSupportNotificationsTracing
  def self.trace(key, metadata); end
end

class GraphQL::Tracing::AppOpticsTracing
  def platform_field_key(type, field); end

  def platform_trace(platform_key, _key, data); end
  EXEC_KEYS = ::T.let(nil, ::T.untyped)
  PREP_KEYS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Tracing::AppOpticsTracing
  def self.version(); end
end

class GraphQL::Tracing::AppsignalTracing
  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::AppsignalTracing
end

class GraphQL::Tracing::DataDogTracing
  def analytics_available?(); end

  def analytics_enabled?(); end

  def analytics_sample_rate(); end

  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end

  def service_name(); end

  def tracer(); end
end

class GraphQL::Tracing::DataDogTracing
end

class GraphQL::Tracing::NewRelicTracing
  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::NewRelicTracing
end

module GraphQL::Tracing::NullTracer
end

module GraphQL::Tracing::NullTracer
  def self.trace(k, v); end
end

class GraphQL::Tracing::PlatformTracing
  def initialize(options=T.unsafe(nil)); end

  def instrument(type, field); end

  def trace(key, data); end

  def trace_field(type, field); end
end

class GraphQL::Tracing::PlatformTracing
  def self.platform_keys(); end

  def self.platform_keys=(platform_keys); end

  def self.use(schema_defn, options=T.unsafe(nil)); end
end

class GraphQL::Tracing::PrometheusTracing
  def initialize(opts=T.unsafe(nil)); end

  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data, &block); end
  DEFAULT_COLLECTOR_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_WHITELIST = ::T.let(nil, ::T.untyped)
end

class GraphQL::Tracing::PrometheusTracing
end

class GraphQL::Tracing::ScoutTracing
  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end
  INSTRUMENT_OPTS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Tracing::ScoutTracing
end

class GraphQL::Tracing::SkylightTracing
  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::SkylightTracing
end

module GraphQL::Tracing::Traceable
  def trace(key, metadata); end
end

module GraphQL::Tracing::Traceable
end

module GraphQL::Tracing
  def self.install(tracer); end

  def self.tracers(); end

  def self.uninstall(tracer); end
end

module GraphQL::TypeKinds
  ENUM = ::T.let(nil, ::T.untyped)
  INPUT_OBJECT = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  NON_NULL = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  SCALAR = ::T.let(nil, ::T.untyped)
  TYPE_KINDS = ::T.let(nil, ::T.untyped)
  UNION = ::T.let(nil, ::T.untyped)
end

class GraphQL::TypeKinds::TypeKind
  def abstract?(); end

  def composite?(); end

  def description(); end

  def enum?(); end

  def fields?(); end

  def initialize(name, abstract: T.unsafe(nil), fields: T.unsafe(nil), wraps: T.unsafe(nil), input: T.unsafe(nil), description: T.unsafe(nil)); end

  def input?(); end

  def input_object?(); end

  def interface?(); end

  def list?(); end

  def name(); end

  def non_null?(); end

  def object?(); end

  def resolves?(); end

  def scalar?(); end

  def union?(); end

  def wraps?(); end
end

class GraphQL::TypeKinds::TypeKind
end

module GraphQL::TypeKinds
end

module GraphQL::Types
end

class GraphQL::Types::BigInt
end

class GraphQL::Types::BigInt
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::Boolean
end

class GraphQL::Types::Boolean
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::Float
end

class GraphQL::Types::Float
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::ID
end

class GraphQL::Types::ID
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::ISO8601Date
end

class GraphQL::Types::ISO8601Date
  def self.coerce_input(str_value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::ISO8601DateTime
  DEFAULT_TIME_PRECISION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Types::ISO8601DateTime
  def self.coerce_input(str_value, _ctx); end

  def self.coerce_result(value, _ctx); end

  def self.time_precision(); end

  def self.time_precision=(value); end
end

class GraphQL::Types::Int
  MAX = ::T.let(nil, ::T.untyped)
  MIN = ::T.let(nil, ::T.untyped)
end

class GraphQL::Types::Int
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, ctx); end
end

class GraphQL::Types::JSON
end

class GraphQL::Types::JSON
  def self.coerce_input(value, _context); end

  def self.coerce_result(value, _context); end
end

module GraphQL::Types::Relay
  NodeField = ::T.let(nil, ::T.untyped)
  NodesField = ::T.let(nil, ::T.untyped)
end

class GraphQL::Types::Relay::BaseConnection
  def cursor_from_node(*args, &block); end

  def edges(); end

  def nodes(); end

  def parent(*args, &block); end
end

class GraphQL::Types::Relay::BaseConnection
  extend ::Forwardable
  def self.accessible?(ctx); end

  def self.authorized?(obj, ctx); end

  def self.edge_class(); end

  def self.edge_type(edge_type_class, edge_class: T.unsafe(nil), node_type: T.unsafe(nil), nodes_field: T.unsafe(nil)); end

  def self.node_type(); end

  def self.nodes_field(); end

  def self.visible?(ctx); end
end

class GraphQL::Types::Relay::BaseEdge
end

class GraphQL::Types::Relay::BaseEdge
  def self.accessible?(ctx); end

  def self.authorized?(obj, ctx); end

  def self.node_type(node_type=T.unsafe(nil), null: T.unsafe(nil)); end

  def self.visible?(ctx); end
end

class GraphQL::Types::Relay::BaseField
  def initialize(edge_class: T.unsafe(nil), **rest, &block); end
end

class GraphQL::Types::Relay::BaseField
end

module GraphQL::Types::Relay::BaseInterface
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
end

module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  def default_relay(new_value); end

  def default_relay?(); end

  def to_graphql(); end
end

module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
end

module GraphQL::Types::Relay::BaseInterface
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::BaseInterface::DefinitionMethods
end

class GraphQL::Types::Relay::BaseObject
end

class GraphQL::Types::Relay::BaseObject
  def self.default_relay(new_value); end

  def self.default_relay?(); end
end

module GraphQL::Types::Relay::Node
  include ::GraphQL::Types::Relay::BaseInterface
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
end

module GraphQL::Types::Relay::Node::DefinitionMethods
end

module GraphQL::Types::Relay::Node::DefinitionMethods
end

module GraphQL::Types::Relay::Node
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  extend ::GraphQL::Types::Relay::Node::DefinitionMethods
end

class GraphQL::Types::Relay::PageInfo
end

class GraphQL::Types::Relay::PageInfo
end

module GraphQL::Types::Relay
end

class GraphQL::Types::String
end

class GraphQL::Types::String
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, ctx); end
end

module GraphQL::Types
end

class GraphQL::UnauthorizedError
  def context(); end

  def initialize(message=T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil)); end

  def object(); end

  def type(); end
end

class GraphQL::UnauthorizedError
end

class GraphQL::UnauthorizedFieldError
  def field(); end

  def field=(field); end

  def initialize(message=T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil), field: T.unsafe(nil)); end
end

class GraphQL::UnauthorizedFieldError
end

class GraphQL::UnionType
  def add_possible_types(types, **options); end

  def get_possible_type(type_name, ctx); end

  def include?(child_type_defn, ctx=T.unsafe(nil)); end

  def kind(); end

  def possible_type?(type, ctx); end

  def possible_types(ctx=T.unsafe(nil)); end

  def possible_types=(types); end

  def resolve_type=(new_resolve_type_proc); end

  def resolve_type_proc(); end

  def resolve_type_proc=(resolve_type_proc); end

  def type_membership_class(); end

  def type_membership_class=(type_membership_class); end

  def type_memberships(); end

  def type_memberships=(type_memberships); end
end

class GraphQL::UnionType::AcceptPossibleTypesDefinition
end

class GraphQL::UnionType::AcceptPossibleTypesDefinition
  def self.call(target, possible_types, options=T.unsafe(nil)); end
end

class GraphQL::UnionType
end

class GraphQL::UnresolvedTypeError
  def field(); end

  def initialize(value, field, parent_type, resolved_type, possible_types); end

  def parent_type(); end

  def possible_types(); end

  def resolved_type(); end

  def value(); end
end

class GraphQL::UnresolvedTypeError
end

module GraphQL
  def self.parse(graphql_string, tracer: T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_with_racc(string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end

  def self.scan(graphql_string); end

  def self.scan_with_ragel(graphql_string); end
end

class HTMLSelector
  def context(); end

  def css_selector(); end

  def initialize(values, previous_selection=T.unsafe(nil), &root_fallback); end

  def message(); end

  def select(); end

  def selecting_no_body?(); end

  def tests(); end
  NO_STRIP = ::T.let(nil, ::T.untyped)
end

class HTMLSelector
  def self.context(); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::Mocha::Inspect::HashMethods
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def assert_valid_keys(*valid_keys); end

  def compact(); end

  def compact!(); end

  def deep_merge(other_hash, &block); end

  def deep_merge!(other_hash, &block); end

  def deep_transform_values(&block); end

  def deep_transform_values!(&block); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def except(*keys); end

  def except!(*keys); end

  def extract!(*keys); end

  def extractable_options?(); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def nested_under_indifferent_access(); end

  def replace(_); end

  def reverse_merge(other_hash); end

  def reverse_merge!(other_hash); end

  def reverse_update(other_hash); end

  def slice(*_); end

  def slice!(*keys); end

  def to_h(); end

  def to_options!(); end

  def to_param(namespace=T.unsafe(nil)); end

  def to_proc(); end

  def to_query(namespace=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values!(); end

  def update(*_); end

  def with_defaults(other_hash); end

  def with_defaults!(other_hash); end

  def with_indifferent_access(); end
end

class Hash
  def self.from_trusted_xml(xml); end

  def self.from_xml(xml, disallowed_types=T.unsafe(nil)); end

  def self.try_convert(_); end
end

HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

module Hashdiff
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hashdiff::CompareHashes
end

class Hashdiff::CompareHashes
  def self.call(obj1, obj2, opts=T.unsafe(nil)); end
end

class Hashdiff::LcsCompareArrays
end

class Hashdiff::LcsCompareArrays
  def self.call(obj1, obj2, opts=T.unsafe(nil)); end
end

class Hashdiff::LinearCompareArray
  def call(); end

  def initialize(old_array, new_array, options); end
end

class Hashdiff::LinearCompareArray
  def self.call(old_array, new_array, options=T.unsafe(nil)); end
end

module Hashdiff
  def self.best_diff(obj1, obj2, options=T.unsafe(nil), &block); end

  def self.comparable?(obj1, obj2, strict=T.unsafe(nil)); end

  def self.compare_values(obj1, obj2, options=T.unsafe(nil)); end

  def self.count_diff(diffs); end

  def self.count_nodes(obj); end

  def self.custom_compare(method, key, obj1, obj2); end

  def self.decode_property_path(path, delimiter=T.unsafe(nil)); end

  def self.diff(obj1, obj2, options=T.unsafe(nil), &block); end

  def self.diff_array_lcs(arraya, arrayb, options=T.unsafe(nil)); end

  def self.lcs(arraya, arrayb, options=T.unsafe(nil)); end

  def self.node(hash, parts); end

  def self.patch!(obj, changes, options=T.unsafe(nil)); end

  def self.prefix_append_array_index(prefix, array_index, opts); end

  def self.prefix_append_key(prefix, key, opts); end

  def self.similar?(obja, objb, options=T.unsafe(nil)); end

  def self.unpatch!(obj, changes, options=T.unsafe(nil)); end
end

module Hashie
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hashie::Array
  include ::Hashie::Extensions::Array::PrettyInspect
  include ::Hashie::Extensions::RubyVersionCheck
  def array_inspect(); end

  def dig(*indexes); end
end

class Hashie::Array
end

module Hashie::Extensions
end

module Hashie::Extensions::Array
end

module Hashie::Extensions::Array::PrettyInspect
  def hashie_inspect(); end
end

module Hashie::Extensions::Array::PrettyInspect
  def self.included(base); end
end

module Hashie::Extensions::Array
end

module Hashie::Extensions::KeyConflictWarning
  def disable_warnings(*method_keys); end

  def disable_warnings?(method_key=T.unsafe(nil)); end

  def disabled_warnings(); end

  def inherited(subclass); end
end

class Hashie::Extensions::KeyConflictWarning::CannotDisableMashWarnings
  def initialize(); end
end

class Hashie::Extensions::KeyConflictWarning::CannotDisableMashWarnings
end

module Hashie::Extensions::KeyConflictWarning
end

module Hashie::Extensions::PrettyInspect
  def hashie_inspect(); end
end

module Hashie::Extensions::PrettyInspect
  def self.included(base); end
end

class Hashie::Extensions::RubyVersion
  include ::Comparable
  def initialize(version); end

  def segments(); end

  def segments=(segments); end
end

class Hashie::Extensions::RubyVersion
end

module Hashie::Extensions::RubyVersionCheck
end

module Hashie::Extensions::RubyVersionCheck
  def self.included(base); end
end

module Hashie::Extensions::StringifyKeys
  def stringify_keys(); end

  def stringify_keys!(); end
end

module Hashie::Extensions::StringifyKeys::ClassMethods
  def stringify_keys(hash); end

  def stringify_keys!(hash); end

  def stringify_keys_recursively!(object); end
end

module Hashie::Extensions::StringifyKeys::ClassMethods
end

module Hashie::Extensions::StringifyKeys
  extend ::Hashie::Extensions::StringifyKeys::ClassMethods
end

module Hashie::Extensions
end

class Hashie::Hash
  include ::Hashie::Extensions::PrettyInspect
  include ::Hashie::Extensions::StringifyKeys
  def hash_inspect(); end

  def to_hash(options=T.unsafe(nil)); end

  def to_json(*args); end

  def to_mash(); end
end

class Hashie::Hash
end

class Hashie::Mash
  include ::Hashie::Extensions::RubyVersionCheck
  def [](key); end

  def []=(key, value, convert=T.unsafe(nil)); end

  def assign_property(name, value); end

  def convert_key(key); end

  def convert_value(val, duping=T.unsafe(nil)); end

  def custom_reader(key); end

  def custom_writer(key, value, convert=T.unsafe(nil)); end

  def deep_merge(*other_hashes, &blk); end

  def deep_merge!(*other_hashes, &blk); end

  def deep_update(*other_hashes, &blk); end

  def delete(key); end

  def dig(*keys); end

  def fetch(key, *args); end

  def has_key?(key); end

  def include?(key); end

  def initialize(source_hash=T.unsafe(nil), default=T.unsafe(nil), &blk); end

  def initializing_reader(key); end

  def key?(key); end

  def member?(key); end

  def merge(*other_hashes, &blk); end

  def merge!(*other_hashes, &blk); end

  def method_missing(method_name, *args, &blk); end

  def method_name_and_suffix(method_name); end

  def method_suffix(method_name); end

  def prefix_method?(method_name); end

  def regular_dup(); end

  def regular_key?(_); end

  def regular_reader(_); end

  def regular_writer(_, _1); end

  def reject(&blk); end

  def replace(other_hash); end

  def select(&blk); end

  def shallow_merge(other_hash); end

  def shallow_update(other_hash); end

  def slice(*keys); end

  def to_module(mash_method_name=T.unsafe(nil)); end

  def transform_keys(&blk); end

  def transform_values(&blk); end

  def underbang_reader(key); end

  def update(*other_hashes, &blk); end

  def values_at(*keys); end

  def with_accessors!(); end
  ALLOWED_SUFFIXES = ::T.let(nil, ::T.untyped)
end

class Hashie::Mash
  extend ::Hashie::Extensions::KeyConflictWarning
  def self.load(path, options=T.unsafe(nil)); end

  def self.quiet(*method_keys); end
end

module Hashie::Utils
end

module Hashie::Utils
  def self.integer_classes(); end

  def self.method_information(bound_method); end

  def self.safe_dup(value); end
end

module Hashie
  def self.logger(); end

  def self.logger=(logger); end
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class I18n::ArgumentError
end

class I18n::ArgumentError
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
end

module I18n::Base
  def available_locales(); end

  def available_locales=(value); end

  def available_locales_initialized?(); end

  def backend(); end

  def backend=(value); end

  def config(); end

  def config=(value); end

  def default_locale(); end

  def default_locale=(value); end

  def default_separator(); end

  def default_separator=(value); end

  def eager_load!(); end

  def enforce_available_locales(); end

  def enforce_available_locales!(locale); end

  def enforce_available_locales=(value); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exists?(key, _locale=T.unsafe(nil), locale: T.unsafe(nil)); end

  def l(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def load_path(); end

  def load_path=(value); end

  def locale(); end

  def locale=(value); end

  def locale_available?(locale); end

  def localize(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def normalize_keys(locale, key, scope, separator=T.unsafe(nil)); end

  def reload!(); end

  def t(key=T.unsafe(nil), *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def t!(key, options=T.unsafe(nil)); end

  def translate(key=T.unsafe(nil), *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def translate!(key, options=T.unsafe(nil)); end

  def transliterate(key, *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), replacement: T.unsafe(nil), **options); end

  def with_locale(tmp_locale=T.unsafe(nil)); end
end

module I18n::Base
end

class I18n::Config
  def available_locales(); end

  def available_locales=(locales); end

  def available_locales_initialized?(); end

  def available_locales_set(); end

  def backend(); end

  def backend=(backend); end

  def clear_available_locales_set(); end

  def default_locale(); end

  def default_locale=(locale); end

  def default_separator(); end

  def default_separator=(separator); end

  def enforce_available_locales(); end

  def enforce_available_locales=(enforce_available_locales); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def interpolation_patterns(); end

  def interpolation_patterns=(interpolation_patterns); end

  def load_path(); end

  def load_path=(load_path); end

  def locale(); end

  def locale=(locale); end

  def missing_interpolation_argument_handler(); end

  def missing_interpolation_argument_handler=(exception_handler); end
end

class I18n::Config
end

class I18n::Disabled
  def initialize(method); end
end

class I18n::Disabled
end

class I18n::ExceptionHandler
  def call(exception, _locale, _key, _options); end
end

class I18n::ExceptionHandler
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::HashRefinements
end

module I18n::HashRefinements
end

class I18n::InvalidLocale
  def initialize(locale); end

  def locale(); end
end

class I18n::InvalidLocale
end

class I18n::InvalidLocaleData
  def filename(); end

  def initialize(filename, exception_message); end
end

class I18n::InvalidLocaleData
end

class I18n::InvalidPluralizationData
  def count(); end

  def entry(); end

  def initialize(entry, count, key); end

  def key(); end
end

class I18n::InvalidPluralizationData
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

class I18n::MissingInterpolationArgument
  def initialize(key, values, string); end

  def key(); end

  def string(); end

  def values(); end
end

class I18n::MissingInterpolationArgument
end

class I18n::MissingTranslation
  include ::I18n::MissingTranslation::Base
end

module I18n::MissingTranslation::Base
  def initialize(locale, key, options=T.unsafe(nil)); end

  def key(); end

  def keys(); end

  def locale(); end

  def message(); end

  def options(); end

  def to_exception(); end

  def to_s(); end
end

module I18n::MissingTranslation::Base
end

class I18n::MissingTranslation
end

class I18n::MissingTranslationData
  include ::I18n::MissingTranslation::Base
end

class I18n::MissingTranslationData
end

class I18n::Railtie
end

class I18n::Railtie
  def self.include_fallbacks_module(); end

  def self.init_fallbacks(fallbacks); end

  def self.initialize_i18n(app); end

  def self.validate_fallbacks(fallbacks); end

  def self.watched_dirs_with_extensions(paths); end
end

class I18n::ReservedInterpolationKey
  def initialize(key, string); end

  def key(); end

  def string(); end
end

class I18n::ReservedInterpolationKey
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

class I18n::UnknownFileType
  def filename(); end

  def initialize(type, filename); end

  def type(); end
end

class I18n::UnknownFileType
end

module I18n
  extend ::I18n::Base
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.interpolate(string, values); end

  def self.interpolate_hash(string, values); end

  def self.new_double_nested_cache(); end

  def self.perform_caching?(); end
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pread(*_); end

  def pressed?(); end

  def pwrite(_, _1); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Abort
end

class IRB::Abort
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def ap_name(); end

  def ap_name=(ap_name); end

  def auto_indent_mode(); end

  def auto_indent_mode=(auto_indent_mode); end

  def back_trace_limit(); end

  def back_trace_limit=(back_trace_limit); end

  def debug?(); end

  def debug_level(); end

  def debug_level=(value); end

  def echo(); end

  def echo=(echo); end

  def echo?(); end

  def eval_history=(*opts, &b); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def exit(ret=T.unsafe(nil)); end

  def file_input?(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ignore_eof?(); end

  def ignore_sigint(); end

  def ignore_sigint=(ignore_sigint); end

  def ignore_sigint?(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect?(); end

  def inspect_last_value(); end

  def inspect_mode(); end

  def inspect_mode=(opt); end

  def io(); end

  def io=(io); end

  def irb(); end

  def irb=(irb); end

  def irb_name(); end

  def irb_name=(irb_name); end

  def irb_path(); end

  def irb_path=(irb_path); end

  def last_value(); end

  def load_modules(); end

  def load_modules=(load_modules); end

  def main(); end

  def prompt_c(); end

  def prompt_c=(prompt_c); end

  def prompt_i(); end

  def prompt_i=(prompt_i); end

  def prompt_mode(); end

  def prompt_mode=(mode); end

  def prompt_n(); end

  def prompt_n=(prompt_n); end

  def prompt_s(); end

  def prompt_s=(prompt_s); end

  def prompting?(); end

  def rc(); end

  def rc=(rc); end

  def rc?(); end

  def return_format(); end

  def return_format=(return_format); end

  def save_history=(*opts, &b); end

  def set_last_value(value); end

  def thread(); end

  def use_loader=(*opts, &b); end

  def use_readline(); end

  def use_readline=(opt); end

  def use_readline?(); end

  def use_tracer=(*opts, &b); end

  def verbose(); end

  def verbose=(verbose); end

  def verbose?(); end

  def workspace(); end

  def workspace=(workspace); end

  def workspace_home(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::Context
end

module IRB::ContextExtender
end

IRB::ContextExtender::CE = IRB::ContextExtender

module IRB::ContextExtender
  def self.def_extend_command(cmd_name, load_file, *aliases); end

  def self.install_extend_commands(); end
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override=T.unsafe(nil)); end

  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_context(); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_exit(ret=T.unsafe(nil)); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_load(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_require(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.def_extend_command(cmd_name, cmd_class, load_file=T.unsafe(nil), *aliases); end

  def self.extend_object(obj); end

  def self.install_extend_commands(); end

  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(file); end
end

class IRB::FileInputMethod
end

class IRB::InputMethod
  def file_name(); end

  def gets(); end

  def initialize(file=T.unsafe(nil)); end

  def prompt(); end

  def prompt=(prompt); end

  def readable_after_eof?(); end
end

class IRB::InputMethod
end

class IRB::Inspector
  def init(); end

  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end

  def inspect_value(v); end
  INSPECTORS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def self.def_inspector(key, arg=T.unsafe(nil), &block); end

  def self.keys_with_inspector(inspector); end
end

class IRB::Irb
  def context(); end

  def eval_input(); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end

  def run(conf=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def signal_handle(); end

  def signal_status(status); end

  def suspend_context(context); end

  def suspend_input_method(input_method); end

  def suspend_name(path=T.unsafe(nil), name=T.unsafe(nil)); end

  def suspend_workspace(workspace); end
  ATTR_PLAIN = ::T.let(nil, ::T.untyped)
  ATTR_TTY = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end

  def def_pre_proc(base_method, extend_method); end

  def new_alias_name(name, prefix=T.unsafe(nil), postfix=T.unsafe(nil)); end
end

module IRB::MethodExtender
end

module IRB::Notifier
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
  D_NOMSG = ::T.let(nil, ::T.untyped)
end

class IRB::Notifier::AbstractNotifier
  def exec_if(); end

  def initialize(prefix, base_notifier); end

  def notify?(); end

  def ppx(prefix, *objs); end

  def prefix(); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::Notifier::AbstractNotifier
end

class IRB::Notifier::CompositeNotifier
  def def_notifier(level, prefix=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def level_notifier(); end

  def level_notifier=(value); end

  def notifiers(); end
end

class IRB::Notifier::CompositeNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::LeveledNotifier
  include ::Comparable
  def initialize(base, level, prefix); end

  def level(); end
end

class IRB::Notifier::LeveledNotifier
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::Notifier::NoMsgNotifier
end

module IRB::Notifier
  extend ::Exception2MessageMapper
  def self.def_notifier(prefix=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def self.included(mod); end
end

class IRB::OutputMethod
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def parse_printf_format(format, opts); end

  def ppx(prefix, *objs); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::ReadlineInputMethod
  include ::Readline
  include ::RbReadline
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReadlineInputMethod
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::StdioInputMethod
end

class IRB::StdioOutputMethod
end

class IRB::StdioOutputMethod
end

class IRB::WorkSpace
  def code_around_binding(); end

  def evaluate(context, statements, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def filter_backtrace(bt); end

  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end

  def main(); end
end

class IRB::WorkSpace
end

module IRB
  def self.CurrentContext(); end

  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.conf(); end

  def self.default_src_encoding(); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.irb_abort(irb, exception=T.unsafe(nil)); end

  def self.irb_at_exit(); end

  def self.irb_exit(irb, ret); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end

  def self.start(ap_path=T.unsafe(nil)); end

  def self.version(); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  include ::ActiveSupport::NumericWithFormat
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def multiple_of?(number); end

  def nobits?(_); end

  def ordinal(); end

  def ordinalize(); end

  def pow(*_); end

  def to_bn(); end

  def to_d(); end
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JWT
  include ::JWT::DefaultOptions
end

module JWT::Algos
end

module JWT::Algos::Ecdsa
  NAMED_CURVES = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Ecdsa
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Eddsa
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Eddsa
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Hmac
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Hmac
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Ps
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Ps
  def self.require_openssl!(); end

  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Rsa
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Rsa
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Unsupported
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Unsupported
  def self.sign(*_); end

  def self.verify(*_); end
end

module JWT::Algos
end

class JWT::Base64
end

class JWT::Base64
  def self.url_decode(str); end

  def self.url_encode(str); end
end

class JWT::ClaimsValidator
  def initialize(payload); end

  def validate!(); end
  INTEGER_CLAIMS = ::T.let(nil, ::T.untyped)
end

class JWT::ClaimsValidator
end

class JWT::Decode
  def decode_segments(); end

  def initialize(jwt, key, verify, options, &keyfinder); end
end

class JWT::Decode
end

class JWT::DecodeError
end

class JWT::DecodeError
end

module JWT::DefaultOptions
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module JWT::DefaultOptions
end

class JWT::Encode
  def initialize(options); end

  def segments(); end
  ALG_KEY = ::T.let(nil, ::T.untyped)
  ALG_NONE = ::T.let(nil, ::T.untyped)
end

class JWT::Encode
end

class JWT::EncodeError
end

class JWT::EncodeError
end

class JWT::ExpiredSignature
end

class JWT::ExpiredSignature
end

class JWT::ImmatureSignature
end

class JWT::ImmatureSignature
end

class JWT::IncorrectAlgorithm
end

class JWT::IncorrectAlgorithm
end

class JWT::InvalidAudError
end

class JWT::InvalidAudError
end

class JWT::InvalidIatError
end

class JWT::InvalidIatError
end

class JWT::InvalidIssuerError
end

class JWT::InvalidIssuerError
end

class JWT::InvalidJtiError
end

class JWT::InvalidJtiError
end

class JWT::InvalidPayload
end

class JWT::InvalidPayload
end

class JWT::InvalidSubError
end

class JWT::InvalidSubError
end

class JWT::JSON
end

class JWT::JSON
  def self.generate(data); end

  def self.parse(data); end
end

module JWT::JWK
  MAPPINGS = ::T.let(nil, ::T.untyped)
end

class JWT::JWK::KeyFinder
  def initialize(options); end

  def key_for(kid); end
end

class JWT::JWK::KeyFinder
end

class JWT::JWK::RSA
  def export(); end

  def initialize(keypair); end

  def keypair(); end

  def kid(); end

  def private?(*args, &block); end

  def public_key(*args, &block); end
  BINARY = ::T.let(nil, ::T.untyped)
  KTY = ::T.let(nil, ::T.untyped)
end

class JWT::JWK::RSA
  extend ::Forwardable
  def self.import(jwk_data); end
end

module JWT::JWK
  def self.create_from(keypair); end

  def self.import(jwk_data); end

  def self.new(keypair); end
end

class JWT::JWKError
end

class JWT::JWKError
end

class JWT::RequiredDependencyError
end

class JWT::RequiredDependencyError
end

module JWT::SecurityUtils
end

module JWT::SecurityUtils
  def self.asn1_to_raw(signature, public_key); end

  def self.raw_to_asn1(signature, private_key); end

  def self.rbnacl_fixup(algorithm, key); end

  def self.secure_compare(left, right); end

  def self.verify_ps(algorithm, public_key, signing_input, signature); end

  def self.verify_rsa(algorithm, public_key, signing_input, signature); end
end

module JWT::Signature
  def sign(algorithm, msg, key); end

  def verify(algorithm, key, signing_input, signature); end
  ALGOS = ::T.let(nil, ::T.untyped)
end

class JWT::Signature::ToSign
  def algorithm(); end

  def algorithm=(_); end

  def key(); end

  def key=(_); end

  def msg(); end

  def msg=(_); end
end

class JWT::Signature::ToSign
  def self.[](*_); end

  def self.members(); end
end

class JWT::Signature::ToVerify
  def algorithm(); end

  def algorithm=(_); end

  def public_key(); end

  def public_key=(_); end

  def signature(); end

  def signature=(_); end

  def signing_input(); end

  def signing_input=(_); end
end

class JWT::Signature::ToVerify
  def self.[](*_); end

  def self.members(); end
end

module JWT::Signature
  extend ::JWT::Signature
end

class JWT::VerificationError
end

class JWT::VerificationError
end

class JWT::Verify
  def initialize(payload, options); end

  def verify_aud(); end

  def verify_expiration(); end

  def verify_iat(); end

  def verify_iss(); end

  def verify_jti(); end

  def verify_not_before(); end

  def verify_sub(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class JWT::Verify
  def self.verify_aud(payload, options); end

  def self.verify_claims(payload, options); end

  def self.verify_expiration(payload, options); end

  def self.verify_iat(payload, options); end

  def self.verify_iss(payload, options); end

  def self.verify_jti(payload, options); end

  def self.verify_not_before(payload, options); end

  def self.verify_sub(payload, options); end
end

module JWT
  def self.decode(jwt, key=T.unsafe(nil), verify=T.unsafe(nil), options=T.unsafe(nil), &keyfinder); end

  def self.encode(payload, key, algorithm=T.unsafe(nil), header_fields=T.unsafe(nil)); end
end

module Kernel
  def byebug(); end

  def class_eval(*args, &block); end

  def debugger(); end

  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def remote_byebug(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end

  def self.load(*_); end

  def self.require(_); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

class LoadError
  def is_missing?(location); end

  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module LoggerSilence
end

module LoggerSilence
  extend ::ActiveSupport::Concern
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::DocumentDecorator
  def initialize(*args, &block); end
end

module Loofah::DocumentDecorator
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
end

module Loofah::HTML
end

class Loofah::HTML::Document
  include ::Loofah::ScrubBehavior::Node
  include ::Loofah::DocumentDecorator
  include ::Loofah::TextBehavior
  def serialize_root(); end
end

class Loofah::HTML::Document
end

class Loofah::HTML::DocumentFragment
  include ::Loofah::TextBehavior
  def serialize_root(); end
end

class Loofah::HTML::DocumentFragment
end

module Loofah::HTML
end

module Loofah::HTML5
end

module Loofah::HTML5::SafeList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::SafeList
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  def self.allowed_element?(element_name); end

  def self.force_correct_attribute_escaping!(node); end

  def self.scrub_attributes(node); end

  def self.scrub_css(style); end

  def self.scrub_css_attribute(node); end
end

Loofah::HTML5::WhiteList = Loofah::HTML5::SafeList

module Loofah::HTML5
end

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

module Loofah::LibxmlWorkarounds
end

module Loofah::MetaHelpers
end

module Loofah::MetaHelpers
  def self.add_downcased_set_members_to_all_set_constants(mojule); end
end

module Loofah::ScrubBehavior
end

module Loofah::ScrubBehavior::Node
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::Node
end

module Loofah::ScrubBehavior::NodeSet
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::NodeSet
end

module Loofah::ScrubBehavior
  def self.resolve_scrubber(scrubber); end
end

class Loofah::Scrubber
  def append_attribute(node, attribute, value); end

  def block(); end

  def direction(); end

  def initialize(options=T.unsafe(nil), &block); end

  def scrub(node); end

  def traverse(node); end
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
end

class Loofah::ScrubberNotFound
end

class Loofah::ScrubberNotFound
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubbers::Escape
  def initialize(); end
end

class Loofah::Scrubbers::Escape
end

class Loofah::Scrubbers::NewlineBlockElements
  def initialize(); end
end

class Loofah::Scrubbers::NewlineBlockElements
end

class Loofah::Scrubbers::NoFollow
  def initialize(); end
end

class Loofah::Scrubbers::NoFollow
end

class Loofah::Scrubbers::NoOpener
  def initialize(); end
end

class Loofah::Scrubbers::NoOpener
end

class Loofah::Scrubbers::Prune
  def initialize(); end
end

class Loofah::Scrubbers::Prune
end

class Loofah::Scrubbers::Strip
  def initialize(); end
end

class Loofah::Scrubbers::Strip
end

class Loofah::Scrubbers::Unprintable
  def initialize(); end
end

class Loofah::Scrubbers::Unprintable
end

class Loofah::Scrubbers::Whitewash
  def initialize(); end
end

class Loofah::Scrubbers::Whitewash
end

module Loofah::Scrubbers
  def self.scrubber_symbols(); end
end

module Loofah::TextBehavior
  def inner_text(options=T.unsafe(nil)); end

  def text(options=T.unsafe(nil)); end

  def to_str(options=T.unsafe(nil)); end

  def to_text(options=T.unsafe(nil)); end
end

module Loofah::TextBehavior
end

module Loofah::XML
end

class Loofah::XML::Document
  include ::Loofah::ScrubBehavior::Node
  include ::Loofah::DocumentDecorator
end

class Loofah::XML::Document
end

class Loofah::XML::DocumentFragment
end

class Loofah::XML::DocumentFragment
end

module Loofah::XML
end

module Loofah
  def self.document(*args, &block); end

  def self.fragment(*args, &block); end

  def self.remove_extraneous_whitespace(string); end

  def self.scrub_document(string_or_io, method); end

  def self.scrub_fragment(string_or_io, method); end

  def self.scrub_xml_document(string_or_io, method); end

  def self.scrub_xml_fragment(string_or_io, method); end

  def self.xml_document(*args, &block); end

  def self.xml_fragment(*args, &block); end
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::Address
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other_address); end

  def address(output_type=T.unsafe(nil)); end

  def address=(value); end

  def comments(); end

  def decoded(); end

  def display_name(output_type=T.unsafe(nil)); end

  def display_name=(str); end

  def domain(output_type=T.unsafe(nil)); end

  def encoded(); end

  def format(output_type=T.unsafe(nil)); end

  def group(); end

  def initialize(value=T.unsafe(nil)); end

  def local(output_type=T.unsafe(nil)); end

  def name(); end

  def raw(); end
end

class Mail::Address
  def self.wrap(address); end
end

class Mail::AddressContainer
  def <<(address); end

  def initialize(field, list=T.unsafe(nil)); end
end

class Mail::AddressContainer
end

class Mail::AddressList
  def addresses(); end

  def addresses_grouped_by_group(); end

  def group_names(); end

  def initialize(string); end
end

class Mail::AddressList
end

class Mail::AttachmentsList
  def [](index_value); end

  def []=(name, value); end

  def guess_encoding(); end

  def initialize(parts_list); end

  def inline(); end

  def set_mime_type(filename); end
end

class Mail::AttachmentsList
end

class Mail::BccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def include_in_headers(); end

  def include_in_headers=(include_in_headers); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::BccField
end

class Mail::Body
  def <<(val); end

  def ==(other); end

  def =~(regexp); end

  def ascii_only?(); end

  def boundary(); end

  def boundary=(val); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def default_encoding(); end

  def empty?(); end

  def encoded(transfer_encoding=T.unsafe(nil)); end

  def encoding(val=T.unsafe(nil)); end

  def encoding=(val); end

  def epilogue(); end

  def epilogue=(val); end

  def include?(other); end

  def initialize(string=T.unsafe(nil)); end

  def match(regexp); end

  def multipart?(); end

  def negotiate_best_encoding(message_encoding, allowed_encodings=T.unsafe(nil)); end

  def parts(); end

  def preamble(); end

  def preamble=(val); end

  def raw_source(); end

  def set_sort_order(order); end

  def sort_parts!(); end

  def split!(boundary); end
end

class Mail::Body
end

class Mail::CcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
end

module Mail::CheckDeliveryParams
end

module Mail::CheckDeliveryParams
  def self.check(mail); end

  def self.check_addr(addr_name, addr); end

  def self.check_from(addr); end

  def self.check_message(message); end

  def self.check_to(addrs); end

  def self.validate_smtp_addr(addr); end
end

class Mail::CommentsField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
end

module Mail::CommonAddress
  def <<(val); end

  def addresses(); end

  def addrs(); end

  def charset(); end

  def decoded_group_addresses(); end

  def default(); end

  def display_names(); end

  def each(&blk); end

  def encode_if_needed(val); end

  def encoded_group_addresses(); end

  def formatted(); end

  def group_addresses(); end

  def group_names(); end

  def groups(); end

  def parse(val=T.unsafe(nil)); end

  def value=(val); end
end

module Mail::CommonAddress
end

module Mail::CommonDate
  def date_time(); end

  def default(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonDate
end

module Mail::CommonField
  include ::Mail::Constants
  def default(); end

  def field_length(); end

  def name(); end

  def name=(value); end

  def responsible_for?(val); end

  def to_s(); end

  def value(); end

  def value=(value); end
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::CommonField
end

module Mail::CommonMessageId
  def default(); end

  def element(); end

  def message_id(); end

  def message_ids(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonMessageId
end

class Mail::Configuration
  include ::Singleton
  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def lookup_delivery_method(method); end

  def lookup_retriever_method(method); end

  def param_encode_language(value=T.unsafe(nil)); end

  def retriever_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end
end

class Mail::Configuration
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
end

class Mail::ContentDescriptionField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
end

class Mail::ContentDispositionElement
  def disposition_type(); end

  def initialize(string); end

  def parameters(); end
end

class Mail::ContentDispositionElement
end

class Mail::ContentDispositionField
  def decoded(); end

  def disposition_type(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionField
end

class Mail::ContentIdField
  def content_id(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
end

class Mail::ContentLocationElement
  def initialize(string); end

  def location(); end

  def to_s(*args); end
end

class Mail::ContentLocationElement
end

class Mail::ContentLocationField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def location(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationField
end

class Mail::ContentTransferEncodingElement
  def encoding(); end

  def initialize(string); end
end

class Mail::ContentTransferEncodingElement
end

class Mail::ContentTransferEncodingField
  def decoded(); end

  def element(); end

  def encoded(); end

  def encoding(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingField
end

class Mail::ContentTypeElement
  def initialize(string); end

  def main_type(); end

  def parameters(); end

  def sub_type(); end
end

class Mail::ContentTypeElement
end

class Mail::ContentTypeField
  def attempt_to_clean(); end

  def content_type(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def main_type(); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end

  def string(); end

  def stringify(params); end

  def sub_type(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeField
  def self.generate_boundary(); end

  def self.with_boundary(type); end
end

class Mail::DateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
end

class Mail::DateTimeElement
  def date_string(); end

  def initialize(string); end

  def time_string(); end
end

class Mail::DateTimeElement
end

module Mail::Encodings
  include ::Mail::Constants
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Base64
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
end

class Mail::Encodings::Identity
end

class Mail::Encodings::Identity
  def self.decode(str); end

  def self.encode(str); end
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  def self.can_encode?(enc); end

  def self.can_transport?(enc); end

  def self.compatible_input?(str); end

  def self.cost(str); end

  def self.lowest_cost(str, encodings); end

  def self.negotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end

  def self.renegotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  def self.decode(str); end

  def self.encode(str); end
end

module Mail::Encodings
  extend ::Mail::Utilities
  extend ::Mail::Constants
  def self.address_encode(address, charset=T.unsafe(nil)); end

  def self.b_value_decode(str); end

  def self.b_value_encode(string, encoding=T.unsafe(nil)); end

  def self.collapse_adjacent_encodings(str); end

  def self.decode_encode(str, output_type); end

  def self.defined?(name); end

  def self.each_base64_chunk_byterange(str, max_bytesize_per_base64_chunk, &block); end

  def self.each_chunk_byterange(str, max_bytesize_per_chunk); end

  def self.encode_non_usascii(address, charset); end

  def self.find_encoding(str); end

  def self.get_all(); end

  def self.get_encoding(name); end

  def self.get_name(name); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.q_value_decode(str); end

  def self.q_value_encode(encoded_str, encoding=T.unsafe(nil)); end

  def self.register(name, cls); end

  def self.transcode_charset(str, from_charset, to_charset=T.unsafe(nil)); end

  def self.unquote_and_convert_to(str, to_encoding); end

  def self.value_decode(str); end

  def self.value_encoding_from_string(str); end

  def self.with_ascii_kcode(); end
end

class Mail::Envelope
  def date(); end

  def element(); end

  def from(); end

  def initialize(*args); end
end

class Mail::Envelope
end

class Mail::EnvelopeFromElement
  def address(); end

  def date_time(); end

  def formatted_date_time(); end

  def initialize(string); end
end

class Mail::EnvelopeFromElement
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
end

class Mail::Field
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Comparable
  def ==(other); end

  def field(); end

  def field=(value); end

  def field_order_id(); end

  def initialize(name, value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def name(); end

  def responsible_for?(val); end

  def same(other); end

  def unparsed_value(); end

  def update(name, value); end

  def value(); end

  def value=(val); end
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Field::FieldError
end

class Mail::Field::FieldError
end

class Mail::Field::IncompleteParseError
  def initialize(element, original_text, unparsed_index); end
end

class Mail::Field::IncompleteParseError
end

class Mail::Field::NilParseError
  def initialize(element); end
end

class Mail::Field::NilParseError
end

class Mail::Field::ParseError
  def element(); end

  def element=(element); end

  def initialize(element, value, reason); end

  def reason(); end

  def reason=(reason); end

  def value(); end

  def value=(value); end
end

class Mail::Field::ParseError
end

class Mail::Field::SyntaxError
end

class Mail::Field::SyntaxError
end

class Mail::Field
  def self.parse(field, charset=T.unsafe(nil)); end

  def self.split(raw_field); end
end

class Mail::FieldList
  def <<(new_field); end
end

class Mail::FieldList
end

class Mail::FileDelivery
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::FileDelivery
end

class Mail::FromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::FromField
end

class Mail::Header
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Enumerable
  def [](name); end

  def []=(name, value); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def field_summary(); end

  def fields(); end

  def fields=(unfolded_fields); end

  def has_content_id?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def initialize(header_text=T.unsafe(nil), charset=T.unsafe(nil)); end

  def raw_source(); end
  LIMITED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Header
  def self.maximum_amount(); end

  def self.maximum_amount=(value); end
end

class Mail::IMAP
  def connection(&block); end

  def delete_all(mailbox=T.unsafe(nil)); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::IMAP
end

class Mail::InReplyToField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::InReplyToField
end

class Mail::IndifferentHash
  def []=(key, value); end

  def convert_key(key); end

  def convert_value(value); end

  def default(key=T.unsafe(nil)); end

  def delete(key); end

  def fetch(key, *extras); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash); end

  def merge!(other_hash); end

  def regular_update(*_); end

  def regular_writer(_, _1); end

  def store(key, value); end

  def update(other_hash); end

  def values_at(*indices); end
end

class Mail::IndifferentHash
  def self.new_from_hash_copying_default(hash); end
end

class Mail::KeywordsField
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def keywords(); end

  def parse(val=T.unsafe(nil)); end

  def phrase_list(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
end

class Mail::LoggerDelivery
  include ::Mail::CheckDeliveryParams
  def deliver!(mail); end

  def initialize(settings); end

  def logger(); end

  def settings(); end

  def severity(); end
end

class Mail::LoggerDelivery
end

module Mail::Matchers
  def an_attachment_with_filename(filename); end

  def any_attachment(); end

  def have_sent_email(); end
end

class Mail::Matchers::AnyAttachmentMatcher
  def ===(other); end
end

class Mail::Matchers::AnyAttachmentMatcher
end

class Mail::Matchers::AttachmentFilenameMatcher
  def ===(other); end

  def filename(); end

  def initialize(filename); end
end

class Mail::Matchers::AttachmentFilenameMatcher
end

class Mail::Matchers::HasSentEmailMatcher
  def bcc(recipient_or_list); end

  def cc(recipient_or_list); end

  def description(); end

  def dump_deliveries(); end

  def explain_expectations(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def filter_matched_deliveries(deliveries); end

  def from(sender); end

  def initialize(_context); end

  def matches?(subject); end

  def matches_on_attachments?(delivery); end

  def matches_on_blind_copy_recipients?(delivery); end

  def matches_on_body?(delivery); end

  def matches_on_body_matcher?(delivery); end

  def matches_on_copy_recipients?(delivery); end

  def matches_on_having_attachments?(delivery); end

  def matches_on_html_part_body?(delivery); end

  def matches_on_recipients?(delivery); end

  def matches_on_sender?(delivery); end

  def matches_on_subject?(delivery); end

  def matches_on_subject_matcher?(delivery); end

  def matches_on_text_part_body?(delivery); end

  def matching_body(body_matcher); end

  def matching_subject(subject_matcher); end

  def to(recipient_or_list); end

  def with_any_attachments(); end

  def with_attachments(attachments); end

  def with_body(body); end

  def with_html(body); end

  def with_no_attachments(); end

  def with_subject(subject); end

  def with_text(body); end
end

class Mail::Matchers::HasSentEmailMatcher
end

module Mail::Matchers
end

class Mail::Message
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def action(); end

  def add_charset(); end

  def add_content_transfer_encoding(); end

  def add_content_type(); end

  def add_date(date_val=T.unsafe(nil)); end

  def add_file(values); end

  def add_message_id(msg_id_val=T.unsafe(nil)); end

  def add_mime_version(ver_val=T.unsafe(nil)); end

  def add_part(part); end

  def add_transfer_encoding(); end

  def all_parts(); end

  def attachment(); end

  def attachment?(); end

  def attachments(); end

  def bcc(val=T.unsafe(nil)); end

  def bcc=(val); end

  def bcc_addresses(); end

  def bcc_addrs(); end

  def body(value=T.unsafe(nil)); end

  def body=(value); end

  def body_encoding(value=T.unsafe(nil)); end

  def body_encoding=(value); end

  def bounced?(); end

  def boundary(); end

  def cc(val=T.unsafe(nil)); end

  def cc=(val); end

  def cc_addresses(); end

  def cc_addrs(); end

  def charset(); end

  def charset=(value); end

  def comments(val=T.unsafe(nil)); end

  def comments=(val); end

  def content_description(val=T.unsafe(nil)); end

  def content_description=(val); end

  def content_disposition(val=T.unsafe(nil)); end

  def content_disposition=(val); end

  def content_id(val=T.unsafe(nil)); end

  def content_id=(val); end

  def content_location(val=T.unsafe(nil)); end

  def content_location=(val); end

  def content_transfer_encoding(val=T.unsafe(nil)); end

  def content_transfer_encoding=(val); end

  def content_type(val=T.unsafe(nil)); end

  def content_type=(val); end

  def content_type_parameters(); end

  def convert_to_multipart(); end

  def date(val=T.unsafe(nil)); end

  def date=(val); end

  def decode_body(); end

  def decoded(); end

  def default(sym, val=T.unsafe(nil)); end

  def deliver(); end

  def deliver!(); end

  def delivery_handler(); end

  def delivery_handler=(delivery_handler); end

  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def delivery_status_part(); end

  def delivery_status_report?(); end

  def destinations(); end

  def diagnostic_code(); end

  def encode!(); end

  def encoded(); end

  def envelope_date(); end

  def envelope_from(); end

  def error_status(); end

  def errors(); end

  def filename(); end

  def final_recipient(); end

  def find_first_mime_type(mt); end

  def from(val=T.unsafe(nil)); end

  def from=(val); end

  def from_address(); end

  def from_addrs(); end

  def has_attachments?(); end

  def has_charset?(); end

  def has_content_transfer_encoding?(); end

  def has_content_type?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def has_transfer_encoding?(); end

  def header(value=T.unsafe(nil)); end

  def header=(value); end

  def header_fields(); end

  def headers(hash=T.unsafe(nil)); end

  def html_part(&block); end

  def html_part=(msg); end

  def in_reply_to(val=T.unsafe(nil)); end

  def in_reply_to=(val); end

  def inform_interceptors(); end

  def inform_observers(); end

  def initialize(*args, &block); end

  def is_marked_for_delete?(); end

  def keywords(val=T.unsafe(nil)); end

  def keywords=(val); end

  def main_type(); end

  def mark_for_delete=(value=T.unsafe(nil)); end

  def message_content_type(); end

  def message_id(val=T.unsafe(nil)); end

  def message_id=(val); end

  def method_missing(name, *args, &block); end

  def mime_parameters(); end

  def mime_type(); end

  def mime_version(val=T.unsafe(nil)); end

  def mime_version=(val); end

  def multipart?(); end

  def multipart_report?(); end

  def part(params=T.unsafe(nil)); end

  def parts(); end

  def perform_deliveries(); end

  def perform_deliveries=(perform_deliveries); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(raise_delivery_errors); end

  def raw_envelope(); end

  def raw_source(); end

  def read(); end

  def ready_to_send!(); end

  def received(val=T.unsafe(nil)); end

  def received=(val); end

  def recipients(); end

  def recipients_addresses(); end

  def references(val=T.unsafe(nil)); end

  def references=(val); end

  def register_for_delivery_notification(observer); end

  def remote_mta(); end

  def reply(*args, &block); end

  def reply_to(val=T.unsafe(nil)); end

  def reply_to=(val); end

  def resent_bcc(val=T.unsafe(nil)); end

  def resent_bcc=(val); end

  def resent_cc(val=T.unsafe(nil)); end

  def resent_cc=(val); end

  def resent_date(val=T.unsafe(nil)); end

  def resent_date=(val); end

  def resent_from(val=T.unsafe(nil)); end

  def resent_from=(val); end

  def resent_message_id(val=T.unsafe(nil)); end

  def resent_message_id=(val); end

  def resent_sender(val=T.unsafe(nil)); end

  def resent_sender=(val); end

  def resent_to(val=T.unsafe(nil)); end

  def resent_to=(val); end

  def retryable?(); end

  def return_path(val=T.unsafe(nil)); end

  def return_path=(val); end

  def sender(val=T.unsafe(nil)); end

  def sender=(val); end

  def set_envelope(val); end

  def skip_deletion(); end

  def smtp_envelope_from(val=T.unsafe(nil)); end

  def smtp_envelope_from=(val); end

  def smtp_envelope_to(val=T.unsafe(nil)); end

  def smtp_envelope_to=(val); end

  def sub_type(); end

  def subject(val=T.unsafe(nil)); end

  def subject=(val); end

  def text?(); end

  def text_part(&block); end

  def text_part=(msg); end

  def to(val=T.unsafe(nil)); end

  def to=(val); end

  def to_addresses(); end

  def to_addrs(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def transfer_encoding(); end

  def transport_encoding(val=T.unsafe(nil)); end

  def transport_encoding=(val); end

  def without_attachments!(); end

  def x_original_to_addresses(); end
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::Message
  def self.default_charset(); end

  def self.default_charset=(charset); end

  def self.from_hash(hash); end

  def self.from_yaml(str); end
end

class Mail::MessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
end

class Mail::MessageIdsElement
  def initialize(string); end

  def message_id(); end

  def message_ids(); end
end

class Mail::MessageIdsElement
end

class Mail::MimeVersionElement
  def initialize(string); end

  def major(); end

  def minor(); end
end

class Mail::MimeVersionElement
end

class Mail::MimeVersionField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def major(); end

  def minor(); end

  def parse(val=T.unsafe(nil)); end

  def version(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MimeVersionField
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Chars
  include ::Comparable
  def =~(other); end

  def [](*args); end

  def []=(*args); end

  def acts_like_string?(); end

  def capitalize(); end

  def capitalize!(*args); end

  def chars(string); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def g_length(); end

  def initialize(string); end

  def justify(integer, way, padstr=T.unsafe(nil)); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def padding(padsize, padstr=T.unsafe(nil)); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def translate_offset(byte_offset); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class Mail::Multibyte::Chars
  def self.consumes?(string); end
end

class Mail::Multibyte::EncodingError
end

class Mail::Multibyte::EncodingError
end

module Mail::Multibyte::Unicode
  def apply_mapping(string, mapping); end

  def compose_codepoints(codepoints); end

  def decompose_codepoints(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def g_pack(unpacked); end

  def g_unpack(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def reorder_characters(codepoints); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def u_unpack(string); end
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def swapcase_mapping(); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class Mail::Multibyte::Unicode::Codepoint
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module Mail::Multibyte::Unicode
  extend ::Mail::Multibyte::Unicode
  def self.codepoints_to_pattern(array_of_codepoints); end
end

module Mail::Multibyte
  def self.clean(string); end

  def self.mb_chars(str); end

  def self.proxy_class(); end

  def self.proxy_class=(proxy_class); end

  def self.valid_character(); end

  def self.verify(string); end

  def self.verify!(string); end
end

class Mail::OptionalField
end

class Mail::OptionalField
end

class Mail::POP3
  def connection(&block); end

  def delete_all(); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::POP3
end

class Mail::ParameterHash
  include ::Mail::Utilities
  include ::Mail::Constants
  def [](key_name); end

  def decoded(); end

  def encoded(); end
end

class Mail::ParameterHash
end

module Mail::ParserTools
  def chars(data, from_bytes, to_bytes); end
end

module Mail::ParserTools
end

module Mail::Parsers
end

module Mail::Parsers::AddressListsParser
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def addresses(); end

  def addresses=(_); end

  def error(); end

  def error=(_); end

  def group_names(); end

  def group_names=(_); end
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def comments(); end

  def comments=(_); end

  def display_name(); end

  def display_name=(_); end

  def domain(); end

  def domain=(_); end

  def error(); end

  def error=(_); end

  def group(); end

  def group=(_); end

  def local(); end

  def local=(_); end

  def obs_domain_list(); end

  def obs_domain_list=(_); end

  def raw(); end

  def raw=(_); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::AddressListsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentDispositionParser
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def disposition_type(); end

  def disposition_type=(_); end

  def error(); end

  def error=(_); end

  def parameters(); end

  def parameters=(_); end
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentDispositionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentLocationParser
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def error(); end

  def error=(_); end

  def location(); end

  def location=(_); end
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentLocationParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTransferEncodingParser
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def encoding(); end

  def encoding=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentTransferEncodingParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTypeParser
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def error(); end

  def error=(_); end

  def main_type(); end

  def main_type=(_); end

  def parameters(); end

  def parameters=(_); end

  def sub_type(); end

  def sub_type=(_); end
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentTypeParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::DateTimeParser
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def date_string(); end

  def date_string=(_); end

  def error(); end

  def error=(_); end

  def time_string(); end

  def time_string=(_); end
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::DateTimeParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::EnvelopeFromParser
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def address(); end

  def address=(_); end

  def ctime_date(); end

  def ctime_date=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::EnvelopeFromParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MessageIdsParser
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def error(); end

  def error=(_); end

  def message_ids(); end

  def message_ids=(_); end
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::MessageIdsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MimeVersionParser
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def error(); end

  def error=(_); end

  def major(); end

  def major=(_); end

  def minor(); end

  def minor=(_); end
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::MimeVersionParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

class Mail::Parsers::PhraseListsParser
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def error(); end

  def error=(_); end

  def phrases(); end

  def phrases=(_); end
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::PhraseListsParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ReceivedParser
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def date(); end

  def date=(_); end

  def error(); end

  def error=(_); end

  def info(); end

  def info=(_); end

  def time(); end

  def time=(_); end
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ReceivedParser
  extend ::Mail::ParserTools
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers
end

class Mail::Part
  def add_content_id(content_id_val=T.unsafe(nil)); end

  def cid(); end

  def delivery_status_data(); end

  def delivery_status_report_part?(); end

  def has_content_id?(); end

  def inline?(); end

  def inline_content_id(); end

  def url(); end
end

class Mail::Part
end

class Mail::PartsList
  def attachments(); end

  def collect(); end

  def collect!(); end

  def encode_with(coder); end

  def initialize(*args); end

  def map(); end

  def map!(); end

  def parts(); end

  def sort(); end

  def sort!(order); end

  def to_yaml(options=T.unsafe(nil)); end
end

class Mail::PartsList
end

class Mail::PhraseList
  def initialize(string); end

  def phrases(); end
end

class Mail::PhraseList
end

class Mail::ReceivedElement
  include ::Mail::Utilities
  include ::Mail::Constants
  def date_time(); end

  def info(); end

  def initialize(string); end

  def to_s(*args); end
end

class Mail::ReceivedElement
end

class Mail::ReceivedField
  def date_time(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def formatted_date(); end

  def info(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReceivedField
end

class Mail::ReferencesField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
end

class Mail::ReplyToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
end

class Mail::ResentBccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
end

class Mail::ResentCcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
end

class Mail::ResentDateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
end

class Mail::ResentFromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
end

class Mail::ResentMessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
end

class Mail::ResentSenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
end

class Mail::ResentToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
end

class Mail::Retriever
  def all(options=T.unsafe(nil), &block); end

  def find_and_delete(options=T.unsafe(nil), &block); end

  def first(options=T.unsafe(nil), &block); end

  def last(options=T.unsafe(nil), &block); end
end

class Mail::Retriever
end

class Mail::ReturnPathField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
end

class Mail::Ruby19
end

class Mail::Ruby19::BestEffortCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::BestEffortCharsetEncoder
end

class Mail::Ruby19::StrictCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::StrictCharsetEncoder
end

class Mail::Ruby19
  def self.b_value_decode(str); end

  def self.b_value_encode(str, encoding=T.unsafe(nil)); end

  def self.bracket(str); end

  def self.charset_encoder(); end

  def self.charset_encoder=(charset_encoder); end

  def self.decode_base64(str); end

  def self.decode_utf7(utf7); end

  def self.encode_base64(str); end

  def self.encode_utf7(string); end

  def self.escape_bracket(str); end

  def self.escape_paren(str); end

  def self.get_constant(klass, string); end

  def self.has_constant?(klass, string); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.paren(str); end

  def self.pick_encoding(charset); end

  def self.q_value_decode(str); end

  def self.q_value_encode(str, encoding=T.unsafe(nil)); end

  def self.string_byteslice(str, *args); end

  def self.transcode_charset(str, from_encoding, to_encoding=T.unsafe(nil)); end

  def self.uri_parser(); end
end

Mail::RubyVer = Mail::Ruby19

class Mail::SMTP
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SMTP
end

class Mail::SMTPConnection
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end

  def smtp(); end

  def smtp=(smtp); end
end

class Mail::SMTPConnection
end

class Mail::SenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SenderField
end

class Mail::Sendmail
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  def self.call(path, arguments, destinations, encoded_message); end

  def self.popen(command, &block); end

  def self.shellquote(address); end
end

class Mail::StructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(val); end

  def errors(); end

  def initialize(name=T.unsafe(nil), value=T.unsafe(nil), charset=T.unsafe(nil)); end
end

class Mail::StructuredField
end

class Mail::SubjectField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
end

class Mail::TestMailer
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::TestMailer
  def self.deliveries(); end

  def self.deliveries=(val); end
end

class Mail::TestRetriever
  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end
end

class Mail::TestRetriever
  def self.emails(); end

  def self.emails=(val); end
end

class Mail::ToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ToField
end

class Mail::UnknownEncodingType
end

class Mail::UnknownEncodingType
end

class Mail::UnstructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(charset); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def initialize(name, value, charset=T.unsafe(nil)); end

  def parse(); end
end

class Mail::UnstructuredField
end

module Mail::Utilities
  include ::Mail::Constants
  def atom_safe?(str); end

  def bracket(str); end

  def capitalize_field(str); end

  def constantize(str); end

  def dasherize(str); end

  def dquote(str); end

  def escape_paren(str); end

  def map_lines(str, &block); end

  def map_with_index(enum, &block); end

  def match_to_s(obj1, obj2); end

  def paren(str); end

  def quote_atom(str); end

  def quote_phrase(str); end

  def quote_token(str); end

  def token_safe?(str); end

  def unbracket(str); end

  def underscoreize(str); end

  def unparen(str); end

  def uri_escape(str); end

  def uri_parser(); end

  def uri_unescape(str); end
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  def self.binary_unsafe_to_crlf(string); end

  def self.binary_unsafe_to_lf(string); end

  def self.blank?(value); end

  def self.safe_for_line_ending_conversion?(string); end

  def self.to_crlf(string); end

  def self.to_lf(string); end

  def self.unescape(str); end

  def self.unquote(str); end
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  def self.version(); end
end

module Mail
  def self.all(*args, &block); end

  def self.connection(&block); end

  def self.defaults(&block); end

  def self.delete_all(*args, &block); end

  def self.deliver(*args, &block); end

  def self.delivery_method(); end

  def self.eager_autoload!(); end

  def self.find(*args, &block); end

  def self.find_and_delete(*args, &block); end

  def self.first(*args, &block); end

  def self.from_source(source); end

  def self.inform_interceptors(mail); end

  def self.inform_observers(mail); end

  def self.last(*args, &block); end

  def self.new(*args, &block); end

  def self.random_tag(); end

  def self.read(filename); end

  def self.read_from_string(mail_as_string); end

  def self.register_autoload(name, path); end

  def self.register_interceptor(interceptor); end

  def self.register_observer(observer); end

  def self.retriever_method(); end

  def self.something_random(); end

  def self.uniq(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_observer(observer); end
end

module Marcel
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  def self.extend(type, extensions: T.unsafe(nil), parents: T.unsafe(nil), magic: T.unsafe(nil)); end

  def self.for(pathname_or_io=T.unsafe(nil), name: T.unsafe(nil), extension: T.unsafe(nil), declared_type: T.unsafe(nil)); end
end

module Marcel
end

module Marshal
  extend ::ActiveSupport::MarshalWithAutoloading
  def self.restore(*_); end
end

class Method
  include ::MethodSource::SourceLocation::MethodExtensions
  include ::MethodSource::MethodExtensions
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers
  def comment_describing(file, line_number); end

  def complete_expression?(str); end

  def expression_at(file, line_number, options=T.unsafe(nil)); end
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  def self.===(ex); end

  def self.rbx?(); end
end

module MethodSource::CodeHelpers
end

module MethodSource::MethodExtensions
  def comment(); end

  def source(); end
end

module MethodSource::MethodExtensions
  def self.included(klass); end
end

module MethodSource::ReeSourceLocation
  def source_location(); end
end

module MethodSource::ReeSourceLocation
end

module MethodSource::SourceLocation
end

module MethodSource::SourceLocation::MethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::MethodExtensions
end

module MethodSource::SourceLocation::ProcExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::ProcExtensions
end

module MethodSource::SourceLocation::UnboundMethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::UnboundMethodExtensions
end

module MethodSource::SourceLocation
end

class MethodSource::SourceNotFoundError
end

class MethodSource::SourceNotFoundError
end

module MethodSource
  extend ::MethodSource::CodeHelpers
  def self.comment_helper(source_location, name=T.unsafe(nil)); end

  def self.extract_code(source_location); end

  def self.lines_for(file_name, name=T.unsafe(nil)); end

  def self.source_helper(source_location, name=T.unsafe(nil)); end

  def self.valid_expression?(str); end
end

Methods = T::Private::Methods

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
end

class Mime::AllType
  include ::Singleton
  def initialize(); end
end

class Mime::AllType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Mimes
  include ::Enumerable
  def <<(type); end

  def delete_if(); end

  def each(&blk); end

  def symbols(); end
end

class Mime::Mimes
end

class Mime::NullType
  include ::Singleton
  def ref(); end
end

class Mime::NullType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Type
  def ==(mime_type); end

  def ===(list); end

  def =~(mime_type); end

  def all?(); end

  def eql?(other); end

  def html?(); end

  def initialize(string, symbol=T.unsafe(nil), synonyms=T.unsafe(nil)); end

  def ref(); end

  def string(); end

  def symbol(); end

  def synonyms(); end

  def to_str(); end

  def to_sym(); end
  MIME_NAME = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_KEY = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_VALUE = ::T.let(nil, ::T.untyped)
  MIME_REGEXP = ::T.let(nil, ::T.untyped)
end

class Mime::Type::AcceptItem
  def index(); end

  def index=(index); end

  def initialize(index, name, q=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def q(); end

  def q=(q); end
end

class Mime::Type::AcceptItem
end

class Mime::Type::AcceptList
end

class Mime::Type::AcceptList
  def self.find_item_by_name(array, name); end

  def self.sort!(list); end
end

class Mime::Type::InvalidMimeType
end

class Mime::Type::InvalidMimeType
end

class Mime::Type
  def self.lookup(string); end

  def self.lookup_by_extension(extension); end

  def self.parse(accept_header); end

  def self.parse_data_with_trailing_star(type); end

  def self.parse_trailing_star(accept_header); end

  def self.register(string, symbol, mime_type_synonyms=T.unsafe(nil), extension_synonyms=T.unsafe(nil), skip_lookup=T.unsafe(nil)); end

  def self.register_alias(string, symbol, extension_synonyms=T.unsafe(nil)); end

  def self.register_callback(&block); end

  def self.unregister(symbol); end
end

module Mime
  def self.[](type); end

  def self.fetch(type); end
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

module MiniMime::Configuration
end

module MiniMime::Configuration
  def self.content_type_db_path(); end

  def self.content_type_db_path=(content_type_db_path); end

  def self.ext_db_path(); end

  def self.ext_db_path=(ext_db_path); end
end

class MiniMime::Db
  def lookup_by_content_type(content_type); end

  def lookup_by_extension(extension); end
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::Cache
  def []=(key, val); end

  def fetch(key, &blk); end

  def initialize(size); end
end

class MiniMime::Db::Cache
end

class MiniMime::Db::RandomAccessDb
  def initialize(path, sort_order); end

  def lookup(val); end

  def lookup_uncached(val); end

  def resolve(row); end
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
end

class MiniMime::Db
  def self.lookup_by_content_type(content_type); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

class MiniMime::Info
  def [](idx); end

  def binary?(); end

  def content_type(); end

  def content_type=(content_type); end

  def encoding(); end

  def encoding=(encoding); end

  def extension(); end

  def extension=(extension); end

  def initialize(buffer); end
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
end

module MiniMime
  def self.lookup_by_content_type(mime); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

MiniTest = Minitest

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::AbstractReporter
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def passed?(); end

  def prerecord(klass, name); end

  def record(result); end

  def report(); end

  def start(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class Minitest::AbstractReporter
end

class Minitest::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
end

class Minitest::Assertion
end

module Minitest::Assertions
  def _synchronize(); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_mock(mock); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), bt=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

class Minitest::BacktraceFilter
  def filter(bt); end
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
end

class Minitest::CompositeReporter
  def <<(reporter); end

  def initialize(*reporters); end

  def io(); end

  def reporters(); end

  def reporters=(reporters); end
end

class Minitest::CompositeReporter
end

class Minitest::Expectation
  def ctx(); end

  def ctx=(_); end

  def target(); end

  def target=(_); end
end

class Minitest::Expectation
  def self.[](*_); end

  def self.members(); end
end

module Minitest::Expectations
  def must_be(*args); end

  def must_be_close_to(*args); end

  def must_be_empty(*args); end

  def must_be_instance_of(*args); end

  def must_be_kind_of(*args); end

  def must_be_nil(*args); end

  def must_be_same_as(*args); end

  def must_be_silent(*args); end

  def must_be_within_delta(*args); end

  def must_be_within_epsilon(*args); end

  def must_equal(*args); end

  def must_include(*args); end

  def must_match(*args); end

  def must_output(*args); end

  def must_raise(*args); end

  def must_respond_to(*args); end

  def must_throw(*args); end

  def path_must_exist(*args); end

  def path_wont_exist(*args); end

  def wont_be(*args); end

  def wont_be_close_to(*args); end

  def wont_be_empty(*args); end

  def wont_be_instance_of(*args); end

  def wont_be_kind_of(*args); end

  def wont_be_nil(*args); end

  def wont_be_same_as(*args); end

  def wont_be_within_delta(*args); end

  def wont_be_within_epsilon(*args); end

  def wont_equal(*args); end

  def wont_include(*args); end

  def wont_match(*args); end

  def wont_respond_to(*args); end
end

module Minitest::Expectations
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

module Minitest::Guard
end

class Minitest::Mock
  def ===(*args, &b); end

  def __call(name, data); end

  def __respond_to?(*_); end

  def class(*args, &b); end

  def expect(name, retval, args=T.unsafe(nil), &blk); end

  def initialize(delegator=T.unsafe(nil)); end

  def inspect(*args, &b); end

  def instance_eval(*args, &b); end

  def instance_variables(*args, &b); end

  def method_missing(sym, *args, &block); end

  def object_id(*args, &b); end

  def public_send(*args, &b); end

  def respond_to?(sym, include_private=T.unsafe(nil)); end

  def send(*args, &b); end

  def to_s(*args, &b); end

  def verify(); end
end

class Minitest::Mock
end

module Minitest::Parallel
end

class Minitest::Parallel::Executor
  def <<(work); end

  def initialize(size); end

  def shutdown(); end

  def size(); end

  def start(); end
end

class Minitest::Parallel::Executor
end

module Minitest::Parallel::Test
  def _synchronize(); end
end

module Minitest::Parallel::Test::ClassMethods
  def run_one_method(klass, method_name, reporter); end

  def test_order(); end
end

module Minitest::Parallel::Test::ClassMethods
end

module Minitest::Parallel::Test
end

module Minitest::Parallel
end

class Minitest::ProgressReporter
end

class Minitest::ProgressReporter
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
end

module Minitest::Reportable
end

class Minitest::Reporter
  def initialize(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def options(); end

  def options=(options); end
end

class Minitest::Reporter
end

class Minitest::Result
  include ::Minitest::Reportable
  def klass(); end

  def klass=(klass); end

  def source_location(); end

  def source_location=(source_location); end
end

class Minitest::Result
  def self.from(runnable); end
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::Skip
end

class Minitest::Skip
end

class Minitest::Spec
  include ::Minitest::Spec::DSL::InstanceMethods
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL
  def after(_type=T.unsafe(nil), &block); end

  def before(_type=T.unsafe(nil), &block); end

  def children(); end

  def create(name, desc); end

  def desc(); end

  def describe_stack(); end

  def it(desc=T.unsafe(nil), &block); end

  def let(name, &block); end

  def name(); end

  def nuke_test_methods!(); end

  def register_spec_type(*args, &block); end

  def spec_type(desc, *additional); end

  def specify(desc=T.unsafe(nil), &block); end

  def subject(&block); end

  def to_s(); end
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL::InstanceMethods
  def _(value=T.unsafe(nil), &block); end

  def before_setup(); end

  def expect(value=T.unsafe(nil), &block); end

  def value(value=T.unsafe(nil), &block); end
end

module Minitest::Spec::DSL::InstanceMethods
end

module Minitest::Spec::DSL
  def self.extended(obj); end
end

class Minitest::Spec
  extend ::Minitest::Spec::DSL
  def self.current(); end
end

class Minitest::StatisticsReporter
  def assertions(); end

  def assertions=(assertions); end

  def count(); end

  def count=(count); end

  def errors(); end

  def errors=(errors); end

  def failures(); end

  def failures=(failures); end

  def results(); end

  def results=(results); end

  def skips(); end

  def skips=(skips); end

  def start_time(); end

  def start_time=(start_time); end

  def total_time(); end

  def total_time=(total_time); end
end

class Minitest::StatisticsReporter
end

class Minitest::SummaryReporter
  def aggregated_results(io); end

  def old_sync(); end

  def old_sync=(old_sync); end

  def statistics(); end

  def summary(); end

  def sync(); end

  def sync=(sync); end
end

class Minitest::SummaryReporter
end

class Minitest::Test
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  include ::Mocha::Integration::MiniTest::Adapter
  include ::Mocha::API
  include ::Mocha::ParameterMatchers
  include ::Mocha::Hooks
  include ::WebMock::API
  def assert_request_not_requested(*args); end

  def assert_request_not_requested_with_assertions_count(*args); end

  def assert_request_requested(*args); end

  def assert_request_requested_with_assertions_count(*args); end

  def capture_exceptions(); end

  def teardown_with_webmock(); end

  def teardown_without_webmock(); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

module Minitest::Test::LifecycleHooks
end

class Minitest::Test
  extend ::Minitest::Guard
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end

  def self.test_order(); end
end

class Minitest::UnexpectedError
  def error=(error); end

  def initialize(error); end
end

class Minitest::UnexpectedError
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit::TestCase
end

class Minitest::Unit::TestCase
end

class Minitest::Unit
  def self.after_tests(&b); end

  def self.autorun(); end
end

module Minitest
  def self.__run(reporter, options); end

  def self.after_run(&block); end

  def self.backtrace_filter(); end

  def self.backtrace_filter=(backtrace_filter); end

  def self.clock_time(); end

  def self.extensions(); end

  def self.extensions=(extensions); end

  def self.filter_backtrace(bt); end

  def self.info_signal(); end

  def self.info_signal=(info_signal); end

  def self.init_plugins(options); end

  def self.load_plugins(); end

  def self.parallel_executor(); end

  def self.parallel_executor=(parallel_executor); end

  def self.process_args(args=T.unsafe(nil)); end

  def self.reporter(); end

  def self.reporter=(reporter); end

  def self.run_one_method(klass, method_name); end
end

module Mocha
  PRE_RUBY_V19 = ::T.let(nil, ::T.untyped)
  RUBY_V2_PLUS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Mocha::API
  include ::Mocha::ParameterMatchers
  include ::Mocha::Hooks
  def mock(*arguments); end

  def sequence(name); end

  def states(name); end

  def stub(*arguments); end

  def stub_everything(*arguments); end
end

module Mocha::API
  def self.extended(mod); end

  def self.included(_mod); end
end

class Mocha::AnyInstanceMethod
end

class Mocha::AnyInstanceMethod
end

class Mocha::AnyInstanceReceiver
  def initialize(klass); end

  def mocks(); end
end

class Mocha::AnyInstanceReceiver
end

class Mocha::ArgumentIterator
  def each(&blk); end

  def initialize(argument); end
end

class Mocha::ArgumentIterator
end

class Mocha::BacktraceFilter
  def filtered(backtrace); end

  def initialize(lib_directory=T.unsafe(nil)); end
  LIB_DIRECTORY = ::T.let(nil, ::T.untyped)
end

class Mocha::BacktraceFilter
end

module Mocha::BlockMatchers
end

class Mocha::BlockMatchers::BlockGiven
  def match?(actual_block); end
end

class Mocha::BlockMatchers::BlockGiven
end

class Mocha::BlockMatchers::NoBlockGiven
  def match?(actual_block); end
end

class Mocha::BlockMatchers::NoBlockGiven
end

class Mocha::BlockMatchers::OptionalBlock
  def match?(_actual_block); end
end

class Mocha::BlockMatchers::OptionalBlock
end

module Mocha::BlockMatchers
end

class Mocha::Cardinality
  def <<(invocation); end

  def actual_invocations(); end

  def allowed_any_number_of_times?(); end

  def anticipated_times(); end

  def infinite?(number); end

  def initialize(required, maximum); end

  def invocations_allowed?(); end

  def invoked_times(); end

  def maximum(); end

  def needs_verifying?(); end

  def required(); end

  def satisfied?(); end

  def times(number); end

  def used?(); end

  def verified?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class Mocha::Cardinality
  def self.at_least(count); end

  def self.at_most(count); end

  def self.exactly(count); end

  def self.times(range_or_count); end
end

class Mocha::Central
  def stub(method); end

  def stubba_methods(); end

  def stubba_methods=(stubba_methods); end

  def unstub(method); end

  def unstub_all(); end
end

class Mocha::Central::Null
  def initialize(&block); end

  def stub(*_); end

  def unstub(*_); end
end

class Mocha::Central::Null
end

class Mocha::Central
end

class Mocha::ChangeStateSideEffect
  def initialize(state); end

  def perform(); end
end

class Mocha::ChangeStateSideEffect
end

module Mocha::ClassMethods
  def __method_exists__?(method, include_public_methods=T.unsafe(nil)); end

  def __method_visibility__(method, include_public_methods=T.unsafe(nil)); end

  def any_instance(); end
end

module Mocha::ClassMethods
end

class Mocha::Configuration
  def display_matching_invocations_on_failure=(value); end

  def display_matching_invocations_on_failure?(); end

  def initialize(options=T.unsafe(nil)); end

  def merge(other); end

  def options(); end

  def reinstate_undocumented_behaviour_from_v1_9=(value); end

  def reinstate_undocumented_behaviour_from_v1_9?(); end

  def stubbing_method_on_nil(); end

  def stubbing_method_on_nil=(value); end

  def stubbing_method_on_non_mock_object(); end

  def stubbing_method_on_non_mock_object=(value); end

  def stubbing_method_unnecessarily(); end

  def stubbing_method_unnecessarily=(value); end

  def stubbing_non_existent_method(); end

  def stubbing_non_existent_method=(value); end

  def stubbing_non_public_method(); end

  def stubbing_non_public_method=(value); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mocha::Configuration
  def self.allow(action, &block); end

  def self.allow?(action); end

  def self.configuration(); end

  def self.override(temporary_options); end

  def self.prevent(action, &block); end

  def self.prevent?(action); end

  def self.reset_configuration(); end

  def self.warn_when(action, &block); end

  def self.warn_when?(action); end
end

module Mocha::Debug
  OPTIONS = ::T.let(nil, ::T.untyped)
end

module Mocha::Debug
  def self.puts(message); end
end

class Mocha::DefaultName
  def initialize(mock); end
end

class Mocha::DefaultName
end

class Mocha::DefaultReceiver
  def initialize(mock); end

  def mocks(); end
end

class Mocha::DefaultReceiver
end

class Mocha::Deprecation
end

class Mocha::Deprecation
  def self.messages(); end

  def self.messages=(messages); end

  def self.mode(); end

  def self.mode=(mode); end

  def self.warning(*messages); end
end

module Mocha::Detection
end

module Mocha::Detection::MiniTest
end

module Mocha::Detection::MiniTest
  def self.testcase(); end

  def self.version(); end
end

module Mocha::Detection::TestUnit
end

module Mocha::Detection::TestUnit
  def self.testcase(); end

  def self.version(); end
end

module Mocha::Detection
end

class Mocha::ErrorWithFilteredBacktrace
  def initialize(message=T.unsafe(nil), backtrace=T.unsafe(nil)); end
end

class Mocha::ErrorWithFilteredBacktrace
end

class Mocha::ExceptionRaiser
  def evaluate(invocation); end

  def initialize(exception, message); end
end

class Mocha::ExceptionRaiser
end

class Mocha::Expectation
  def add_in_sequence_ordering_constraint(sequence); end

  def add_ordering_constraint(ordering_constraint); end

  def add_side_effect(side_effect); end

  def at_least(minimum_number_of_times); end

  def at_least_once(); end

  def at_most(maximum_number_of_times); end

  def at_most_once(); end

  def backtrace(); end

  def in_correct_order?(); end

  def in_sequence(sequence, *sequences); end

  def initialize(mock, expected_method_name, backtrace=T.unsafe(nil)); end

  def invocations_allowed?(); end

  def invoke(invocation); end

  def match?(invocation); end

  def matches_method?(method_name); end

  def method_signature(); end

  def multiple_yields(*parameter_groups); end

  def never(); end

  def once(); end

  def perform_side_effects(); end

  def raises(exception=T.unsafe(nil), message=T.unsafe(nil)); end

  def returns(*values); end

  def satisfied?(); end

  def then(*parameters); end

  def throws(tag, object=T.unsafe(nil)); end

  def times(range); end

  def twice(); end

  def used?(); end

  def verified?(assertion_counter=T.unsafe(nil)); end

  def when(state_predicate); end

  def with(*expected_parameters, &matching_block); end

  def with_block_given(); end

  def with_no_block_given(); end

  def yields(*parameters); end
end

class Mocha::Expectation
end

class Mocha::ExpectationError
end

class Mocha::ExpectationError
end

class Mocha::ExpectationErrorFactory
end

class Mocha::ExpectationErrorFactory
  def self.build(message=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def self.exception_class(); end

  def self.exception_class=(exception_class); end
end

class Mocha::ExpectationList
  def +(other); end

  def add(expectation); end

  def any?(); end

  def initialize(expectations=T.unsafe(nil)); end

  def length(); end

  def match(invocation); end

  def match_allowing_invocation(invocation); end

  def matches_method?(method_name); end

  def remove_all_matching_method(method_name); end

  def to_a(); end

  def to_set(); end

  def verified?(assertion_counter=T.unsafe(nil)); end
end

class Mocha::ExpectationList
end

module Mocha::Hooks
  def mocha_setup(); end

  def mocha_teardown(); end

  def mocha_verify(assertion_counter=T.unsafe(nil)); end
end

module Mocha::Hooks
end

class Mocha::ImpersonatingAnyInstanceName
  def initialize(klass); end
end

class Mocha::ImpersonatingAnyInstanceName
end

class Mocha::ImpersonatingName
  def initialize(object); end
end

class Mocha::ImpersonatingName
end

class Mocha::InStateOrderingConstraint
  def allows_invocation_now?(); end

  def initialize(state_predicate); end
end

class Mocha::InStateOrderingConstraint
end

module Mocha::Inspect
end

module Mocha::Inspect::ArrayMethods
  def mocha_inspect(); end
end

module Mocha::Inspect::ArrayMethods
end

module Mocha::Inspect::DateMethods
  def mocha_inspect(); end
end

module Mocha::Inspect::DateMethods
end

module Mocha::Inspect::HashMethods
  def mocha_inspect(); end
end

module Mocha::Inspect::HashMethods
end

module Mocha::Inspect::ObjectMethods
  def mocha_inspect(); end
end

module Mocha::Inspect::ObjectMethods
end

module Mocha::Inspect::TimeMethods
  def mocha_inspect(); end
end

module Mocha::Inspect::TimeMethods
end

module Mocha::Inspect
end

class Mocha::InstanceMethod
end

class Mocha::InstanceMethod
end

module Mocha::Integration
end

class Mocha::Integration::AssertionCounter
  def increment(); end

  def initialize(test_case); end
end

class Mocha::Integration::AssertionCounter
end

module Mocha::Integration::MiniTest
end

module Mocha::Integration::MiniTest::Adapter
  include ::Mocha::API
  include ::Mocha::ParameterMatchers
  include ::Mocha::Hooks
  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end
end

module Mocha::Integration::MiniTest::Adapter
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(_mod); end
end

module Mocha::Integration::MiniTest::Nothing
end

module Mocha::Integration::MiniTest::Nothing
  def self.applicable_to?(_test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(_mod); end
end

module Mocha::Integration::MiniTest::Version13
end

module Mocha::Integration::MiniTest::Version13::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version13::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version13
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version140
end

module Mocha::Integration::MiniTest::Version140::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version140::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version140
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version141
end

module Mocha::Integration::MiniTest::Version141::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version141::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version141
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version142To172
end

module Mocha::Integration::MiniTest::Version142To172::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version142To172::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version142To172
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version200
end

module Mocha::Integration::MiniTest::Version200::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version200::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version200
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version201To222
end

module Mocha::Integration::MiniTest::Version201To222::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version201To222::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version201To222
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version2110To2111
end

module Mocha::Integration::MiniTest::Version2110To2111::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version2110To2111::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version2110To2111
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version2112To320
end

module Mocha::Integration::MiniTest::Version2112To320::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version2112To320::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version2112To320
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest::Version230To2101
end

module Mocha::Integration::MiniTest::Version230To2101::RunMethodPatch
  def run(runner); end
end

module Mocha::Integration::MiniTest::Version230To2101::RunMethodPatch
end

module Mocha::Integration::MiniTest::Version230To2101
  def self.applicable_to?(mini_test_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::MiniTest
  def self.activate(); end

  def self.translate(exception); end
end

module Mocha::Integration::MonkeyPatcher
end

module Mocha::Integration::MonkeyPatcher
  def self.apply(mod, run_method_patch); end
end

module Mocha::Integration::TestUnit
end

module Mocha::Integration::TestUnit::Adapter
  include ::Mocha::API
  include ::Mocha::ParameterMatchers
  include ::Mocha::Hooks
end

module Mocha::Integration::TestUnit::Adapter
  def self.applicable_to?(test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::GemVersion200
end

module Mocha::Integration::TestUnit::GemVersion200::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::GemVersion200::RunMethodPatch
end

module Mocha::Integration::TestUnit::GemVersion200
  def self.applicable_to?(test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::GemVersion201To202
end

module Mocha::Integration::TestUnit::GemVersion201To202::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::GemVersion201To202::RunMethodPatch
end

module Mocha::Integration::TestUnit::GemVersion201To202
  def self.applicable_to?(test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::GemVersion203To220
end

module Mocha::Integration::TestUnit::GemVersion203To220::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::GemVersion203To220::RunMethodPatch
end

module Mocha::Integration::TestUnit::GemVersion203To220
  def self.applicable_to?(test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::GemVersion230To250
end

module Mocha::Integration::TestUnit::GemVersion230To250::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::GemVersion230To250::RunMethodPatch
end

module Mocha::Integration::TestUnit::GemVersion230To250
  def self.applicable_to?(test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::Nothing
end

module Mocha::Integration::TestUnit::Nothing
  def self.applicable_to?(_test_unit_version, _ruby_version=T.unsafe(nil)); end

  def self.description(); end

  def self.included(_mod); end
end

module Mocha::Integration::TestUnit::RubyVersion185AndBelow
end

module Mocha::Integration::TestUnit::RubyVersion185AndBelow::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::RubyVersion185AndBelow::RunMethodPatch
end

module Mocha::Integration::TestUnit::RubyVersion185AndBelow
  def self.applicable_to?(test_unit_version, ruby_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit::RubyVersion186AndAbove
end

module Mocha::Integration::TestUnit::RubyVersion186AndAbove::RunMethodPatch
  def run(result); end
end

module Mocha::Integration::TestUnit::RubyVersion186AndAbove::RunMethodPatch
end

module Mocha::Integration::TestUnit::RubyVersion186AndAbove
  def self.applicable_to?(test_unit_version, ruby_version); end

  def self.description(); end

  def self.included(mod); end
end

module Mocha::Integration::TestUnit
  def self.activate(); end
end

module Mocha::Integration
  def self.activate(); end
end

class Mocha::Invocation
  def arguments(); end

  def block(); end

  def call(yield_parameters=T.unsafe(nil), return_values=T.unsafe(nil)); end

  def call_description(); end

  def full_description(); end

  def initialize(mock, method_name, *arguments, &block); end

  def method_name(); end

  def raised(exception); end

  def result_description(); end

  def returned(value); end

  def short_call_description(); end

  def threw(tag, value); end
end

class Mocha::Invocation
end

class Mocha::Logger
  def initialize(io); end

  def warn(message); end
end

class Mocha::Logger
end

class Mocha::MethodMatcher
  def expected_method_name(); end

  def initialize(expected_method_name); end

  def match?(actual_method_name); end
end

class Mocha::MethodMatcher
end

class Mocha::Mock
  def __expectations__(); end

  def __expects__(method_name_or_hash, backtrace=T.unsafe(nil)); end

  def __expire__(); end

  def __singleton_class__(); end

  def __stubs__(method_name_or_hash, backtrace=T.unsafe(nil)); end

  def __verified__?(assertion_counter=T.unsafe(nil)); end

  def all_expectations(); end

  def any_expectations?(); end

  def ensure_method_not_already_defined(method_name); end

  def everything_stubbed(); end

  def expects(method_name_or_hash, backtrace=T.unsafe(nil)); end

  def initialize(mockery, name=T.unsafe(nil), receiver=T.unsafe(nil)); end

  def method_missing(symbol, *arguments, &block); end

  def quacks_like(responder); end

  def quacks_like_instance_of(responder_class); end

  def responds_like(responder); end

  def responds_like_instance_of(responder_class); end

  def stub_everything(); end

  def stubs(method_name_or_hash, backtrace=T.unsafe(nil)); end
end

class Mocha::Mock
end

class Mocha::Mockery
  def logger(); end

  def logger=(logger); end

  def mock_impersonating(object); end

  def mock_impersonating_any_instance_of(klass); end

  def mocks(); end

  def named_mock(name); end

  def new_state_machine(name); end

  def on_stubbing(object, method); end

  def on_stubbing_method_unnecessarily(expectation); end

  def state_machines(); end

  def stubba(); end

  def teardown(); end

  def unnamed_mock(); end

  def verify(assertion_counter=T.unsafe(nil)); end
end

class Mocha::Mockery::Null
  def add_mock(*_); end

  def add_state_machine(*_); end
end

class Mocha::Mockery::Null
end

class Mocha::Mockery
  def self.instance(); end

  def self.setup(); end

  def self.teardown(); end

  def self.verify(*args); end
end

class Mocha::Name
  def initialize(name); end
end

class Mocha::Name
end

class Mocha::NotInitializedError
end

class Mocha::NotInitializedError
end

module Mocha::ObjectMethods
  def _method(_); end

  def expects(expected_methods_vs_return_values); end

  def mocha(instantiate=T.unsafe(nil)); end

  def reset_mocha(); end

  def stubba_class(); end

  def stubba_method(); end

  def stubba_object(); end

  def stubs(stubbed_methods_vs_return_values); end

  def unstub(*method_names); end
end

module Mocha::ObjectMethods
end

class Mocha::ObjectReceiver
  def initialize(object); end

  def mocks(); end
end

class Mocha::ObjectReceiver
end

module Mocha::ParameterMatchers
  def Not(matcher); end

  def all_of(*matchers); end

  def any_of(*matchers); end

  def any_parameters(); end

  def anything(); end

  def equals(value); end

  def equivalent_uri(uri); end

  def has_entries(entries); end

  def has_entry(*options); end

  def has_key(key); end

  def has_value(value); end

  def includes(*items); end

  def instance_of(klass); end

  def is_a(klass); end

  def kind_of(klass); end

  def optionally(*matchers); end

  def regexp_matches(regexp); end

  def responds_with(message, result); end

  def yaml_equivalent(object); end
end

module Mocha::ParameterMatchers::InstanceMethods
  def to_matcher(); end
end

module Mocha::ParameterMatchers::InstanceMethods
end

module Mocha::ParameterMatchers
end

class Mocha::ParametersMatcher
  def initialize(expected_parameters=T.unsafe(nil), &matching_block); end

  def match?(actual_parameters=T.unsafe(nil)); end

  def matchers(); end

  def parameters_match?(actual_parameters); end
end

class Mocha::ParametersMatcher
end

class Mocha::RaisedException
  def initialize(exception); end
end

class Mocha::RaisedException
end

class Mocha::ReturnValues
  def +(other); end

  def initialize(*values); end

  def next(invocation); end

  def values(); end

  def values=(values); end
end

class Mocha::ReturnValues
  def self.build(*values); end
end

class Mocha::Sequence
  def constrain_as_next_in_sequence(expectation); end

  def initialize(name); end

  def satisfied_to_index?(index); end
end

class Mocha::Sequence::InSequenceOrderingConstraint
  def allows_invocation_now?(); end

  def initialize(sequence, index); end
end

class Mocha::Sequence::InSequenceOrderingConstraint
end

class Mocha::Sequence
end

class Mocha::SingleReturnValue
  def evaluate(invocation); end

  def initialize(value); end
end

class Mocha::SingleReturnValue
end

class Mocha::StateMachine
  def become(next_state_name); end

  def current_state(); end

  def current_state=(current_state); end

  def initialize(name); end

  def is(state_name); end

  def is_not(state_name); end

  def name(); end

  def starts_as(initial_state_name); end
end

class Mocha::StateMachine::State
  def activate(); end

  def active?(); end

  def initialize(state_machine, state); end
end

class Mocha::StateMachine::State
end

class Mocha::StateMachine::StatePredicate
  def active?(); end

  def initialize(state_machine, state); end
end

class Mocha::StateMachine::StatePredicate
end

class Mocha::StateMachine
end

class Mocha::StubbedMethod
  def define_new_method(); end

  def hide_original_method(); end

  def initialize(stubbee, method_name); end

  def matches?(other); end

  def method_name(); end

  def mock(); end

  def remove_new_method(); end

  def restore_original_method(); end

  def store_original_method(); end

  def stub(); end

  def stubbee(); end

  def unstub(); end
end

class Mocha::StubbedMethod::PrependedModule
end

class Mocha::StubbedMethod::PrependedModule
end

class Mocha::StubbedMethod
end

class Mocha::StubbingError
end

class Mocha::StubbingError
end

class Mocha::Thrower
  def evaluate(invocation); end

  def initialize(tag, object=T.unsafe(nil)); end
end

class Mocha::Thrower
end

class Mocha::ThrownObject
  def initialize(tag, value=T.unsafe(nil)); end
end

class Mocha::ThrownObject
end

class Mocha::YieldParameters
  def add(*parameter_groups); end

  def next_invocation(); end
end

class Mocha::YieldParameters
end

module Mocha
  def self.activate(); end

  def self.configuration(); end

  def self.configure(); end
end

class MockExpectationError
end

class MockExpectationError
end

class Module
  include ::ActiveSupport::Dependencies::ModuleConstMissing
  include ::Module::Concerning
  def alias_attribute(new_name, old_name); end

  def anonymous?(); end

  def attr_internal(*attrs); end

  def attr_internal_accessor(*attrs); end

  def attr_internal_reader(*attrs); end

  def attr_internal_writer(*attrs); end

  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  def delegate_missing_to(target); end

  def deprecate(*method_names); end

  def deprecate_constant(*_); end

  def infect_an_assertion(meth, new_name, dont_flip=T.unsafe(nil)); end

  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def method_visibility(method); end

  def module_parent(); end

  def module_parent_name(); end

  def module_parents(); end

  def parent(); end

  def parent_name(); end

  def parents(); end

  def rake_extension(method); end

  def redefine_method(method, &block); end

  def redefine_singleton_method(method, &block); end

  def remove_possible_method(method); end

  def remove_possible_singleton_method(method); end

  def silence_redefinition_of_method(method); end

  def thread_cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def undef_method(*_); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module Module::Concerning
  def concern(topic, &module_definition); end

  def concerning(topic, &block); end
end

module Module::Concerning
end

class Module::DelegationError
end

class Module::DelegationError
end

class Module
  def self.attr_internal_naming_format(); end

  def self.attr_internal_naming_format=(attr_internal_naming_format); end

  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

module MultiJson
  include ::MultiJson::Options
  def adapter(); end

  def adapter=(new_adapter); end

  def cached_options(*_); end

  def current_adapter(options=T.unsafe(nil)); end

  def decode(string, options=T.unsafe(nil)); end

  def default_adapter(); end

  def default_engine(); end

  def default_options(); end

  def default_options=(value); end

  def dump(object, options=T.unsafe(nil)); end

  def encode(object, options=T.unsafe(nil)); end

  def engine(); end

  def engine=(new_adapter); end

  def load(string, options=T.unsafe(nil)); end

  def load_adapter(new_adapter); end

  def reset_cached_options!(*_); end

  def use(new_adapter); end

  def with_adapter(new_adapter); end

  def with_engine(new_adapter); end
  ALIASES = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class MultiJson::AdapterError
end

class MultiJson::AdapterError
  def self.build(original_exception); end
end

MultiJson::DecodeError = MultiJson::ParseError

MultiJson::LoadError = MultiJson::ParseError

module MultiJson::Options
  def default_dump_options(); end

  def default_load_options(); end

  def dump_options(*args); end

  def dump_options=(options); end

  def load_options(*args); end

  def load_options=(options); end
end

module MultiJson::Options
end

module MultiJson::OptionsCache
  def fetch(type, key, &block); end

  def reset(); end
  MAX_CACHE_SIZE = ::T.let(nil, ::T.untyped)
end

module MultiJson::OptionsCache
  extend ::MultiJson::OptionsCache
end

class MultiJson::ParseError
  def data(); end
end

class MultiJson::ParseError
  def self.build(original_exception, data); end
end

class MultiJson::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
end

class MultiJson::Version
end

module MultiJson
  extend ::MultiJson
  extend ::MultiJson::Options
end

module MultiXml
  CONTENT_ROOT = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DISALLOWED_XML_TYPES = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class MultiXml::DisallowedTypeError
  def initialize(type); end
end

class MultiXml::DisallowedTypeError
end

class MultiXml::NoParserError
end

class MultiXml::NoParserError
end

class MultiXml::ParseError
end

class MultiXml::ParseError
end

module MultiXml
  def self.default_parser(); end

  def self.parse(xml, options=T.unsafe(nil)); end

  def self.parser(); end

  def self.parser=(new_parser); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

class NameError
  include ::DidYouMean::Correctable
  def missing_name(); end

  def missing_name?(name); end

  def name(); end

  def receiver(); end
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  def open_timeout(); end

  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  Revision = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

Net::SMTPSession = Net::SMTP

module Net::WebMockHTTPResponse
  def read_body(dest=T.unsafe(nil), &block); end
end

module Net::WebMockHTTPResponse
end

class Net::WebMockNetBufferedIO
  def initialize(io, *args, **kwargs); end
end

class Net::WebMockNetBufferedIO
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_d(); end

  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS
end

class Nokogiri::CSS::Node
  def accept(visitor); end

  def find_by_type(types); end

  def initialize(type, value); end

  def to_a(); end

  def to_type(); end

  def to_xpath(prefix=T.unsafe(nil), visitor=T.unsafe(nil)); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
end

class Nokogiri::CSS::Parser
  def _reduce_1(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_7(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(namespaces=T.unsafe(nil)); end

  def on_error(error_token_id, error_value, value_stack); end

  def parse(string); end

  def unescape_css_identifier(identifier); end

  def unescape_css_string(str); end

  def xpath_for(string, options=T.unsafe(nil)); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  def self.[](string); end

  def self.[]=(string, value); end

  def self.cache_on(); end

  def self.cache_on=(cache_on); end

  def self.cache_on?(); end

  def self.clear_cache(); end

  def self.parse(selector); end

  def self.set_cache(_); end

  def self.without_cache(&block); end
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::Tokenizer
  def _next_token(); end

  def action(); end

  def filename(); end

  def lineno(); end

  def load_file(filename); end

  def next_token(); end

  def scan(str); end

  def scan_file(filename); end

  def scan_setup(str); end

  def scan_str(str); end

  def state(); end

  def state=(state); end
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer
end

class Nokogiri::CSS::XPathVisitor
  def accept(node); end

  def visit_attribute_condition(node); end

  def visit_child_selector(node); end

  def visit_class_condition(node); end

  def visit_combinator(node); end

  def visit_conditional_selector(node); end

  def visit_descendant_selector(node); end

  def visit_direct_adjacent_selector(node); end

  def visit_element_name(node); end

  def visit_following_selector(node); end

  def visit_function(node); end

  def visit_id(node); end

  def visit_not(node); end

  def visit_pseudo_class(node); end
end

class Nokogiri::CSS::XPathVisitor
end

module Nokogiri::CSS
  def self.parse(selector); end

  def self.xpath_for(selector, options=T.unsafe(nil)); end
end

module Nokogiri::Decorators
end

module Nokogiri::Decorators::Slop
  def method_missing(name, *args, &block); end
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
end

module Nokogiri::Decorators
end

class Nokogiri::EncodingHandler
  def name(); end
end

class Nokogiri::EncodingHandler
  def self.[](_); end

  def self.alias(_, _1); end

  def self.clear_aliases!(); end

  def self.delete(_); end
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::Builder
  def to_html(); end
end

class Nokogiri::HTML::Builder
end

class Nokogiri::HTML::Document
  def meta_encoding(); end

  def meta_encoding=(encoding); end

  def serialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(text); end
end

class Nokogiri::HTML::Document
end

class Nokogiri::HTML::DocumentFragment
end

class Nokogiri::HTML::DocumentFragment
  def self.parse(tags, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::ElementDescription
  def block?(); end

  def default_sub_element(); end

  def deprecated?(); end

  def deprecated_attributes(); end

  def description(); end

  def empty?(); end

  def implied_end_tag?(); end

  def implied_start_tag?(); end

  def inline?(); end

  def name(); end

  def optional_attributes(); end

  def required_attributes(); end

  def save_end_tag?(); end

  def sub_elements(); end
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

class Nokogiri::HTML::ElementDescription
  def self.[](_); end
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityLookup
  def [](name); end

  def get(_); end
end

class Nokogiri::HTML::EntityLookup
end

module Nokogiri::HTML::SAX
end

class Nokogiri::HTML::SAX::Parser
  def parse_file(filename, encoding=T.unsafe(nil)); end

  def parse_memory(data, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::SAX::Parser
end

class Nokogiri::HTML::SAX::ParserContext
end

class Nokogiri::HTML::SAX::ParserContext
  def self.file(_, _1); end

  def self.memory(_, _1); end
end

class Nokogiri::HTML::SAX::PushParser
end

class Nokogiri::HTML::SAX::PushParser
end

module Nokogiri::HTML::SAX
end

module Nokogiri::HTML
  def self.fragment(string, encoding=T.unsafe(nil)); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

class Nokogiri::SyntaxError
end

class Nokogiri::SyntaxError
end

class Nokogiri::VersionInfo
  def compiled_parser_version(); end

  def engine(); end

  def jruby?(); end

  def libxml2?(); end

  def libxml2_using_packaged?(); end

  def libxml2_using_system?(); end

  def loaded_parser_version(); end

  def to_hash(); end

  def to_markdown(); end

  def warnings(); end
end

class Nokogiri::VersionInfo
  def self.instance(); end
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Attr
  def content=(content); end

  def value(); end

  def value=(value); end
end

class Nokogiri::XML::Attr
end

class Nokogiri::XML::AttributeDecl
  def attribute_type(); end

  def default(); end

  def enumeration(); end
end

class Nokogiri::XML::AttributeDecl
end

class Nokogiri::XML::Builder
  def <<(string); end

  def [](ns); end

  def arity(); end

  def arity=(arity); end

  def cdata(string); end

  def comment(string); end

  def context(); end

  def context=(context); end

  def doc(); end

  def doc=(doc); end

  def initialize(options=T.unsafe(nil), root=T.unsafe(nil), &block); end

  def method_missing(method, *args, &block); end

  def parent(); end

  def parent=(parent); end

  def text(string); end

  def to_xml(*args); end
end

class Nokogiri::XML::Builder
  def self.with(root, &block); end
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CharacterData
  include ::Nokogiri::XML::PP::CharacterData
end

class Nokogiri::XML::CharacterData
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::DTD
  def entities(); end

  def external_id(); end

  def html5_dtd?(); end

  def html_dtd?(); end

  def notations(); end

  def system_id(); end

  def validate(_); end
end

class Nokogiri::XML::DTD
end

class Nokogiri::XML::Document
  def canonicalize(*_); end

  def collect_namespaces(); end

  def create_cdata(string, &block); end

  def create_comment(string, &block); end

  def create_element(name, *args, &block); end

  def create_entity(*_); end

  def create_text_node(string, &block); end

  def decorate(node); end

  def decorators(key); end

  def encoding(); end

  def encoding=(encoding); end

  def errors(); end

  def errors=(errors); end

  def fragment(tags=T.unsafe(nil)); end

  def initialize(*args); end

  def remove_namespaces!(); end

  def root(); end

  def root=(root); end

  def slop!(); end

  def to_java(); end

  def to_xml(*args, &block); end

  def url(); end

  def validate(); end

  def version(); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  def self.empty_doc?(string_or_io); end

  def self.parse(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.read_io(_, _1, _2, _3); end

  def self.read_memory(_, _1, _2, _3); end

  def self.wrap(document); end
end

class Nokogiri::XML::DocumentFragment
  def dup(); end

  def errors(); end

  def errors=(things); end

  def initialize(document, tags=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def search(*rules); end

  def serialize(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end
end

class Nokogiri::XML::DocumentFragment
  def self.parse(tags); end
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  def children(); end

  def document(); end

  def name(); end

  def occur(); end

  def prefix(); end

  def type(); end
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ElementContent
end

class Nokogiri::XML::ElementDecl
  def element_type(); end

  def prefix(); end
end

class Nokogiri::XML::ElementDecl
end

class Nokogiri::XML::EntityDecl
  def entity_type(); end

  def external_id(); end

  def original_content(); end

  def system_id(); end
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  def self.new(name, doc, *args); end
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::Namespace
  include ::Nokogiri::XML::PP::Node
  def document(); end

  def href(); end

  def prefix(); end
end

class Nokogiri::XML::Namespace
end

class Nokogiri::XML::Node
  include ::Nokogiri::XML::PP::Node
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def <<(node_or_tags); end

  def ==(other); end

  def >(selector); end

  def [](name); end

  def []=(name, value); end

  def accept(visitor); end

  def add_child(node_or_tags); end

  def add_class(name); end

  def add_namespace(_, _1); end

  def add_namespace_definition(_, _1); end

  def add_next_sibling(node_or_tags); end

  def add_previous_sibling(node_or_tags); end

  def after(node_or_tags); end

  def ancestors(selector=T.unsafe(nil)); end

  def append_class(name); end

  def attr(name); end

  def attribute(_); end

  def attribute_nodes(); end

  def attribute_with_ns(_, _1); end

  def attributes(); end

  def before(node_or_tags); end

  def canonicalize(mode=T.unsafe(nil), inclusive_namespaces=T.unsafe(nil), with_comments=T.unsafe(nil)); end

  def cdata?(); end

  def child(); end

  def children(); end

  def children=(node_or_tags); end

  def classes(); end

  def comment?(); end

  def content(); end

  def content=(string); end

  def create_external_subset(_, _1, _2); end

  def create_internal_subset(_, _1, _2); end

  def css_path(); end

  def decorate!(); end

  def default_namespace=(url); end

  def delete(name); end

  def description(); end

  def do_xinclude(options=T.unsafe(nil)); end

  def document(); end

  def document?(); end

  def dup(*_); end

  def each(&blk); end

  def elem?(); end

  def element?(); end

  def element_children(); end

  def elements(); end

  def encode_special_chars(_); end

  def external_subset(); end

  def first_element_child(); end

  def fragment(tags); end

  def fragment?(); end

  def get_attribute(name); end

  def has_attribute?(_); end

  def html?(); end

  def initialize(name, document); end

  def inner_html(*args); end

  def inner_html=(node_or_tags); end

  def inner_text(); end

  def internal_subset(); end

  def key?(_); end

  def keys(); end

  def lang(); end

  def lang=(lang); end

  def last_element_child(); end

  def line(); end

  def matches?(selector); end

  def name(); end

  def name=(name); end

  def namespace(); end

  def namespace=(ns); end

  def namespace_definitions(); end

  def namespace_scopes(); end

  def namespaced_key?(_, _1); end

  def namespaces(); end

  def native_content=(native_content); end

  def next(); end

  def next=(node_or_tags); end

  def next_element(); end

  def next_sibling(); end

  def node_name(); end

  def node_name=(node_name); end

  def node_type(); end

  def parent(); end

  def parent=(parent_node); end

  def parse(string_or_io, options=T.unsafe(nil)); end

  def path(); end

  def pointer_id(); end

  def prepend_child(node_or_tags); end

  def previous(); end

  def previous=(node_or_tags); end

  def previous_element(); end

  def previous_sibling(); end

  def processing_instruction?(); end

  def read_only?(); end

  def remove(); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def replace(node_or_tags); end

  def serialize(*args, &block); end

  def set_attribute(name, value); end

  def swap(node_or_tags); end

  def text(); end

  def text?(); end

  def to_html(options=T.unsafe(nil)); end

  def to_str(); end

  def to_xhtml(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def traverse(&block); end

  def type(); end

  def unlink(); end

  def values(); end

  def wrap(html); end

  def write_html_to(io, options=T.unsafe(nil)); end

  def write_to(io, *options); end

  def write_xhtml_to(io, options=T.unsafe(nil)); end

  def write_xml_to(io, options=T.unsafe(nil)); end

  def xml?(); end
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
end

class Nokogiri::XML::NodeSet
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def &(_); end

  def +(_); end

  def -(_); end

  def <<(_); end

  def ==(other); end

  def >(selector); end

  def [](*_); end

  def add_class(name); end

  def after(datum); end

  def append_class(name); end

  def attr(key, value=T.unsafe(nil), &block); end

  def attribute(key, value=T.unsafe(nil), &block); end

  def before(datum); end

  def children(); end

  def clone(); end

  def delete(_); end

  def document(); end

  def document=(document); end

  def each(&blk); end

  def empty?(); end

  def filter(expr); end

  def first(n=T.unsafe(nil)); end

  def index(node=T.unsafe(nil)); end

  def initialize(document, list=T.unsafe(nil)); end

  def inner_html(*args); end

  def inner_text(); end

  def last(); end

  def length(); end

  def pop(); end

  def push(_); end

  def remove(); end

  def remove_attr(name); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def reverse(); end

  def set(key, value=T.unsafe(nil), &block); end

  def shift(); end

  def size(); end

  def slice(*_); end

  def text(); end

  def to_a(); end

  def to_ary(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end

  def unlink(); end

  def wrap(html); end

  def |(_); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
end

class Nokogiri::XML::Notation
end

class Nokogiri::XML::Notation
end

module Nokogiri::XML::PP
end

module Nokogiri::XML::PP::CharacterData
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::CharacterData
end

module Nokogiri::XML::PP::Node
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::Node
end

module Nokogiri::XML::PP
end

class Nokogiri::XML::ParseOptions
  def compact(); end

  def compact?(); end

  def default_html(); end

  def default_html?(); end

  def default_xml(); end

  def default_xml?(); end

  def dtdattr(); end

  def dtdattr?(); end

  def dtdload(); end

  def dtdload?(); end

  def dtdvalid(); end

  def dtdvalid?(); end

  def huge(); end

  def huge?(); end

  def initialize(options=T.unsafe(nil)); end

  def nobasefix(); end

  def nobasefix?(); end

  def noblanks(); end

  def noblanks?(); end

  def nocdata(); end

  def nocdata?(); end

  def nocompact(); end

  def nodefault_html(); end

  def nodefault_xml(); end

  def nodict(); end

  def nodict?(); end

  def nodtdattr(); end

  def nodtdload(); end

  def nodtdvalid(); end

  def noent(); end

  def noent?(); end

  def noerror(); end

  def noerror?(); end

  def nohuge(); end

  def nonet(); end

  def nonet?(); end

  def nonobasefix(); end

  def nonoblanks(); end

  def nonocdata(); end

  def nonodict(); end

  def nonoent(); end

  def nonoerror(); end

  def nononet(); end

  def nonowarning(); end

  def nonoxincnode(); end

  def nonsclean(); end

  def noold10(); end

  def nopedantic(); end

  def norecover(); end

  def nosax1(); end

  def nowarning(); end

  def nowarning?(); end

  def noxinclude(); end

  def noxincnode(); end

  def noxincnode?(); end

  def nsclean(); end

  def nsclean?(); end

  def old10(); end

  def old10?(); end

  def options(); end

  def options=(options); end

  def pedantic(); end

  def pedantic?(); end

  def recover(); end

  def recover?(); end

  def sax1(); end

  def sax1?(); end

  def strict(); end

  def strict?(); end

  def to_i(); end

  def xinclude(); end

  def xinclude?(); end
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
end

class Nokogiri::XML::ProcessingInstruction
  def initialize(document, name, content); end
end

class Nokogiri::XML::ProcessingInstruction
end

class Nokogiri::XML::Reader
  include ::Enumerable
  def attribute(_); end

  def attribute_at(_); end

  def attribute_count(); end

  def attribute_nodes(); end

  def attributes(); end

  def attributes?(); end

  def base_uri(); end

  def default?(); end

  def depth(); end

  def each(&blk); end

  def empty_element?(); end

  def encoding(); end

  def errors(); end

  def errors=(errors); end

  def initialize(source, url=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def inner_xml(); end

  def lang(); end

  def local_name(); end

  def name(); end

  def namespace_uri(); end

  def namespaces(); end

  def node_type(); end

  def outer_xml(); end

  def prefix(); end

  def read(); end

  def self_closing?(); end

  def source(); end

  def state(); end

  def value(); end

  def value?(); end

  def xml_version(); end
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  def self.from_io(*_); end

  def self.from_memory(*_); end
end

class Nokogiri::XML::RelaxNG
end

class Nokogiri::XML::RelaxNG
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::SAX::Document
  def cdata_block(string); end

  def characters(string); end

  def comment(string); end

  def end_document(); end

  def end_element(name); end

  def end_element_namespace(name, prefix=T.unsafe(nil), uri=T.unsafe(nil)); end

  def error(string); end

  def processing_instruction(name, content); end

  def start_document(); end

  def start_element(name, attrs=T.unsafe(nil)); end

  def start_element_namespace(name, attrs=T.unsafe(nil), prefix=T.unsafe(nil), uri=T.unsafe(nil), ns=T.unsafe(nil)); end

  def warning(string); end

  def xmldecl(version, encoding, standalone); end
end

class Nokogiri::XML::SAX::Document
end

class Nokogiri::XML::SAX::Parser
  def document(); end

  def document=(document); end

  def encoding(); end

  def encoding=(encoding); end

  def initialize(doc=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def parse(thing, &block); end

  def parse_file(filename); end

  def parse_io(io, encoding=T.unsafe(nil)); end

  def parse_memory(data); end
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
end

class Nokogiri::XML::SAX::ParserContext
  def column(); end

  def line(); end

  def parse_with(_); end

  def recovery(); end

  def recovery=(recovery); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end
end

class Nokogiri::XML::SAX::ParserContext
  def self.file(_); end

  def self.io(_, _1); end

  def self.memory(_); end

  def self.new(thing, encoding=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
  def <<(chunk, last_chunk=T.unsafe(nil)); end

  def document(); end

  def document=(document); end

  def finish(); end

  def initialize(doc=T.unsafe(nil), file_name=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end

  def write(chunk, last_chunk=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::Schema
  def errors(); end

  def errors=(errors); end

  def valid?(thing); end

  def validate(thing); end
end

class Nokogiri::XML::Schema
  def self.from_document(_); end

  def self.new(string_or_io); end

  def self.read_memory(_); end
end

module Nokogiri::XML::Searchable
  def %(*args); end

  def /(*args); end

  def at(*args); end

  def at_css(*args); end

  def at_xpath(*args); end

  def css(*args); end

  def search(*args); end

  def xpath(*args); end
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
end

class Nokogiri::XML::SyntaxError
  def code(); end

  def column(); end

  def domain(); end

  def error?(); end

  def fatal?(); end

  def file(); end

  def int1(); end

  def level(); end

  def line(); end

  def none?(); end

  def str1(); end

  def str2(); end

  def str3(); end

  def warning?(); end
end

class Nokogiri::XML::SyntaxError
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::XPath
  def document(); end

  def document=(document); end
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath
end

class Nokogiri::XML::XPathContext
  def evaluate(*_); end

  def register_namespaces(namespaces); end

  def register_ns(_, _1); end

  def register_variable(_, _1); end
end

class Nokogiri::XML::XPathContext
  def self.new(_); end
end

module Nokogiri::XML
  def self.Reader(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.RelaxNG(string_or_io); end

  def self.Schema(string_or_io); end

  def self.fragment(string); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module Nokogiri::XSLT
end

class Nokogiri::XSLT::Stylesheet
  def apply_to(document, params=T.unsafe(nil)); end

  def serialize(_); end

  def transform(*_); end
end

class Nokogiri::XSLT::Stylesheet
  def self.parse_stylesheet_doc(_); end
end

module Nokogiri::XSLT
  def self.parse(string, modules=T.unsafe(nil)); end

  def self.quote_params(params); end

  def self.register(_, _1); end
end

module Nokogiri
  def self.HTML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.Slop(*args, &block); end

  def self.XML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.XSLT(stylesheet, modules=T.unsafe(nil)); end

  def self.install_default_aliases(); end

  def self.jruby?(); end

  def self.make(input=T.unsafe(nil), opts=T.unsafe(nil), &blk); end

  def self.parse(string, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.uses_libxml?(); end
end

module OAuth2
end

class OAuth2::AccessToken
  def [](key); end

  def client(); end

  def delete(path, opts=T.unsafe(nil), &block); end

  def expired?(); end

  def expires?(); end

  def expires_at(); end

  def expires_in(); end

  def get(path, opts=T.unsafe(nil), &block); end

  def headers(); end

  def initialize(client, token, opts=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def params(); end

  def patch(path, opts=T.unsafe(nil), &block); end

  def post(path, opts=T.unsafe(nil), &block); end

  def put(path, opts=T.unsafe(nil), &block); end

  def refresh!(params=T.unsafe(nil)); end

  def refresh_token(); end

  def refresh_token=(refresh_token); end

  def request(verb, path, opts=T.unsafe(nil), &block); end

  def to_hash(); end

  def token(); end
end

class OAuth2::AccessToken
  def self.from_hash(client, hash); end

  def self.from_kvform(client, kvform); end
end

class OAuth2::Authenticator
  def apply(params); end

  def id(); end

  def initialize(id, secret, mode); end

  def mode(); end

  def secret(); end
end

class OAuth2::Authenticator
  def self.encode_basic_auth(user, password); end
end

class OAuth2::Client
  def assertion(); end

  def auth_code(); end

  def authorize_url(params=T.unsafe(nil)); end

  def client_credentials(); end

  def connection(); end

  def connection=(connection); end

  def get_token(params, access_token_opts=T.unsafe(nil), access_token_class=T.unsafe(nil)); end

  def id(); end

  def implicit(); end

  def initialize(client_id, client_secret, options=T.unsafe(nil), &block); end

  def options(); end

  def options=(options); end

  def password(); end

  def redirection_params(); end

  def request(verb, url, opts=T.unsafe(nil)); end

  def secret(); end

  def site(); end

  def site=(value); end

  def token_url(params=T.unsafe(nil)); end
end

class OAuth2::Client
end

class OAuth2::Error
  def code(); end

  def description(); end

  def error_message(response_body, opts=T.unsafe(nil)); end

  def initialize(response); end

  def response(); end
end

class OAuth2::Error
end

class OAuth2::MACToken
  def algorithm(); end

  def algorithm=(alg); end

  def header(verb, url); end

  def initialize(client, token, secret, opts=T.unsafe(nil)); end

  def secret(); end

  def signature(timestamp, nonce, verb, uri); end
end

class OAuth2::MACToken
  def self.from_access_token(token, secret, options=T.unsafe(nil)); end
end

class OAuth2::Response
  def body(); end

  def content_type(); end

  def error(); end

  def error=(error); end

  def headers(); end

  def initialize(response, opts=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parsed(); end

  def parser(); end

  def response(); end

  def status(); end
end

class OAuth2::Response
  def self.register_parser(key, mime_types, &block); end
end

module OAuth2::Strategy
end

class OAuth2::Strategy::Assertion
  def authorize_url(); end

  def build_assertion(params); end

  def build_request(params); end

  def get_token(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::Assertion
end

class OAuth2::Strategy::AuthCode
  def authorize_params(params=T.unsafe(nil)); end

  def authorize_url(params=T.unsafe(nil)); end

  def get_token(code, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::AuthCode
end

class OAuth2::Strategy::Base
  def initialize(client); end
end

class OAuth2::Strategy::Base
end

class OAuth2::Strategy::ClientCredentials
  def authorize_url(); end

  def get_token(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::ClientCredentials
end

class OAuth2::Strategy::Implicit
  def authorize_params(params=T.unsafe(nil)); end

  def authorize_url(params=T.unsafe(nil)); end

  def get_token(*_); end
end

class OAuth2::Strategy::Implicit
end

class OAuth2::Strategy::Password
  def authorize_url(); end

  def get_token(username, password, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::Password
end

module OAuth2::Strategy
end

module OAuth2
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Dependencies::Loadable
  include ::ActiveSupport::Tryable
  include ::Minitest::Expectations
  include ::Mocha::ParameterMatchers::InstanceMethods
  include ::Mocha::Inspect::ObjectMethods
  include ::Mocha::ObjectMethods
  include ::PP::ObjectMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def __is_a__(_); end

  def as_json(options=T.unsafe(nil)); end

  def dclone(); end

  def html_safe?(); end

  def presence_in(another_object); end

  def pry(object=T.unsafe(nil), hash=T.unsafe(nil)); end

  def stub(name, val_or_callable, *block_args); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

module OmniAuth
end

class OmniAuth::AuthHash
  def regular_writer(key, value); end

  def valid?(); end
end

class OmniAuth::AuthHash::InfoHash
  def name(); end

  def name?(); end

  def to_hash(); end

  def valid?(); end
end

class OmniAuth::AuthHash::InfoHash
  def self.subkey_class(); end
end

class OmniAuth::AuthHash
  def self.subkey_class(); end
end

class OmniAuth::Builder
  def before_callback_phase(&block); end

  def before_options_phase(&block); end

  def before_request_phase(&block); end

  def configure(&block); end

  def on_failure(&block); end

  def options(options=T.unsafe(nil)); end

  def provider(klass, *args, &block); end
end

class OmniAuth::Builder
end

class OmniAuth::Configuration
  include ::Singleton
  def add_camelization(name, camelized); end

  def add_mock(provider, original=T.unsafe(nil)); end

  def allowed_request_methods(); end

  def allowed_request_methods=(allowed_request_methods); end

  def before_callback_phase(&block); end

  def before_callback_phase=(before_callback_phase); end

  def before_options_phase(&block); end

  def before_options_phase=(before_options_phase); end

  def before_request_phase(&block); end

  def before_request_phase=(before_request_phase); end

  def camelizations(); end

  def camelizations=(camelizations); end

  def failure_raise_out_environments(); end

  def failure_raise_out_environments=(failure_raise_out_environments); end

  def form_css(); end

  def form_css=(form_css); end

  def full_host(); end

  def full_host=(full_host); end

  def logger(); end

  def logger=(logger); end

  def mock_auth(); end

  def mock_auth=(mock_auth); end

  def on_failure(&block); end

  def on_failure=(on_failure); end

  def path_prefix(); end

  def path_prefix=(path_prefix); end

  def test_mode(); end

  def test_mode=(test_mode); end
end

class OmniAuth::Configuration
  extend ::Singleton::SingletonClassMethods
  def self.default_logger(); end

  def self.defaults(); end

  def self.instance(); end
end

class OmniAuth::Error
end

class OmniAuth::Error
end

class OmniAuth::FailureEndpoint
  def call(); end

  def env(); end

  def initialize(env); end

  def origin_query_param(); end

  def raise_out!(); end

  def redirect_to_failure(); end

  def strategy_name_query_param(); end
end

class OmniAuth::FailureEndpoint
  def self.call(env); end
end

class OmniAuth::Form
  def button(text); end

  def css(); end

  def fieldset(legend, options=T.unsafe(nil), &block); end

  def footer(); end

  def header(title, header_info); end

  def html(html); end

  def initialize(options=T.unsafe(nil)); end

  def input_field(type, name); end

  def label_field(text, target); end

  def options(); end

  def options=(options); end

  def password_field(label, name); end

  def text_field(label, name); end

  def to_html(); end

  def to_response(); end
  DEFAULT_CSS = ::T.let(nil, ::T.untyped)
end

class OmniAuth::Form
  def self.build(options=T.unsafe(nil), &block); end
end

class OmniAuth::KeyStore
end

class OmniAuth::KeyStore
  def self.override_logging(); end
end

class OmniAuth::NoSessionError
end

class OmniAuth::NoSessionError
end

module OmniAuth::Shopify
  VERSION = ::T.let(nil, ::T.untyped)
end

module OmniAuth::Shopify
end

module OmniAuth::Strategies
end

class OmniAuth::Strategies::Developer
  include ::OmniAuth::Strategy
end

class OmniAuth::Strategies::Developer
  extend ::OmniAuth::Strategy::ClassMethods
end

class OmniAuth::Strategies::OAuth2
  include ::OmniAuth::Strategy
  def access_token(); end

  def access_token=(access_token); end

  def authorize_params(); end

  def build_access_token(); end

  def client(); end

  def deep_symbolize(options); end

  def options_for(option); end

  def token_params(); end
end

class OmniAuth::Strategies::OAuth2::CallbackError
  def error(); end

  def error=(error); end

  def error_reason(); end

  def error_reason=(error_reason); end

  def error_uri(); end

  def error_uri=(error_uri); end

  def initialize(error, error_reason=T.unsafe(nil), error_uri=T.unsafe(nil)); end
end

class OmniAuth::Strategies::OAuth2::CallbackError
end

class OmniAuth::Strategies::OAuth2
  extend ::OmniAuth::Strategy::ClassMethods
  def self.inherited(subclass); end
end

class OmniAuth::Strategies::Shopify
  def fix_https(); end

  def normalized_scopes(scopes); end

  def valid_permissions?(token); end

  def valid_scope?(token); end

  def valid_signature?(); end

  def valid_site?(); end
  CODE_EXPIRES_AFTER = ::T.let(nil, ::T.untyped)
  DEFAULT_SCOPE = ::T.let(nil, ::T.untyped)
  MINUTE = ::T.let(nil, ::T.untyped)
  SCOPE_DELIMITER = ::T.let(nil, ::T.untyped)
end

class OmniAuth::Strategies::Shopify
  def self.encoded_params_for_signature(params); end

  def self.hmac_sign(encoded_params, secret); end
end

module OmniAuth::Strategies
end

module OmniAuth::Strategy
  def app(); end

  def auth_hash(); end

  def call(env); end

  def call!(env); end

  def call_app!(env=T.unsafe(nil)); end

  def callback_call(); end

  def callback_path(); end

  def callback_phase(); end

  def callback_url(); end

  def credentials(); end

  def current_path(); end

  def custom_path(kind); end

  def dup(); end

  def env(); end

  def extra(); end

  def fail!(message_key, exception=T.unsafe(nil)); end

  def full_host(); end

  def info(); end

  def initialize(app, *args, &block); end

  def inspect(); end

  def log(level, message); end

  def merge_stack(stack); end

  def mock_call!(*_); end

  def mock_callback_call(); end

  def mock_request_call(); end

  def name(); end

  def on_auth_path?(); end

  def on_callback_path?(); end

  def on_path?(path); end

  def on_request_path?(); end

  def options(); end

  def options_call(); end

  def options_request?(); end

  def path_prefix(); end

  def query_string(); end

  def redirect(uri); end

  def request(); end

  def request_call(); end

  def request_path(); end

  def request_phase(); end

  def response(); end

  def script_name(); end

  def session(); end

  def setup_path(); end

  def setup_phase(); end

  def skip_info?(); end

  def ssl?(); end

  def uid(); end

  def user_info(); end
  CURRENT_PATH_REGEX = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
end

module OmniAuth::Strategy::ClassMethods
  def args(args=T.unsafe(nil)); end

  def compile_stack(ancestors, method, context); end

  def configure(options=T.unsafe(nil)); end

  def credentials(&block); end

  def credentials_stack(context); end

  def default_options(); end

  def extra(&block); end

  def extra_stack(context); end

  def info(&block); end

  def info_stack(context); end

  def option(name, value=T.unsafe(nil)); end

  def uid(&block); end

  def uid_stack(context); end
end

module OmniAuth::Strategy::ClassMethods
end

class OmniAuth::Strategy::Options
end

class OmniAuth::Strategy::Options
end

module OmniAuth::Strategy
  def self.included(base); end
end

module OmniAuth::Test
end

class OmniAuth::Test::PhonySession
  def call(env); end

  def initialize(app); end
end

class OmniAuth::Test::PhonySession
end

module OmniAuth::Test::StrategyMacros
  def sets_an_auth_hash(); end

  def sets_provider_to(provider); end

  def sets_uid_to(uid); end

  def sets_user_info_to(user_info); end
end

module OmniAuth::Test::StrategyMacros
end

module OmniAuth::Test::StrategyTestCase
  def app(); end

  def app_response(); end

  def session(); end

  def strategy(); end
end

module OmniAuth::Test::StrategyTestCase
end

module OmniAuth::Test
end

module OmniAuth::Utils
end

module OmniAuth::Utils
  def self.camelize(word, first_letter_in_uppercase=T.unsafe(nil)); end

  def self.deep_merge(hash, other_hash); end

  def self.form_css(); end
end

module OmniAuth
  def self.config(); end

  def self.configure(); end

  def self.logger(); end

  def self.mock_auth_for(provider); end

  def self.strategies(); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

ParseError = Racc::ParseError

module Parts
end

class Parts::EpiloguePart
  include ::Parts::Part
  def initialize(boundary); end
end

class Parts::EpiloguePart
end

class Parts::FilePart
  include ::Parts::Part
  def build_head(boundary, name, filename, type, content_len, opts=T.unsafe(nil)); end

  def initialize(boundary, name, io, headers=T.unsafe(nil)); end
end

class Parts::FilePart
end

class Parts::ParamPart
  include ::Parts::Part
  def build_part(boundary, name, value, headers=T.unsafe(nil)); end

  def initialize(boundary, name, value, headers=T.unsafe(nil)); end
end

class Parts::ParamPart
end

module Parts::Part
  def length(); end

  def to_io(); end
end

module Parts::Part
  def self.file?(value); end

  def self.new(boundary, name, value, headers=T.unsafe(nil)); end
end

module Parts
end

class PatchedStringIO
  def orig_read_nonblock(*_); end

  def read_nonblock(size, *args, **kwargs); end
end

class PatchedStringIO
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  include ::MethodSource::SourceLocation::ProcExtensions
  include ::MethodSource::MethodExtensions
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def clone(); end

  def yield(*_); end
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

class Pry
  def add_sticky_local(name, &block); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def binding_stack(); end

  def binding_stack=(binding_stack); end

  def color(); end

  def color=(value); end

  def command_state(); end

  def commands(); end

  def commands=(value); end

  def complete(str); end

  def config(); end

  def current_binding(); end

  def current_context(); end

  def custom_completions(); end

  def custom_completions=(custom_completions); end

  def editor(); end

  def editor=(value); end

  def eval(line, options=T.unsafe(nil)); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def evaluate_ruby(code); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exec_hook(name, *args, &block); end

  def exit_value(); end

  def extra_sticky_locals(); end

  def extra_sticky_locals=(value); end

  def hooks(); end

  def hooks=(value); end

  def initialize(options=T.unsafe(nil)); end

  def inject_local(name, value, b); end

  def inject_sticky_locals!(); end

  def input(); end

  def input=(value); end

  def input_array(); end

  def input_ring(); end

  def last_dir(); end

  def last_dir=(last_dir); end

  def last_exception(); end

  def last_exception=(e); end

  def last_file(); end

  def last_file=(last_file); end

  def last_result(); end

  def last_result=(last_result); end

  def last_result_is_exception?(); end

  def memory_size(); end

  def memory_size=(size); end

  def output(); end

  def output=(value); end

  def output_array(); end

  def output_ring(); end

  def pager(); end

  def pager=(value); end

  def pop_prompt(); end

  def print(); end

  def print=(value); end

  def process_command(val); end

  def process_command_safely(val); end

  def prompt(); end

  def prompt=(new_prompt); end

  def push_binding(object); end

  def push_initial_binding(target=T.unsafe(nil)); end

  def push_prompt(new_prompt); end

  def quiet?(); end

  def raise_up(*args); end

  def raise_up!(*args); end

  def raise_up_common(force, *args); end

  def repl(target=T.unsafe(nil)); end

  def reset_eval_string(); end

  def run_command(val); end

  def select_prompt(); end

  def set_last_result(result, code=T.unsafe(nil)); end

  def should_print?(); end

  def show_result(result); end

  def sticky_locals(); end

  def suppress_output(); end

  def suppress_output=(suppress_output); end

  def update_input_history(code); end
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  CLIPPED_PRINT = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  DEFAULT_CONTROL_D_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_WHITELIST = ::T.let(nil, ::T.untyped)
  DEFAULT_HOOKS = ::T.let(nil, ::T.untyped)
  DEFAULT_PRINT = ::T.let(nil, ::T.untyped)
  DEFAULT_SYSTEM = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HOME_RC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  SIMPLE_PRINT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  include ::Kernel
end

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::Pry = Pry

class Pry::BasicObject
end

class Pry::BlockCommand
  def call(*args); end

  def help(); end

  def opts(); end
end

class Pry::BlockCommand
end

class Pry::CLI
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI
  def self.add_option_processor(&block); end

  def self.add_options(&block); end

  def self.add_plugin_options(); end

  def self.input_args(); end

  def self.input_args=(input_args); end

  def self.option_processors(); end

  def self.option_processors=(option_processors); end

  def self.options(); end

  def self.options=(options); end

  def self.parse_options(args=T.unsafe(nil)); end

  def self.reset(); end

  def self.start(opts); end
end

class Pry::ClassCommand
  def args(); end

  def args=(args); end

  def call(*args); end

  def complete(search); end

  def help(); end

  def options(opt); end

  def opts(); end

  def opts=(opts); end

  def process(); end

  def setup(); end

  def slop(); end

  def subcommands(cmd); end
end

class Pry::ClassCommand
  def self.inherited(klass); end

  def self.source_location(); end
end

class Pry::Code
  def <<(line, lineno=T.unsafe(nil)); end

  def ==(other); end

  def after(lineno, lines=T.unsafe(nil)); end

  def alter(&block); end

  def around(lineno, lines=T.unsafe(nil)); end

  def before(lineno, lines=T.unsafe(nil)); end

  def between(start_line, end_line=T.unsafe(nil)); end

  def code_type(); end

  def code_type=(code_type); end

  def comment_describing(line_number); end

  def expression_at(line_number, consume=T.unsafe(nil)); end

  def grep(pattern); end

  def highlighted(); end

  def initialize(lines=T.unsafe(nil), start_line=T.unsafe(nil), code_type=T.unsafe(nil)); end

  def length(); end

  def max_lineno_width(); end

  def method_missing(name, *args, &block); end

  def nesting_at(line_number); end

  def print_to_output(output, color=T.unsafe(nil)); end

  def push(line, lineno=T.unsafe(nil)); end

  def raw(); end

  def select(&block); end

  def take_lines(start_line, num_lines); end

  def with_indentation(spaces=T.unsafe(nil)); end

  def with_line_numbers(y_n=T.unsafe(nil)); end

  def with_marker(lineno=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
  def indices_range(lines); end

  def initialize(start_line, end_line=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
end

class Pry::Code::LOC
  def ==(other); end

  def add_line_number(max_width=T.unsafe(nil), color=T.unsafe(nil)); end

  def add_marker(marker_lineno); end

  def colorize(code_type); end

  def handle_multiline_entries_from_edit_command(line, max_width); end

  def indent(distance); end

  def initialize(line, lineno); end

  def line(); end

  def lineno(); end

  def tuple(); end
end

class Pry::Code::LOC
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
  def self.from_file(filename, code_type=T.unsafe(nil)); end

  def self.from_method(meth, start_line=T.unsafe(nil)); end

  def self.from_module(mod, candidate_rank=T.unsafe(nil), start_line=T.unsafe(nil)); end
end

class Pry::CodeFile
  def code(); end

  def code_type(); end

  def initialize(filename, code_type=T.unsafe(nil)); end
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::CodeFile
end

class Pry::CodeObject
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def _pry_(); end

  def _pry_=(_pry_); end

  def command_lookup(); end

  def default_lookup(); end

  def empty_lookup(); end

  def initialize(str, _pry_, options=T.unsafe(nil)); end

  def method_or_class_lookup(); end

  def str(); end

  def str=(str); end

  def super_level(); end

  def super_level=(super_level); end

  def target(); end

  def target=(target); end
end

module Pry::CodeObject::Helpers
  def c_method?(); end

  def c_module?(); end

  def command?(); end

  def module_with_yard_docs?(); end

  def real_method_object?(); end
end

module Pry::CodeObject::Helpers
end

class Pry::CodeObject
  def self.lookup(str, _pry_, options=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def text(str, width=T.unsafe(nil)); end
  OBJ_COLOR = ::T.let(nil, ::T.untyped)
end

class Pry::ColorPrinter
  def self.pp(obj, out=T.unsafe(nil), width=T.unsafe(nil), newline=T.unsafe(nil)); end
end

class Pry::Command
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::Text
  def _pry_(); end

  def _pry_=(_pry_); end

  def arg_string(); end

  def arg_string=(arg_string); end

  def block(); end

  def call_safely(*args); end

  def captures(); end

  def captures=(captures); end

  def check_for_command_collision(command_match, arg_string); end

  def command_block(); end

  def command_block=(command_block); end

  def command_name(); end

  def command_options(); end

  def command_set(); end

  def command_set=(command_set); end

  def commands(); end

  def complete(_search); end

  def context(); end

  def context=(context); end

  def dependencies_met?(); end

  def description(); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def hooks(); end

  def hooks=(hooks); end

  def initialize(context=T.unsafe(nil)); end

  def interpolate_string(str); end

  def match(); end

  def name(); end

  def output(); end

  def output=(output); end

  def process_line(line); end

  def run(command_string, *args); end

  def source(); end

  def state(); end

  def target(); end

  def target=(target); end

  def target_self(); end

  def text(); end

  def tokenize(val); end

  def use_unpatched_symbol(); end

  def void(); end
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::AmendLine
end

class Pry::Command::AmendLine
end

class Pry::Command::Bang
end

class Pry::Command::Bang
end

class Pry::Command::BangPry
end

class Pry::Command::BangPry
end

class Pry::Command::Cat
  def load_path_completions(); end
end

class Pry::Command::Cat::AbstractFormatter
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::BaseHelpers
end

class Pry::Command::Cat::AbstractFormatter
end

class Pry::Command::Cat::ExceptionFormatter
  include ::Pry::Helpers::Text
  def _pry_(); end

  def ex(); end

  def format(); end

  def initialize(exception, _pry_, opts); end

  def opts(); end
end

class Pry::Command::Cat::ExceptionFormatter
end

class Pry::Command::Cat::FileFormatter
  def _pry_(); end

  def file_and_line(); end

  def file_with_embedded_line(); end

  def format(); end

  def initialize(file_with_embedded_line, _pry_, opts); end

  def opts(); end
end

class Pry::Command::Cat::FileFormatter
end

class Pry::Command::Cat::InputExpressionFormatter
  def format(); end

  def initialize(input_expressions, opts); end

  def input_expressions(); end

  def input_expressions=(input_expressions); end

  def opts(); end

  def opts=(opts); end
end

class Pry::Command::Cat::InputExpressionFormatter
end

class Pry::Command::Cat
end

class Pry::Command::Cd
end

class Pry::Command::Cd
end

class Pry::Command::ChangeInspector
  def process(inspector); end
end

class Pry::Command::ChangeInspector
end

class Pry::Command::ChangePrompt
  def process(prompt); end
end

class Pry::Command::ChangePrompt
end

class Pry::Command::ClearScreen
end

class Pry::Command::ClearScreen
end

class Pry::Command::CodeCollector
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def _pry_(); end

  def args(); end

  def code_object(); end

  def content(); end

  def file(); end

  def file=(file); end

  def initialize(args, opts, _pry_); end

  def line_range(); end

  def obj_name(); end

  def opts(); end

  def pry_input_content(); end

  def pry_output_content(); end

  def restrict_to_lines(content, range); end
end

class Pry::Command::CodeCollector
  def self.inject_options(opt); end

  def self.input_expression_ranges(); end

  def self.input_expression_ranges=(input_expression_ranges); end

  def self.output_result_ranges(); end

  def self.output_result_ranges=(output_result_ranges); end
end

class Pry::Command::DisablePry
end

class Pry::Command::DisablePry
end

class Pry::Command::Edit
  def apply_runtime_patch(); end

  def bad_option_combination?(); end

  def code_object(); end

  def ensure_file_name_is_valid(file_name); end

  def file_and_line(); end

  def file_and_line_for_current_exception(); end

  def file_based_exception?(); end

  def file_edit(); end

  def filename_argument(); end

  def initial_temp_file_content(); end

  def input_expression(); end

  def never_reload?(); end

  def patch_exception?(); end

  def previously_patched?(code_object); end

  def probably_a_file?(str); end

  def pry_method?(code_object); end

  def reload?(file_name=T.unsafe(nil)); end

  def reloadable?(); end

  def repl_edit(); end

  def repl_edit?(); end

  def runtime_patch?(); end
end

class Pry::Command::Edit::ExceptionPatcher
  def _pry_(); end

  def _pry_=(_pry_); end

  def file_and_line(); end

  def file_and_line=(file_and_line); end

  def initialize(_pry_, state, exception_file_and_line); end

  def perform_patch(); end

  def state(); end

  def state=(state); end
end

class Pry::Command::Edit::ExceptionPatcher
end

module Pry::Command::Edit::FileAndLineLocator
end

module Pry::Command::Edit::FileAndLineLocator
  def self.from_binding(target); end

  def self.from_code_object(code_object, filename_argument); end

  def self.from_exception(exception, backtrace_level); end

  def self.from_filename_argument(filename_argument); end
end

class Pry::Command::Edit
end

class Pry::Command::Exit
  def process_pop_and_return(); end
end

class Pry::Command::Exit
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitProgram
end

class Pry::Command::ExitProgram
end

class Pry::Command::FindMethod
end

class Pry::Command::FindMethod
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::FixIndent
end

class Pry::Command::FixIndent
end

class Pry::Command::GemCd
  def complete(str); end

  def process(gem); end
end

class Pry::Command::GemCd
end

class Pry::Command::GemInstall
  def process(gem); end
end

class Pry::Command::GemInstall
end

class Pry::Command::GemList
  def process(pattern=T.unsafe(nil)); end
end

class Pry::Command::GemList
end

class Pry::Command::GemOpen
  def complete(str); end

  def process(gem); end
end

class Pry::Command::GemOpen
end

class Pry::Command::GemReadme
  def process(name); end
end

class Pry::Command::GemReadme
end

class Pry::Command::GemSearch
  def process(str); end
  API_ENDPOINT = ::T.let(nil, ::T.untyped)
end

class Pry::Command::GemSearch
end

class Pry::Command::GemStat
  def process(name); end
  FAIL_WHALE = ::T.let(nil, ::T.untyped)
  STAT_HOST = ::T.let(nil, ::T.untyped)
  STAT_PATH = ::T.let(nil, ::T.untyped)
  STAT_PORT = ::T.let(nil, ::T.untyped)
end

class Pry::Command::GemStat
end

class Pry::Command::Gist
  def clipboard_content(content); end

  def comment_expression_result_for_gist(result); end

  def gist_content(content, filename); end

  def input_content(); end
end

class Pry::Command::Gist
end

class Pry::Command::Help
  def command_groups(); end

  def display_command(command); end

  def display_filtered_commands(search); end

  def display_filtered_search_results(search); end

  def display_index(groups); end

  def display_search(search); end

  def group_sort_key(group_name); end

  def help_text_for_commands(name, commands); end

  def normalize(key); end

  def search_hash(search, hash); end

  def sorted_commands(commands); end

  def sorted_group_names(groups); end

  def visible_commands(); end
end

class Pry::Command::Help
end

class Pry::Command::Hist
end

class Pry::Command::Hist
end

class Pry::Command::ImportSet
  def process(_command_set_name); end
end

class Pry::Command::ImportSet
end

class Pry::Command::InstallCommand
  def process(name); end
end

class Pry::Command::InstallCommand
end

class Pry::Command::JumpTo
  def process(break_level); end
end

class Pry::Command::JumpTo
end

class Pry::Command::ListInspectors
end

class Pry::Command::ListInspectors
end

class Pry::Command::Ls
  def no_user_opts?(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
end

class Pry::Command::Ls::Formatter
  def _pry_(); end

  def grep=(grep); end

  def initialize(_pry_); end

  def write_out(); end
end

class Pry::Command::Ls::Formatter
end

class Pry::Command::Ls::Globals
  def initialize(opts, _pry_); end
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
end

class Pry::Command::Ls::Grep
  def initialize(grep_regexp); end

  def regexp(); end
end

class Pry::Command::Ls::Grep
end

class Pry::Command::Ls::InstanceVars
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
end

class Pry::Command::Ls::InstanceVars
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::JRubyHacks
end

class Pry::Command::Ls::LocalNames
  def initialize(no_user_opts, args, _pry_); end
end

class Pry::Command::Ls::LocalNames
end

class Pry::Command::Ls::LocalVars
  def initialize(opts, _pry_); end
end

class Pry::Command::Ls::LocalVars
end

class Pry::Command::Ls::LsEntity
  def _pry_(); end

  def entities_table(); end

  def initialize(opts); end
end

class Pry::Command::Ls::LsEntity
end

class Pry::Command::Ls::Methods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
end

class Pry::Command::Ls::Methods
end

module Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::MethodsHelper
end

class Pry::Command::Ls::SelfMethods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, _pry_); end
end

class Pry::Command::Ls::SelfMethods
end

class Pry::Command::Ls
end

class Pry::Command::Nesting
end

class Pry::Command::Nesting
end

class Pry::Command::Play
  def code_object(); end

  def content(); end

  def content_after_options(); end

  def content_at_expression(); end

  def default_file(); end

  def file_content(); end

  def perform_play(); end

  def should_use_default_file?(); end

  def show_input(); end
end

class Pry::Command::Play
end

class Pry::Command::PryBacktrace
end

class Pry::Command::PryBacktrace
end

class Pry::Command::RaiseUp
end

class Pry::Command::RaiseUp
end

class Pry::Command::ReloadCode
end

class Pry::Command::ReloadCode
end

class Pry::Command::Reset
end

class Pry::Command::Reset
end

class Pry::Command::Ri
  def process(spec); end
end

class Pry::Command::Ri
end

class Pry::Command::SaveFile
  def display_content(); end

  def file_name(); end

  def mode(); end

  def save_file(); end
end

class Pry::Command::SaveFile
end

class Pry::Command::ShellCommand
  def process(cmd); end
end

class Pry::Command::ShellCommand
end

class Pry::Command::ShellMode
end

class Pry::Command::ShellMode
end

class Pry::Command::ShowDoc
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowDoc
end

class Pry::Command::ShowInfo
  def code_object_header(code_object, line_num); end

  def code_object_with_accessible_source(code_object); end

  def complete(input); end

  def content_and_header_for_code_object(code_object); end

  def content_and_headers_for_all_module_candidates(mod); end

  def file_and_line_for(code_object); end

  def header(code_object); end

  def header_options(); end

  def initialize(*_); end

  def method_header(code_object, line_num); end

  def method_sections(code_object); end

  def module_header(code_object, line_num); end

  def no_definition_message(); end

  def obj_name(); end

  def show_all_modules?(code_object); end

  def start_line_for(code_object); end

  def use_line_numbers?(); end

  def valid_superclass?(code_object); end
end

class Pry::Command::ShowInfo
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowSource
  def content_for(code_object); end
end

class Pry::Command::ShowSource
end

class Pry::Command::Stat
end

class Pry::Command::Stat
end

class Pry::Command::SwitchTo
  def process(selection); end
end

class Pry::Command::SwitchTo
end

class Pry::Command::ToggleColor
  def color_toggle(); end
end

class Pry::Command::ToggleColor
end

class Pry::Command::Version
end

class Pry::Command::Version
end

class Pry::Command::WatchExpression
end

class Pry::Command::WatchExpression::Expression
  def _pry_(); end

  def changed?(); end

  def eval!(); end

  def initialize(_pry_, target, source); end

  def previous_value(); end

  def source(); end

  def target(); end

  def value(); end
end

class Pry::Command::WatchExpression::Expression
end

class Pry::Command::WatchExpression
end

class Pry::Command::Whereami
  def bad_option_combination?(); end

  def code(); end

  def code?(); end

  def initialize(*_); end

  def location(); end
end

class Pry::Command::Whereami
  def self.method_size_cutoff(); end

  def self.method_size_cutoff=(method_size_cutoff); end
end

class Pry::Command::Wtf
end

class Pry::Command::Wtf
end

class Pry::Command
  extend ::Pry::Helpers::DocumentationHelpers
  extend ::Pry::CodeObject::Helpers
  def self.banner(arg=T.unsafe(nil)); end

  def self.block(); end

  def self.block=(block); end

  def self.command_name(); end

  def self.command_options(arg=T.unsafe(nil)); end

  def self.command_options=(command_options); end

  def self.command_regex(); end

  def self.convert_to_regex(obj); end

  def self.default_options(match); end

  def self.description(arg=T.unsafe(nil)); end

  def self.description=(description); end

  def self.doc(); end

  def self.file(); end

  def self.group(name=T.unsafe(nil)); end

  def self.hooks(); end

  def self.line(); end

  def self.match(arg=T.unsafe(nil)); end

  def self.match=(match); end

  def self.match_score(val); end

  def self.matches?(val); end

  def self.options(arg=T.unsafe(nil)); end

  def self.options=(options); end

  def self.source(); end

  def self.source_file(); end

  def self.source_line(); end

  def self.subclass(match, description, options, helpers, &block); end
end

class Pry::CommandError
end

class Pry::CommandError
end

class Pry::CommandSet
  include ::Enumerable
  include ::Pry::Helpers::BaseHelpers
  def [](pattern); end

  def []=(pattern, command); end

  def add_command(command); end

  def alias_command(match, action, options=T.unsafe(nil)); end

  def block_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def complete(search, context=T.unsafe(nil)); end

  def create_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def delete(*searches); end

  def desc(search, description=T.unsafe(nil)); end

  def disabled_command(name_of_disabled_command, message, matcher=T.unsafe(nil)); end

  def each(&block); end

  def find_command(pattern); end

  def find_command_by_match_or_listing(match_or_listing); end

  def find_command_for_help(search); end

  def helper_module(); end

  def helpers(&block); end

  def import(*sets); end

  def import_from(set, *matches); end

  def initialize(*imported_sets, &block); end

  def keys(); end

  def list_commands(); end

  def process_line(val, context=T.unsafe(nil)); end

  def rename_command(new_match, search, options=T.unsafe(nil)); end

  def run_command(context, match, *args); end

  def to_h(); end

  def to_hash(); end

  def valid_command?(val); end
end

class Pry::CommandSet
end

class Pry::Config
  include ::Pry::Config::Behavior
end

module Pry::Config::Behavior
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def clear(); end

  def default(); end

  def eager_load!(); end

  def eql?(other); end

  def forget(key); end

  def initialize(default=T.unsafe(nil)); end

  def inspect(); end

  def key?(key); end

  def keys(); end

  def last_default(); end

  def merge!(other); end

  def method_missing(name, *args, &block); end

  def pretty_print(q); end

  def to_h(); end

  def to_hash(); end
  ASSIGNMENT = ::T.let(nil, ::T.untyped)
  INSPECT_REGEXP = ::T.let(nil, ::T.untyped)
  NODUP = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Behavior::Builder
  def assign(attributes, default=T.unsafe(nil)); end

  def from_hash(attributes, default=T.unsafe(nil)); end
end

module Pry::Config::Behavior::Builder
end

class Pry::Config::Behavior::ReservedKeyError
end

class Pry::Config::Behavior::ReservedKeyError
end

module Pry::Config::Behavior
  def self.included(klass); end
end

module Pry::Config::Convenience
  def config_shortcut(*names); end
  SHORTCUTS = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Convenience
end

class Pry::Config::Default
  include ::Pry::Config::Behavior
  include ::Pry::Config::Memoization
  def auto_indent(); end

  def collision_warning(); end

  def color(); end

  def command_completions(); end

  def command_prefix(); end

  def commands(); end

  def completer(); end

  def control_d_handler(); end

  def correct_indent(); end

  def default_window_size(); end

  def disable_auto_reload(); end

  def editor(); end

  def exception_handler(); end

  def exception_whitelist(); end

  def exec_string(); end

  def extra_sticky_locals(); end

  def file_completions(); end

  def gist(); end

  def history(); end

  def hooks(); end

  def initialize(); end

  def input(); end

  def ls(); end

  def memory_size(); end

  def output(); end

  def output_prefix(); end

  def pager(); end

  def print(); end

  def prompt(); end

  def prompt_name(); end

  def prompt_safe_contexts(); end

  def quiet(); end

  def requires(); end

  def should_load_local_rc(); end

  def should_load_plugins(); end

  def should_load_rc(); end

  def should_load_requires(); end

  def should_trap_interrupts(); end

  def system(); end

  def windows_console_warning(); end
end

class Pry::Config::Default
  extend ::Pry::Config::Behavior::Builder
  extend ::Pry::Config::Memoization::ClassMethods
end

class Pry::Config::Lazy
  def call(); end

  def initialize(&block); end
end

class Pry::Config::Lazy
end

module Pry::Config::Memoization
  def memoized_methods(); end
  MEMOIZED_METHODS = ::T.let(nil, ::T.untyped)
end

module Pry::Config::Memoization::ClassMethods
  def def_memoized(method_table); end
end

module Pry::Config::Memoization::ClassMethods
end

module Pry::Config::Memoization
  def self.included(mod); end
end

class Pry::Config
  extend ::Pry::Config::Behavior::Builder
  def self.shortcuts(); end
end

class Pry::Editor
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def _pry_(); end

  def edit_tempfile_with_content(initial_content, line=T.unsafe(nil)); end

  def initialize(_pry_); end

  def invoke_editor(file, line, blocking=T.unsafe(nil)); end
end

class Pry::Editor
end

module Pry::ExtendCommandBundle
end

module Pry::ExtendCommandBundle
end

module Pry::Forwardable
  include ::Forwardable
  def def_private_delegators(target, *private_delegates); end
end

module Pry::Forwardable
end

module Pry::FrozenObjectException
end

module Pry::FrozenObjectException
  def self.===(exception); end
end

module Pry::Helpers
end

module Pry::Helpers::BaseHelpers
  def colorize_code(code); end

  def command_dependencies_met?(options); end

  def find_command(name, set=T.unsafe(nil)); end

  def heading(text); end

  def highlight(string, regexp, highlight_color=T.unsafe(nil)); end

  def jruby?(); end

  def jruby_19?(); end

  def linux?(); end

  def mac_osx?(); end

  def mri?(); end

  def mri_19?(); end

  def mri_2?(); end

  def not_a_real_file?(file); end

  def safe_send(obj, method, *args, &block); end

  def silence_warnings(); end

  def stagger_output(text, _out=T.unsafe(nil)); end

  def use_ansi_codes?(); end

  def windows?(); end

  def windows_ansi?(); end
end

module Pry::Helpers::BaseHelpers
  extend ::Pry::Helpers::BaseHelpers
end

module Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::CommandHelpers
  def self.absolute_index_number(line_number, array_length); end

  def self.absolute_index_range(range_or_number, array_length); end

  def self.command_error(message, omit_help, klass=T.unsafe(nil)); end

  def self.get_method_or_raise(name, target, opts=T.unsafe(nil), omit_help=T.unsafe(nil)); end

  def self.internal_binding?(target); end

  def self.one_index_number(line_number); end

  def self.one_index_range(range); end

  def self.one_index_range_or_number(range_or_number); end

  def self.restrict_to_lines(content, lines); end

  def self.set_file_and_dir_locals(file_name, _pry_=T.unsafe(nil), target=T.unsafe(nil)); end

  def self.temp_file(ext=T.unsafe(nil)); end

  def self.unindent(text, left_padding=T.unsafe(nil)); end
end

module Pry::Helpers::DocumentationHelpers
end

module Pry::Helpers::DocumentationHelpers
  def self.get_comment_content(comment); end

  def self.process_comment_markup(comment); end

  def self.process_rdoc(comment); end

  def self.process_yardoc(comment); end

  def self.process_yardoc_tag(comment, tag); end

  def self.strip_comments_from_c_code(code); end

  def self.strip_leading_whitespace(text); end
end

module Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::OptionsHelpers
  def self.method_object(); end

  def self.method_options(opt); end
end

module Pry::Helpers::Platform
end

module Pry::Helpers::Platform
  def self.jruby?(); end

  def self.jruby_19?(); end

  def self.linux?(); end

  def self.mac_osx?(); end

  def self.mri?(); end

  def self.mri_19?(); end

  def self.mri_2?(); end

  def self.windows?(); end

  def self.windows_ansi?(); end
end

class Pry::Helpers::Table
  def ==(other); end

  def column_count(); end

  def column_count=(n); end

  def columns(); end

  def fits_on_line?(line_length); end

  def initialize(items, args, config=T.unsafe(nil)); end

  def items(); end

  def items=(items); end

  def rows_to_s(style=T.unsafe(nil)); end

  def to_a(); end
end

class Pry::Helpers::Table
end

module Pry::Helpers::Text
  def black(text); end

  def black_on_black(text); end

  def black_on_blue(text); end

  def black_on_cyan(text); end

  def black_on_green(text); end

  def black_on_magenta(text); end

  def black_on_purple(text); end

  def black_on_red(text); end

  def black_on_white(text); end

  def black_on_yellow(text); end

  def blue(text); end

  def blue_on_black(text); end

  def blue_on_blue(text); end

  def blue_on_cyan(text); end

  def blue_on_green(text); end

  def blue_on_magenta(text); end

  def blue_on_purple(text); end

  def blue_on_red(text); end

  def blue_on_white(text); end

  def blue_on_yellow(text); end

  def bold(text); end

  def bright_black(text); end

  def bright_black_on_black(text); end

  def bright_black_on_blue(text); end

  def bright_black_on_cyan(text); end

  def bright_black_on_green(text); end

  def bright_black_on_magenta(text); end

  def bright_black_on_purple(text); end

  def bright_black_on_red(text); end

  def bright_black_on_white(text); end

  def bright_black_on_yellow(text); end

  def bright_blue(text); end

  def bright_blue_on_black(text); end

  def bright_blue_on_blue(text); end

  def bright_blue_on_cyan(text); end

  def bright_blue_on_green(text); end

  def bright_blue_on_magenta(text); end

  def bright_blue_on_purple(text); end

  def bright_blue_on_red(text); end

  def bright_blue_on_white(text); end

  def bright_blue_on_yellow(text); end

  def bright_cyan(text); end

  def bright_cyan_on_black(text); end

  def bright_cyan_on_blue(text); end

  def bright_cyan_on_cyan(text); end

  def bright_cyan_on_green(text); end

  def bright_cyan_on_magenta(text); end

  def bright_cyan_on_purple(text); end

  def bright_cyan_on_red(text); end

  def bright_cyan_on_white(text); end

  def bright_cyan_on_yellow(text); end

  def bright_green(text); end

  def bright_green_on_black(text); end

  def bright_green_on_blue(text); end

  def bright_green_on_cyan(text); end

  def bright_green_on_green(text); end

  def bright_green_on_magenta(text); end

  def bright_green_on_purple(text); end

  def bright_green_on_red(text); end

  def bright_green_on_white(text); end

  def bright_green_on_yellow(text); end

  def bright_magenta(text); end

  def bright_magenta_on_black(text); end

  def bright_magenta_on_blue(text); end

  def bright_magenta_on_cyan(text); end

  def bright_magenta_on_green(text); end

  def bright_magenta_on_magenta(text); end

  def bright_magenta_on_purple(text); end

  def bright_magenta_on_red(text); end

  def bright_magenta_on_white(text); end

  def bright_magenta_on_yellow(text); end

  def bright_purple(text); end

  def bright_purple_on_black(text); end

  def bright_purple_on_blue(text); end

  def bright_purple_on_cyan(text); end

  def bright_purple_on_green(text); end

  def bright_purple_on_magenta(text); end

  def bright_purple_on_purple(text); end

  def bright_purple_on_red(text); end

  def bright_purple_on_white(text); end

  def bright_purple_on_yellow(text); end

  def bright_red(text); end

  def bright_red_on_black(text); end

  def bright_red_on_blue(text); end

  def bright_red_on_cyan(text); end

  def bright_red_on_green(text); end

  def bright_red_on_magenta(text); end

  def bright_red_on_purple(text); end

  def bright_red_on_red(text); end

  def bright_red_on_white(text); end

  def bright_red_on_yellow(text); end

  def bright_white(text); end

  def bright_white_on_black(text); end

  def bright_white_on_blue(text); end

  def bright_white_on_cyan(text); end

  def bright_white_on_green(text); end

  def bright_white_on_magenta(text); end

  def bright_white_on_purple(text); end

  def bright_white_on_red(text); end

  def bright_white_on_white(text); end

  def bright_white_on_yellow(text); end

  def bright_yellow(text); end

  def bright_yellow_on_black(text); end

  def bright_yellow_on_blue(text); end

  def bright_yellow_on_cyan(text); end

  def bright_yellow_on_green(text); end

  def bright_yellow_on_magenta(text); end

  def bright_yellow_on_purple(text); end

  def bright_yellow_on_red(text); end

  def bright_yellow_on_white(text); end

  def bright_yellow_on_yellow(text); end

  def cyan(text); end

  def cyan_on_black(text); end

  def cyan_on_blue(text); end

  def cyan_on_cyan(text); end

  def cyan_on_green(text); end

  def cyan_on_magenta(text); end

  def cyan_on_purple(text); end

  def cyan_on_red(text); end

  def cyan_on_white(text); end

  def cyan_on_yellow(text); end

  def default(text); end

  def green(text); end

  def green_on_black(text); end

  def green_on_blue(text); end

  def green_on_cyan(text); end

  def green_on_green(text); end

  def green_on_magenta(text); end

  def green_on_purple(text); end

  def green_on_red(text); end

  def green_on_white(text); end

  def green_on_yellow(text); end

  def indent(text, chars); end

  def magenta(text); end

  def magenta_on_black(text); end

  def magenta_on_blue(text); end

  def magenta_on_cyan(text); end

  def magenta_on_green(text); end

  def magenta_on_magenta(text); end

  def magenta_on_purple(text); end

  def magenta_on_red(text); end

  def magenta_on_white(text); end

  def magenta_on_yellow(text); end

  def no_color(); end

  def no_pager(); end

  def purple(text); end

  def purple_on_black(text); end

  def purple_on_blue(text); end

  def purple_on_cyan(text); end

  def purple_on_green(text); end

  def purple_on_magenta(text); end

  def purple_on_purple(text); end

  def purple_on_red(text); end

  def purple_on_white(text); end

  def purple_on_yellow(text); end

  def red(text); end

  def red_on_black(text); end

  def red_on_blue(text); end

  def red_on_cyan(text); end

  def red_on_green(text); end

  def red_on_magenta(text); end

  def red_on_purple(text); end

  def red_on_red(text); end

  def red_on_white(text); end

  def red_on_yellow(text); end

  def strip_color(text); end

  def white(text); end

  def white_on_black(text); end

  def white_on_blue(text); end

  def white_on_cyan(text); end

  def white_on_green(text); end

  def white_on_magenta(text); end

  def white_on_purple(text); end

  def white_on_red(text); end

  def white_on_white(text); end

  def white_on_yellow(text); end

  def with_line_numbers(text, offset, color=T.unsafe(nil)); end

  def yellow(text); end

  def yellow_on_black(text); end

  def yellow_on_blue(text); end

  def yellow_on_cyan(text); end

  def yellow_on_green(text); end

  def yellow_on_magenta(text); end

  def yellow_on_purple(text); end

  def yellow_on_red(text); end

  def yellow_on_white(text); end

  def yellow_on_yellow(text); end
  COLORS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  extend ::Pry::Helpers::Text
end

module Pry::Helpers
  def self.tablify(things, line_length, config=T.unsafe(nil)); end

  def self.tablify_or_one_line(heading, things, config=T.unsafe(nil)); end

  def self.tablify_to_screen_width(things, options, config=T.unsafe(nil)); end
end

class Pry::History
  def <<(line); end

  def clear(); end

  def clearer(); end

  def clearer=(clearer); end

  def filter(history); end

  def history_line_count(); end

  def initialize(options=T.unsafe(nil)); end

  def load(); end

  def loader(); end

  def loader=(loader); end

  def original_lines(); end

  def push(line); end

  def pusher(); end

  def pusher=(pusher); end

  def restore_default_behavior(); end

  def saver(); end

  def saver=(saver); end

  def session_line_count(); end

  def to_a(); end
end

class Pry::History
end

class Pry::Hooks
  def add_hook(event_name, hook_name, callable=T.unsafe(nil), &block); end

  def clear_event_hooks(event_name); end

  def delete_hook(event_name, hook_name); end

  def errors(); end

  def exec_hook(event_name, *args, &block); end

  def get_hook(event_name, hook_name); end

  def get_hooks(event_name); end

  def hook_count(event_name); end

  def hook_exists?(event_name, hook_name); end

  def hooks(); end

  def merge(other); end

  def merge!(other); end
end

class Pry::Hooks
end

class Pry::Indent
  include ::Pry::Helpers::BaseHelpers
  def correct_indentation(prompt, code, overhang=T.unsafe(nil)); end

  def current_prefix(); end

  def end_of_statement?(last_token, last_kind); end

  def in_string?(); end

  def indent(input); end

  def indent_level(); end

  def indentation_delta(tokens); end

  def module_nesting(); end

  def open_delimiters(); end

  def open_delimiters_line(); end

  def reset(); end

  def stack(); end

  def tokenize(string); end

  def track_delimiter(token); end

  def track_module_nesting(token, kind); end

  def track_module_nesting_end(token, kind=T.unsafe(nil)); end
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent
  def self.indent(str); end

  def self.nesting_at(str, line_number); end
end

class Pry::InputLock
  def __with_ownership(&block); end

  def enter_interruptible_region(); end

  def interruptible_region(&block); end

  def leave_interruptible_region(); end

  def with_ownership(&block); end
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock
  def self.for(input); end

  def self.global_lock(); end

  def self.global_lock=(global_lock); end

  def self.input_locks(); end

  def self.input_locks=(input_locks); end
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
end

class Pry::LastException
  def bt_index(); end

  def bt_index=(bt_index); end

  def bt_source_location_for(index); end

  def file(); end

  def inc_bt_index(); end

  def initialize(e); end

  def line(); end

  def method_missing(name, *args, &block); end

  def wrapped_exception(); end
end

class Pry::LastException
end

class Pry::Method
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def ==(obj); end

  def alias?(); end

  def aliases(); end

  def bound_method?(); end

  def comment(); end

  def doc(); end

  def dynamically_defined?(); end

  def initialize(method, known_info=T.unsafe(nil)); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(method_name, *args, &block); end

  def name(); end

  def name_with_owner(); end

  def original_name(); end

  def pry_method?(); end

  def redefine(source); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def signature(); end

  def singleton_method?(); end

  def source(); end

  def source?(); end

  def source_file(); end

  def source_line(); end

  def source_range(); end

  def source_type(); end

  def super(times=T.unsafe(nil)); end

  def unbound_method?(); end

  def undefined?(); end

  def visibility(); end

  def wrapped(); end

  def wrapped_owner(); end
end

class Pry::Method::Disowned
  def initialize(receiver, method_name); end

  def method_missing(meth_name, *args, &block); end

  def owner(); end

  def receiver(); end
end

class Pry::Method::Disowned
end

class Pry::Method::Patcher
  def initialize(method); end

  def method(); end

  def method=(method); end

  def patch_in_ram(source); end
end

class Pry::Method::Patcher
  def self.code_for(filename); end
end

class Pry::Method::WeirdMethodLocator
  def get_method(); end

  def initialize(method, target); end

  def lost_method?(); end

  def method(); end

  def method=(method); end

  def target(); end

  def target=(target); end
end

class Pry::Method::WeirdMethodLocator
  def self.normal_method?(method, b); end

  def self.weird_method?(method, b); end
end

class Pry::Method
  extend ::Pry::Helpers::BaseHelpers
  def self.all_from_class(klass, include_super=T.unsafe(nil)); end

  def self.all_from_common(obj, _method_type=T.unsafe(nil), include_super=T.unsafe(nil)); end

  def self.all_from_obj(obj, include_super=T.unsafe(nil)); end

  def self.from_binding(b); end

  def self.from_class(klass, name, target=T.unsafe(nil)); end

  def self.from_module(klass, name, target=T.unsafe(nil)); end

  def self.from_obj(obj, name, target=T.unsafe(nil)); end

  def self.from_str(name, target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.instance_method_definition?(name, definition_line); end

  def self.instance_resolution_order(klass); end

  def self.lookup_method_via_binding(obj, method_name, method_type, target=T.unsafe(nil)); end

  def self.method_definition?(name, definition_line); end

  def self.resolution_order(obj); end

  def self.singleton_class_of(obj); end

  def self.singleton_class_resolution_order(klass); end

  def self.singleton_method_definition?(name, definition_line); end
end

class Pry::MethodNotFound
end

class Pry::MethodNotFound
end

class Pry::NoCommandError
  def initialize(match, owner); end
end

class Pry::NoCommandError
end

class Pry::ObjectPath
  def initialize(path_string, current_stack); end

  def resolve(); end
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
end

class Pry::ObsoleteError
end

class Pry::ObsoleteError
end

class Pry::Output
  def <<(*objs); end

  def _pry_(); end

  def decolorize_maybe(str); end

  def initialize(_pry_); end

  def method_missing(name, *args, &block); end

  def print(*objs); end

  def puts(*objs); end

  def tty?(); end

  def write(*objs); end
end

class Pry::Output
end

class Pry::Pager
  def _pry_(); end

  def initialize(_pry_); end

  def open(); end

  def page(text); end
end

class Pry::Pager::NullPager
  def <<(str); end

  def close(); end

  def initialize(out); end

  def print(str); end

  def puts(str); end

  def write(str); end
end

class Pry::Pager::NullPager
end

class Pry::Pager::PageTracker
  def initialize(rows, cols); end

  def page?(); end

  def record(str); end

  def reset(); end
end

class Pry::Pager::PageTracker
end

class Pry::Pager::SimplePager
  def initialize(*_); end
end

class Pry::Pager::SimplePager
end

class Pry::Pager::StopPaging
end

class Pry::Pager::StopPaging
end

class Pry::Pager::SystemPager
  def initialize(*_); end
end

class Pry::Pager::SystemPager
  def self.available?(); end

  def self.default_pager(); end
end

class Pry::Pager
end

class Pry::PluginManager
  def load_plugins(); end

  def locate_plugins(); end

  def plugins(); end
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager::NoPlugin
  def initialize(name); end

  def method_missing(*_args); end
end

class Pry::PluginManager::NoPlugin
end

class Pry::PluginManager::Plugin
  def activate!(); end

  def active(); end

  def active=(active); end

  def active?(); end

  def disable!(); end

  def enable!(); end

  def enabled(); end

  def enabled=(enabled); end

  def enabled?(); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def initialize(name, gem_name, spec, enabled); end

  def load_cli_options(); end

  def name(); end

  def name=(name); end

  def spec(); end

  def spec=(spec); end

  def supported?(); end
end

class Pry::PluginManager::Plugin
end

class Pry::PluginManager
end

module Pry::Prompt
  DEFAULT_NAME = ::T.let(nil, ::T.untyped)
  SAFE_CONTEXTS = ::T.let(nil, ::T.untyped)
end

module Pry::Prompt
  def self.[](prompt_name); end

  def self.add(prompt_name, description=T.unsafe(nil), separators=T.unsafe(nil)); end

  def self.all(); end
end

class Pry::REPL
  def initialize(pry, options=T.unsafe(nil)); end

  def input(*args, &block); end

  def output(*args, &block); end

  def pry(); end

  def pry=(pry); end

  def start(); end
end

class Pry::REPL
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.start(options); end
end

module Pry::RescuableException
end

module Pry::RescuableException
  def self.===(exception); end
end

class Pry::Result
  def command?(); end

  def initialize(is_command, retval=T.unsafe(nil)); end

  def retval(); end

  def void_command?(); end
end

class Pry::Result
end

class Pry::Ring
  def <<(value); end

  def [](index); end

  def clear(); end

  def count(); end

  def initialize(max_size); end

  def max_size(); end

  def size(); end

  def to_a(); end
end

class Pry::Ring
end

module Pry::Rubygem
end

module Pry::Rubygem
  def self.complete(so_far); end

  def self.install(name); end

  def self.installed?(name); end

  def self.list(pattern=T.unsafe(nil)); end

  def self.spec(name); end
end

class Pry::Slop
  include ::Enumerable
  def [](key); end

  def add_callback(label, &block); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def command(command, options=T.unsafe(nil), &block); end

  def config(); end

  def description(desc=T.unsafe(nil)); end

  def description=(desc); end

  def each(&block); end

  def fetch_command(command); end

  def fetch_option(key); end

  def get(key); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def missing(); end

  def on(*objects, &block); end

  def opt(*objects, &block); end

  def option(*objects, &block); end

  def options(); end

  def parse(items=T.unsafe(nil), &block); end

  def parse!(items=T.unsafe(nil), &block); end

  def present?(*keys); end

  def run(callable=T.unsafe(nil), &block); end

  def separator(text); end

  def strict?(); end

  def to_h(include_commands=T.unsafe(nil)); end

  def to_hash(include_commands=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Commands
  include ::Enumerable
  def [](key); end

  def arguments(); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def commands(); end

  def config(); end

  def default(config=T.unsafe(nil), &block); end

  def each(&block); end

  def get(key); end

  def global(config=T.unsafe(nil), &block); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def on(command, config=T.unsafe(nil), &block); end

  def parse(items=T.unsafe(nil)); end

  def parse!(items=T.unsafe(nil)); end

  def present?(key); end

  def to_hash(); end
end

class Pry::Slop::Commands
end

class Pry::Slop::Error
end

class Pry::Slop::Error
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::Option
  def accepts_optional_argument?(); end

  def argument?(); end

  def argument_in_value(); end

  def argument_in_value=(argument_in_value); end

  def as?(); end

  def autocreated?(); end

  def call(*objects); end

  def callback?(); end

  def config(); end

  def count(); end

  def count=(count); end

  def default?(); end

  def delimiter?(); end

  def description(); end

  def expects_argument?(); end

  def help(); end

  def initialize(slop, short, long, description, config=T.unsafe(nil), &block); end

  def key(); end

  def limit?(); end

  def long(); end

  def match?(); end

  def optional?(); end

  def optional_argument?(); end

  def required?(); end

  def short(); end

  def tail?(); end

  def types(); end

  def value(); end

  def value=(new_value); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
end

class Pry::Slop
  def self.optspec(string, config=T.unsafe(nil)); end

  def self.parse(items=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.parse!(items=T.unsafe(nil), config=T.unsafe(nil), &block); end
end

class Pry::Terminal
end

class Pry::Terminal
  def self.actual_screen_size(); end

  def self.height!(); end

  def self.screen_size(); end

  def self.screen_size_according_to_ansicon_env(); end

  def self.screen_size_according_to_env(); end

  def self.screen_size_according_to_io_console(); end

  def self.screen_size_according_to_readline(); end

  def self.size!(default=T.unsafe(nil)); end

  def self.width!(); end
end

module Pry::TooSafeException
end

module Pry::TooSafeException
  def self.===(exception); end
end

module Pry::UserError
end

module Pry::UserError
end

class Pry::WrappedModule
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::CodeObject::Helpers
  def candidate(rank); end

  def candidates(); end

  def class?(); end

  def constants(inherit=T.unsafe(nil)); end

  def doc(); end

  def file(); end

  def initialize(mod); end

  def line(); end

  def method_missing(method_name, *args, &block); end

  def method_prefix(); end

  def module?(); end

  def nonblank_name(); end

  def number_of_candidates(); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def singleton_class?(); end

  def singleton_instance(); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def super(times=T.unsafe(nil)); end

  def wrapped(); end

  def yard_doc(); end

  def yard_docs?(); end

  def yard_file(); end

  def yard_line(); end
end

class Pry::WrappedModule::Candidate
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def class?(*args, &block); end

  def doc(); end

  def file(); end

  def initialize(wrapper, rank); end

  def line(); end

  def module?(*args, &block); end

  def nonblank_name(*args, &block); end

  def number_of_candidates(*args, &block); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def wrapped(*args, &block); end
end

class Pry::WrappedModule::Candidate
  extend ::Pry::Forwardable
  extend ::Forwardable
end

class Pry::WrappedModule
  def self.from_str(mod_name, target=T.unsafe(nil)); end
end

class Pry
  extend ::Pry::Config::Convenience
  def self.Code(obj); end

  def self.Method(obj); end

  def self.WrappedModule(obj); end

  def self.auto_resize!(); end

  def self.binding_for(target); end

  def self.cli(); end

  def self.cli=(cli); end

  def self.color(); end

  def self.color=(value); end

  def self.commands(); end

  def self.commands=(value); end

  def self.config(); end

  def self.config=(config); end

  def self.configure(); end

  def self.critical_section(); end

  def self.current(); end

  def self.current_line(); end

  def self.current_line=(current_line); end

  def self.custom_completions(); end

  def self.custom_completions=(custom_completions); end

  def self.default_editor_for_platform(); end

  def self.editor(); end

  def self.editor=(value); end

  def self.eval_path(); end

  def self.eval_path=(eval_path); end

  def self.exception_handler(); end

  def self.exception_handler=(value); end

  def self.extra_sticky_locals(); end

  def self.extra_sticky_locals=(value); end

  def self.final_session_setup(); end

  def self.history(); end

  def self.history=(history); end

  def self.hooks(); end

  def self.hooks=(value); end

  def self.in_critical_section?(); end

  def self.init(); end

  def self.initial_session?(); end

  def self.initial_session_setup(); end

  def self.input(); end

  def self.input=(value); end

  def self.last_internal_error(); end

  def self.last_internal_error=(last_internal_error); end

  def self.lazy(&block); end

  def self.line_buffer(); end

  def self.line_buffer=(line_buffer); end

  def self.load_file_at_toplevel(file); end

  def self.load_file_through_repl(file_name); end

  def self.load_history(); end

  def self.load_plugins(*args, &block); end

  def self.load_rc_files(); end

  def self.load_requires(); end

  def self.load_traps(); end

  def self.load_win32console(); end

  def self.locate_plugins(*args, &block); end

  def self.main(); end

  def self.memory_size(); end

  def self.memory_size=(value); end

  def self.output(); end

  def self.output=(value); end

  def self.pager(); end

  def self.pager=(value); end

  def self.plugins(*args, &block); end

  def self.print(); end

  def self.print=(value); end

  def self.prompt(); end

  def self.prompt=(value); end

  def self.quiet(); end

  def self.quiet=(quiet); end

  def self.rc_files_to_load(); end

  def self.real_path_to(file); end

  def self.reset_defaults(); end

  def self.run_command(command_string, options=T.unsafe(nil)); end

  def self.start(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.start_with_pry_nav(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.start_without_pry_nav(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.toplevel_binding(); end

  def self.toplevel_binding=(binding); end

  def self.view_clip(obj, options=T.unsafe(nil)); end
end

module PryNav
  def check_file_context(target); end

  def current_remote_server(); end

  def current_remote_server=(current_remote_server); end
  Commands = ::T.let(nil, ::T.untyped)
  TRACE_IGNORE_FILES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PryNav::Tracer
  def initialize(pry_start_options=T.unsafe(nil), &block); end

  def process_command(command=T.unsafe(nil)); end

  def run(&block); end

  def start(); end

  def stop(); end
end

class PryNav::Tracer
end

module PryNav
  extend ::PryNav
end

module PryStackExplorer
  Commands = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module PryStackExplorer::FrameHelpers
end

module PryStackExplorer::FrameHelpers
end

class PryStackExplorer::FrameManager
  include ::Enumerable
  def binding_index(); end

  def binding_index=(binding_index); end

  def bindings(); end

  def bindings=(bindings); end

  def change_frame_to(index, run_whereami=T.unsafe(nil)); end

  def current_frame(); end

  def each(&block); end

  def initialize(bindings, _pry_); end

  def prior_backtrace(); end

  def prior_binding(); end

  def refresh_frame(run_whereami=T.unsafe(nil)); end

  def set_binding_index_safely(index); end

  def user(); end
end

class PryStackExplorer::FrameManager
end

class PryStackExplorer::WhenStartedHook
  include ::Pry::Helpers::BaseHelpers
  def call(target, options, _pry_); end

  def caller_bindings(target); end
end

class PryStackExplorer::WhenStartedHook
end

module PryStackExplorer
  def self.bindings_equal?(b1, b2); end

  def self.clear_frame_managers(_pry_); end

  def self.create_and_push_frame_manager(bindings, _pry_, options=T.unsafe(nil)); end

  def self.delete_frame_managers(_pry_); end

  def self.frame_hash(); end

  def self.frame_manager(_pry_); end

  def self.frame_managers(_pry_); end

  def self.pop_frame_manager(_pry_); end
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def alias?(); end

  def children(); end

  def document?(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def mapping?(); end

  def scalar?(); end

  def sequence?(); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def stream?(); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename, fallback: T.unsafe(nil)); end

  def self.parse_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, legacy_permitted_classes=T.unsafe(nil), legacy_permitted_symbols=T.unsafe(nil), legacy_aliases=T.unsafe(nil), legacy_filename=T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::Domain
  def domain(); end

  def domain?(); end

  def initialize(*args); end

  def name(); end

  def sld(); end

  def subdomain(); end

  def subdomain?(); end

  def tld(); end

  def to_a(); end

  def trd(); end
end

class PublicSuffix::Domain
  def self.name_to_labels(name); end
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::Error
end

class PublicSuffix::Error
end

class PublicSuffix::List
  def <<(rule); end

  def ==(other); end

  def add(rule); end

  def clear(); end

  def default_rule(); end

  def each(&block); end

  def empty?(); end

  def eql?(other); end

  def find(name, default: T.unsafe(nil), **options); end

  def rules(); end

  def size(); end
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  def self.default(**options); end

  def self.default=(value); end

  def self.parse(input, private_domains: T.unsafe(nil)); end
end

module PublicSuffix::Rule
end

class PublicSuffix::Rule::Base
  def ==(other); end

  def decompose(*_); end

  def eql?(other); end

  def initialize(value:, length: T.unsafe(nil), private: T.unsafe(nil)); end

  def length(); end

  def match?(name); end

  def parts(); end

  def private(); end

  def value(); end
end

class PublicSuffix::Rule::Base
  def self.build(content, private: T.unsafe(nil)); end
end

class PublicSuffix::Rule::Entry
  def length=(_); end

  def private(); end

  def private=(_); end

  def type(); end

  def type=(_); end
end

class PublicSuffix::Rule::Entry
  def self.[](*_); end

  def self.members(); end
end

class PublicSuffix::Rule::Exception
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Exception
end

class PublicSuffix::Rule::Normal
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Normal
end

class PublicSuffix::Rule::Wildcard
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Wildcard
end

module PublicSuffix::Rule
  def self.default(); end

  def self.factory(content, private: T.unsafe(nil)); end
end

module PublicSuffix
  def self.decompose(name, rule); end

  def self.domain(name, **options); end

  def self.normalize(name); end

  def self.parse(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end

  def self.valid?(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end
end

module REXML
  COPYRIGHT = ::T.let(nil, ::T.untyped)
  Copyright = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class REXML::AttlistDecl
  include ::Enumerable
  def [](key); end

  def each(&block); end

  def element_name(); end

  def include?(key); end

  def initialize(source); end

  def node_type(); end

  def write(out, indent=T.unsafe(nil)); end
end

class REXML::AttlistDecl
end

class REXML::Attribute
  include ::REXML::Node
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def ==(other); end

  def clone(); end

  def doctype(); end

  def element(); end

  def element=(element); end

  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end

  def namespace(arg=T.unsafe(nil)); end

  def node_type(); end

  def normalized=(normalized); end

  def remove(); end

  def to_s(); end

  def to_string(); end

  def value(); end

  def write(output, indent=T.unsafe(nil)); end

  def xpath(); end
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class REXML::Attribute
end

class REXML::Attributes
  def <<(attribute); end

  def [](name); end

  def []=(name, value); end

  def add(attribute); end

  def delete(attribute); end

  def delete_all(name); end

  def each_attribute(); end

  def get_attribute(name); end

  def get_attribute_ns(namespace, name); end

  def initialize(element); end

  def namespaces(); end

  def prefixes(); end
end

class REXML::Attributes
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  ILLEGAL = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::CData
end

class REXML::Child
  include ::REXML::Node
  def bytes(); end

  def document(); end

  def initialize(parent=T.unsafe(nil)); end

  def next_sibling(); end

  def next_sibling=(other); end

  def parent(); end

  def parent=(other); end

  def previous_sibling(); end

  def previous_sibling=(other); end

  def remove(); end

  def replace_with(child); end
end

class REXML::Child
end

class REXML::Comment
  include ::Comparable
  def ==(other); end

  def clone(); end

  def initialize(first, second=T.unsafe(nil)); end

  def node_type(); end

  def string(); end

  def string=(string); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Comment
end

class REXML::Declaration
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::Declaration
end

class REXML::DocType
  include ::REXML::XMLTokens
  def add(child); end

  def attribute_of(element, attribute); end

  def attributes_of(element); end

  def clone(); end

  def context(); end

  def entities(); end

  def entity(name); end

  def external_id(); end

  def initialize(first, parent=T.unsafe(nil)); end

  def name(); end

  def namespaces(); end

  def node_type(); end

  def notation(name); end

  def notations(); end

  def public(); end

  def system(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
end

class REXML::DocType
end

class REXML::Document
  def <<(child); end

  def add(child); end

  def add_element(arg=T.unsafe(nil), arg2=T.unsafe(nil)); end

  def doctype(); end

  def encoding(); end

  def entity_expansion_count(); end

  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end

  def record_entity_expansion(); end

  def stand_alone?(); end

  def version(); end

  def write(*arguments); end

  def xml_decl(); end
  DECLARATION = ::T.let(nil, ::T.untyped)
end

class REXML::Document
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end

  def self.parse_stream(source, listener); end
end

class REXML::Element
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def [](name_or_index); end

  def add_attribute(key, value=T.unsafe(nil)); end

  def add_attributes(hash); end

  def add_element(element, attrs=T.unsafe(nil)); end

  def add_namespace(prefix, uri=T.unsafe(nil)); end

  def add_text(text); end

  def attribute(name, namespace=T.unsafe(nil)); end

  def attributes(); end

  def cdatas(); end

  def clone(); end

  def comments(); end

  def context(); end

  def context=(context); end

  def delete_attribute(key); end

  def delete_element(element); end

  def delete_namespace(namespace=T.unsafe(nil)); end

  def each_element(xpath=T.unsafe(nil), &block); end

  def each_element_with_attribute(key, value=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def each_element_with_text(text=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def elements(); end

  def get_elements(xpath); end

  def get_text(path=T.unsafe(nil)); end

  def has_attributes?(); end

  def has_elements?(); end

  def has_text?(); end

  def ignore_whitespace_nodes(); end

  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end

  def instructions(); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespaces(); end

  def next_element(); end

  def node_type(); end

  def prefixes(); end

  def previous_element(); end

  def raw(); end

  def root(); end

  def root_node(); end

  def text(path=T.unsafe(nil)); end

  def text=(text); end

  def texts(); end

  def whitespace(); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def xpath(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class REXML::Element
end

class REXML::ElementDecl
end

class REXML::ElementDecl
end

class REXML::Elements
  include ::Enumerable
  def <<(element=T.unsafe(nil)); end

  def [](index, name=T.unsafe(nil)); end

  def []=(index, element); end

  def add(element=T.unsafe(nil)); end

  def collect(xpath=T.unsafe(nil)); end

  def delete(element); end

  def delete_all(xpath); end

  def each(xpath=T.unsafe(nil), &blk); end

  def empty?(); end

  def index(element); end

  def initialize(parent); end

  def inject(xpath=T.unsafe(nil), initial=T.unsafe(nil)); end

  def size(); end

  def to_a(xpath=T.unsafe(nil)); end
end

class REXML::Elements
end

module REXML::Encoding
  def decode(string); end

  def encode(string); end

  def encoding(); end

  def encoding=(encoding); end
end

module REXML::Encoding
end

class REXML::Entity
  include ::REXML::XMLTokens
  def external(); end

  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end

  def name(); end

  def ndata(); end

  def normalized(); end

  def pubid(); end

  def ref(); end

  def to_s(); end

  def unnormalized(); end

  def value(); end

  def write(out, indent=T.unsafe(nil)); end
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PEREFERENCE_RE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::Entity
  def self.matches?(string); end
end

module REXML::EntityConst
  AMP = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  GT = ::T.let(nil, ::T.untyped)
  LT = ::T.let(nil, ::T.untyped)
  QUOT = ::T.let(nil, ::T.untyped)
end

module REXML::EntityConst
end

class REXML::ExternalEntity
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::ExternalEntity
end

module REXML::Formatters
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end

  def write(node, output); end

  def write_cdata(node, output); end

  def write_comment(node, output); end

  def write_document(node, output); end

  def write_element(node, output); end

  def write_instruction(node, output); end

  def write_text(node, output); end
end

class REXML::Formatters::Default
end

class REXML::Formatters::Pretty
  def compact(); end

  def compact=(compact); end

  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class REXML::Formatters::Pretty
end

module REXML::Formatters
end

module REXML::Functions
  INTERNAL_METHODS = ::T.let(nil, ::T.untyped)
end

module REXML::Functions
  def self.boolean(object=T.unsafe(nil)); end

  def self.ceiling(number); end

  def self.compare_language(lang1, lang2); end

  def self.concat(*objects); end

  def self.contains(string, test); end

  def self.context=(value); end

  def self.count(node_set); end

  def self.false(); end

  def self.floor(number); end

  def self.get_namespace(node_set=T.unsafe(nil)); end

  def self.id(object); end

  def self.lang(language); end

  def self.last(); end

  def self.local_name(node_set=T.unsafe(nil)); end

  def self.name(node_set=T.unsafe(nil)); end

  def self.namespace_context(); end

  def self.namespace_context=(x); end

  def self.namespace_uri(node_set=T.unsafe(nil)); end

  def self.normalize_space(string=T.unsafe(nil)); end

  def self.not(object); end

  def self.number(object=T.unsafe(nil)); end

  def self.position(); end

  def self.processing_instruction(node); end

  def self.round(number); end

  def self.send(name, *args); end

  def self.singleton_method_added(name); end

  def self.starts_with(string, test); end

  def self.string(object=T.unsafe(nil)); end

  def self.string_length(string); end

  def self.string_value(o); end

  def self.substring(string, start, length=T.unsafe(nil)); end

  def self.substring_after(string, test); end

  def self.substring_before(string, test); end

  def self.sum(nodes); end

  def self.text(); end

  def self.translate(string, tr1, tr2); end

  def self.true(); end

  def self.variables(); end

  def self.variables=(x); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::IOSource
end

class REXML::Instruction
  def ==(other); end

  def clone(); end

  def content(); end

  def content=(content); end

  def initialize(target, content=T.unsafe(nil)); end

  def node_type(); end

  def target(); end

  def target=(target); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Instruction
end

module REXML::Light
end

class REXML::Light::Node
  def <<(element); end

  def =~(path); end

  def [](reference, ns=T.unsafe(nil)); end

  def []=(reference, ns, value=T.unsafe(nil)); end

  def children(); end

  def each(&blk); end

  def has_name?(name, namespace=T.unsafe(nil)); end

  def initialize(node=T.unsafe(nil)); end

  def local_name(); end

  def local_name=(name_str); end

  def name(); end

  def name=(name_str, ns=T.unsafe(nil)); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespace=(namespace); end

  def node_type(); end

  def parent(); end

  def parent=(node); end

  def prefix(namespace=T.unsafe(nil)); end

  def root(); end

  def size(); end

  def text=(foo); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
  PARENTS = ::T.let(nil, ::T.untyped)
end

class REXML::Light::Node
end

module REXML::Light
end

module REXML::Namespace
  include ::REXML::XMLTokens
  def expanded_name(); end

  def fully_expanded_name(); end

  def has_name?(other, ns=T.unsafe(nil)); end

  def local_name(); end

  def name(); end

  def name=(name); end

  def prefix(); end

  def prefix=(prefix); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
end

module REXML::Namespace
end

module REXML::Node
  def each_recursive(&block); end

  def find_first_recursive(&block); end

  def indent(to, ind); end

  def index_in_parent(); end

  def next_sibling_node(); end

  def parent?(); end

  def previous_sibling_node(); end

  def to_s(indent=T.unsafe(nil)); end
end

module REXML::Node
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end

  def name(); end

  def public(); end

  def public=(public); end

  def system(); end

  def system=(system); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil)); end
end

class REXML::NotationDecl
end

class REXML::Output
  include ::REXML::Encoding
  def <<(content); end

  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::Output
end

class REXML::Parent
  include ::Enumerable
  def <<(object); end

  def [](index); end

  def []=(*args); end

  def add(object); end

  def children(); end

  def deep_clone(); end

  def delete(object); end

  def delete_at(index); end

  def delete_if(&block); end

  def each(&block); end

  def each_child(&block); end

  def each_index(&block); end

  def index(child); end

  def insert_after(child1, child2); end

  def insert_before(child1, child2); end

  def length(); end

  def push(object); end

  def replace_child(to_replace, replacement); end

  def size(); end

  def to_a(); end

  def unshift(object); end
end

class REXML::Parent
end

class REXML::ParseException
  def context(); end

  def continued_exception(); end

  def continued_exception=(continued_exception); end

  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end

  def line(); end

  def parser(); end

  def parser=(parser); end

  def position(); end

  def source(); end

  def source=(source); end
end

class REXML::ParseException
end

module REXML::Parsers
end

class REXML::Parsers::BaseParser
  def add_listener(listener); end

  def empty?(); end

  def entity(reference, entities); end

  def has_next?(); end

  def initialize(source); end

  def normalize(input, entities=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def peek(depth=T.unsafe(nil)); end

  def position(); end

  def pull(); end

  def source(); end

  def stream=(source); end

  def unnormalize(string, entities=T.unsafe(nil), filter=T.unsafe(nil)); end

  def unshift(token); end
  ATTDEF = ::T.let(nil, ::T.untyped)
  ATTDEF_RE = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_START = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_PATTERN = ::T.let(nil, ::T.untyped)
  ATTTYPE = ::T.let(nil, ::T.untyped)
  ATTVALUE = ::T.let(nil, ::T.untyped)
  CDATA_END = ::T.let(nil, ::T.untyped)
  CDATA_PATTERN = ::T.let(nil, ::T.untyped)
  CDATA_START = ::T.let(nil, ::T.untyped)
  CLOSE_MATCH = ::T.let(nil, ::T.untyped)
  COMBININGCHAR = ::T.let(nil, ::T.untyped)
  COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
  COMMENT_START = ::T.let(nil, ::T.untyped)
  DEFAULTDECL = ::T.let(nil, ::T.untyped)
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DOCTYPE_END = ::T.let(nil, ::T.untyped)
  DOCTYPE_PATTERN = ::T.let(nil, ::T.untyped)
  DOCTYPE_START = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_START = ::T.let(nil, ::T.untyped)
  ENCODING = ::T.let(nil, ::T.untyped)
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  ENTITY_START = ::T.let(nil, ::T.untyped)
  ENUMERATEDTYPE = ::T.let(nil, ::T.untyped)
  ENUMERATION = ::T.let(nil, ::T.untyped)
  EREFERENCE = ::T.let(nil, ::T.untyped)
  EXTENDER = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  INSTRUCTION_PATTERN = ::T.let(nil, ::T.untyped)
  INSTRUCTION_START = ::T.let(nil, ::T.untyped)
  LETTER = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  NOTATIONDECL_START = ::T.let(nil, ::T.untyped)
  NOTATIONTYPE = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  REFERENCE_RE = ::T.let(nil, ::T.untyped)
  STANDALONE = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
  SYSTEMENTITY = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
  TAG_MATCH = ::T.let(nil, ::T.untyped)
  TEXT_PATTERN = ::T.let(nil, ::T.untyped)
  UNAME_STR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  XMLDECL_PATTERN = ::T.let(nil, ::T.untyped)
  XMLDECL_START = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::BaseParser
end

class REXML::Parsers::StreamParser
  def add_listener(listener); end

  def initialize(source, listener); end

  def parse(); end
end

class REXML::Parsers::StreamParser
end

class REXML::Parsers::TreeParser
  def add_listener(listener); end

  def initialize(source, build_context=T.unsafe(nil)); end

  def parse(); end
end

class REXML::Parsers::TreeParser
end

class REXML::Parsers::XPathParser
  include ::REXML::XMLTokens
  def abbreviate(path); end

  def expand(path); end

  def namespaces=(namespaces); end

  def parse(path); end

  def predicate(path); end

  def predicate_to_string(path, &block); end
  AXIS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  NT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PI = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
end

module REXML::Parsers
end

module REXML::Security
end

module REXML::Security
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end
end

class REXML::Source
  include ::REXML::Encoding
  def buffer(); end

  def consume(pattern); end

  def current_line(); end

  def empty?(); end

  def encoding=(enc); end

  def initialize(arg, encoding=T.unsafe(nil)); end

  def line(); end

  def match(pattern, cons=T.unsafe(nil)); end

  def match_to(char, pattern); end

  def match_to_consume(char, pattern); end

  def position(); end

  def read(); end

  def scan(pattern, cons=T.unsafe(nil)); end
end

class REXML::Source
end

class REXML::SourceFactory
end

class REXML::SourceFactory
  def self.create_from(arg); end
end

class REXML::SyncEnumerator
  include ::Enumerable
  def each(&blk); end

  def initialize(*enums); end

  def length(); end

  def size(); end
end

class REXML::SyncEnumerator
end

class REXML::Text
  include ::Comparable
  def <<(to_append); end

  def clone(); end

  def doctype(); end

  def empty?(); end

  def indent_text(string, level=T.unsafe(nil), style=T.unsafe(nil), indentfirstline=T.unsafe(nil)); end

  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end

  def node_type(); end

  def parent=(parent); end

  def raw(); end

  def raw=(raw); end

  def to_s(); end

  def value(); end

  def value=(val); end

  def wrap(string, width, addnewline=T.unsafe(nil)); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def write_with_substitution(out, input); end

  def xpath(); end
  EREFERENCE = ::T.let(nil, ::T.untyped)
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  NUMERICENTITY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SETUTITSBUS = ::T.let(nil, ::T.untyped)
  SLAICEPS = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
  SUBSTITUTES = ::T.let(nil, ::T.untyped)
  VALID_CHAR = ::T.let(nil, ::T.untyped)
  VALID_XML_CHARS = ::T.let(nil, ::T.untyped)
end

class REXML::Text
  def self.check(string, pattern, doctype); end

  def self.expand(ref, doctype, filter); end

  def self.normalize(input, doctype=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def self.read_with_substitution(input, illegal=T.unsafe(nil)); end

  def self.unnormalize(string, doctype=T.unsafe(nil), filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::UndefinedNamespaceException
end

module REXML::Validation
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::Validation::ValidationException
end

module REXML::Validation
end

class REXML::XMLDecl
  include ::REXML::Encoding
  def ==(other); end

  def clone(); end

  def dowrite(); end

  def encoding=(enc); end

  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end

  def node_type(); end

  def nowrite(); end

  def old_enc=(encoding); end

  def stand_alone?(); end

  def standalone(); end

  def standalone=(standalone); end

  def version(); end

  def version=(version); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def writeencoding(); end

  def writethis(); end

  def xmldecl(version, encoding, standalone); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  DEFAULT_STANDALONE = ::T.let(nil, ::T.untyped)
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::XMLDecl
  def self.default(); end
end

module REXML::XMLTokens
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_CHAR = ::T.let(nil, ::T.untyped)
  NAME_START_CHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
end

module REXML::XMLTokens
end

class REXML::XPath
  include ::REXML::Functions
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

class REXML::XPath
  def self.each(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.first(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  include ::REXML::XMLTokens
  def []=(variable_name, value); end

  def first(path_stack, node); end

  def get_first(path, nodeset); end

  def initialize(strict: T.unsafe(nil)); end

  def match(path_stack, nodeset); end

  def namespaces=(namespaces=T.unsafe(nil)); end

  def parse(path, nodeset); end

  def predicate(path, nodeset); end

  def variables=(vars=T.unsafe(nil)); end
  LITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
end

module REXML
end

class REXMLUtilityNode
  def add_node(node); end

  def attributes(); end

  def attributes=(attributes); end

  def children(); end

  def children=(children); end

  def initialize(name, normalized_attributes=T.unsafe(nil)); end

  def inner_html(); end

  def name(); end

  def name=(name); end

  def to_hash(); end

  def to_html(); end

  def type(); end

  def type=(type); end

  def typecast_value(value); end

  def undasherize_keys(params); end
end

class REXMLUtilityNode
  def self.available_typecasts(); end

  def self.available_typecasts=(obj); end

  def self.typecasts(); end

  def self.typecasts=(obj); end
end

class REXMLUtiliyNodeString
  def attributes(); end

  def attributes=(attributes); end
end

class REXMLUtiliyNodeString
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rack::Auth
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

module Rack::Auth::Digest
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

module Rack::Auth::Digest
end

module Rack::Auth
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, &block); end
end

class Rack::BodyProxy
end

class Rack::Builder
  def call(env); end

  def freeze_app(); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.load_file(path, opts=T.unsafe(nil)); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, cascade_for=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  def close(); end

  def each(&block); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked::TrailerBody
end

class Rack::Chunked
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime, sync); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def root(); end

  def stat(path); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
end

class Rack::Events
  def call(env); end

  def initialize(app, handlers); end
end

module Rack::Events::Abstract
  def on_commit(req, res); end

  def on_error(req, res, e); end

  def on_finish(req, res); end

  def on_send(req, res); end

  def on_start(req, res); end
end

module Rack::Events::Abstract
end

class Rack::Events::BufferedResponse
  def body(); end

  def initialize(status, headers, body); end

  def to_a(); end
end

class Rack::Events::BufferedResponse
end

class Rack::Events::EventedBodyProxy
  def each(&blk); end

  def initialize(body, request, response, handlers, &block); end

  def request(); end

  def response(); end
end

class Rack::Events::EventedBodyProxy
end

class Rack::Events
end

Rack::File = Rack::Files

class Rack::Files
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Files::BaseIterator
  def bytesize(); end

  def close(); end

  def each(&blk); end

  def initialize(path, ranges, options); end

  def options(); end

  def path(); end

  def ranges(); end
end

class Rack::Files::BaseIterator
end

class Rack::Files::Iterator
  def to_path(); end
end

class Rack::Files::Iterator
end

class Rack::Files
  def self.method_added(name); end
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, **options); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def flush(*args, &block); end

  def initialize(io); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
  extend ::Forwardable
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  def self.params(content_type); end

  def self.type(content_type); end
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def cookie(name); end

  def cookies(); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
  def self.[](*_); end
end

class Rack::MockSession
  def after_request(&block); end

  def clear_cookies(); end

  def cookie_jar(); end

  def cookie_jar=(cookie_jar); end

  def default_host(); end

  def initialize(app, default_host=T.unsafe(nil)); end

  def last_request(); end

  def last_response(); end

  def request(uri, env); end

  def set_cookie(cookie, uri=T.unsafe(nil)); end
end

class Rack::MockSession
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size, outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

class Rack::QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end

  def key_space_limit(); end

  def make_params(); end

  def new_depth_limit(param_depth_limit); end

  def new_space_limit(key_space_limit); end

  def normalize_params(params, name, v, depth); end

  def param_depth_limit(); end

  def parse_nested_query(qs, d=T.unsafe(nil)); end

  def parse_query(qs, d=T.unsafe(nil), &unescaper); end
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::Params
  def [](key); end

  def []=(key, value); end

  def initialize(limit); end

  def key?(key); end

  def to_h(); end

  def to_params_hash(); end
end

class Rack::QueryParser::Params
end

class Rack::QueryParser
  def self.make_default(key_space_limit, param_depth_limit); end
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Env
  def add_header(key, v); end

  def delete_header(name); end

  def each_header(&block); end

  def env(); end

  def fetch_header(name, &block); end

  def get_header(name); end

  def has_header?(name); end

  def initialize(env); end

  def set_header(name, v); end
end

module Rack::Request::Env
end

module Rack::Request::Helpers
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def accept_language(); end

  def authority(); end

  def base_url(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def delete_param(k); end

  def form_data?(); end

  def forwarded_authority(); end

  def forwarded_for(); end

  def forwarded_port(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_authority(); end

  def host_with_port(authority=T.unsafe(nil)); end

  def hostname(); end

  def ip(); end

  def link?(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def multithread?(); end

  def options?(); end

  def params(); end

  def parseable_data?(); end

  def patch?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def server_authority(); end

  def server_name(); end

  def server_port(); end

  def session(); end

  def session_options(); end

  def ssl?(); end

  def trace?(); end

  def trusted_proxy?(ip); end

  def unlink?(); end

  def update_param(k, v); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def xhr?(); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
end

class Rack::Request
  def self.ip_filter(); end

  def self.ip_filter=(ip_filter); end
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, v); end

  def body(); end

  def body=(body); end

  def chunked?(); end

  def close(); end

  def delete_header(key); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), headers=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def write(chunk); end
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def add_header(key, v); end

  def append(chunk); end

  def bad_request?(); end

  def buffered_body!(); end

  def cache!(duration=T.unsafe(nil), directive: T.unsafe(nil)); end

  def cache_control(); end

  def cache_control=(v); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def content_type=(content_type); end

  def created?(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def do_not_cache!(); end

  def etag(); end

  def etag=(v); end

  def forbidden?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def location=(location); end

  def media_type(); end

  def media_type_params(); end

  def method_not_allowed?(); end

  def moved_permanently?(); end

  def no_content?(); end

  def not_found?(); end

  def ok?(); end

  def precondition_failed?(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def set_cookie(key, value); end

  def set_cookie_header(); end

  def set_cookie_header=(v); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

module Rack::Response::Helpers
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers
  def delete_header(key); end

  def get_header(key); end

  def has_header?(key); end

  def headers(); end

  def initialize(status, headers); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end
end

class Rack::Response::Raw
end

class Rack::Response
  def self.[](status, headers, body); end
end

class Rack::RewindableInput
  def close(); end

  def each(&block); end

  def gets(); end

  def initialize(io); end

  def read(*args); end

  def rewind(); end
end

class Rack::RewindableInput
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&block); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

module Rack::Session
end

module Rack::Session::Abstract
end

class Rack::Session::Abstract::ID
  def find_session(req, sid); end
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def commit_session(req, res); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end

  def sid_secure(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
end

class Rack::Session::Abstract::PersistedSecure
  def extract_session_id(*_); end

  def generate_sid(*_); end
end

class Rack::Session::Abstract::PersistedSecure
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def dig(key, *keys); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  def self.find(req); end

  def self.set(req, session); end

  def self.set_options(req, options); end
end

module Rack::Session::Abstract
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value); end
end

class Rack::Session::Cookie::SessionId
end

class Rack::Session::Cookie
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

class Rack::Session::SessionId
  def cookie_value(); end

  def empty?(); end

  def initialize(public_id); end

  def private_id(); end

  def public_id(); end
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Session::SessionId
end

module Rack::Session
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end

  def template(); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::Cookie
  include ::Rack::Utils
  def default_uri(); end

  def domain(); end

  def empty?(); end

  def expired?(); end

  def expires(); end

  def http_only?(); end

  def initialize(raw, uri=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def matches?(uri); end

  def name(); end

  def path(); end

  def raw(); end

  def replaces?(other); end

  def secure?(); end

  def to_h(); end

  def to_hash(); end

  def valid?(uri); end

  def value(); end
end

class Rack::Test::Cookie
end

class Rack::Test::CookieJar
  def <<(new_cookie); end

  def [](name); end

  def []=(name, value); end

  def delete(name); end

  def for(uri); end

  def get_cookie(name); end

  def hash_for(uri=T.unsafe(nil)); end

  def initialize(cookies=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def merge(raw_cookies, uri=T.unsafe(nil)); end

  def to_hash(); end
  DELIMITER = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
end

class Rack::Test::Error
end

class Rack::Test::Error
end

module Rack::Test::Methods
  def _current_session_names(); end

  def authorize(*args, &block); end

  def basic_authorize(*args, &block); end

  def build_rack_mock_session(); end

  def build_rack_test_session(name); end

  def clear_cookies(*args, &block); end

  def current_session(); end

  def custom_request(*args, &block); end

  def delete(*args, &block); end

  def digest_authorize(*args, &block); end

  def env(*args, &block); end

  def follow_redirect!(*args, &block); end

  def get(*args, &block); end

  def head(*args, &block); end

  def header(*args, &block); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(*args, &block); end

  def patch(*args, &block); end

  def post(*args, &block); end

  def put(*args, &block); end

  def rack_mock_session(name=T.unsafe(nil)); end

  def rack_test_session(name=T.unsafe(nil)); end

  def request(*args, &block); end

  def set_cookie(*args, &block); end

  def with_session(name); end
  METHODS = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  extend ::Forwardable
end

class Rack::Test::MockDigestRequest
  def initialize(params); end

  def method(); end

  def method_missing(sym); end

  def response(password); end
end

class Rack::Test::MockDigestRequest
end

class Rack::Test::Session
  include ::Rack::Test::Utils
  include ::Rack::Utils
  def authorize(username, password); end

  def basic_authorize(username, password); end

  def clear_cookies(*args, &block); end

  def custom_request(verb, uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def delete(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def digest_authorize(username, password); end

  def env(name, value); end

  def follow_redirect!(); end

  def get(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def head(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def header(name, value); end

  def initialize(mock_session); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def patch(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def post(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def put(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def request(uri, env=T.unsafe(nil), &block); end

  def set_cookie(*args, &block); end
end

class Rack::Test::Session
  extend ::Forwardable
end

class Rack::Test::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(content, content_type=T.unsafe(nil), binary=T.unsafe(nil), original_filename: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def tempfile(); end
end

class Rack::Test::UploadedFile
  def self.actually_finalize(file); end

  def self.finalize(file); end
end

module Rack::Test::Utils
  include ::Rack::Utils
end

module Rack::Test::Utils
  extend ::Rack::Utils
  def self.build_file_part(parameter_name, uploaded_file); end

  def self.build_multipart(params, first=T.unsafe(nil), multipart=T.unsafe(nil)); end

  def self.build_parts(parameters); end

  def self.build_primitive_part(parameter_name, value); end

  def self.get_parts(parameters); end
end

module Rack::Test
  def self.encoding_aware_strings?(); end
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

class Rack::Utils::Context
  def app(); end

  def call(env); end

  def context(env, app=T.unsafe(nil)); end

  def for(); end

  def initialize(app_f, app_r); end

  def recontext(app); end
end

class Rack::Utils::Context
end

class Rack::Utils::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def replace(other); end
end

class Rack::Utils::HeaderHash
  def self.[](headers); end
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

module Rack::Utils
  def self.add_cookie_to_header(header, key, value); end

  def self.add_remove_cookie_to_header(header, key, value=T.unsafe(nil)); end

  def self.best_q_match(q_value_header, available_mimes); end

  def self.build_nested_query(value, prefix=T.unsafe(nil)); end

  def self.build_query(params); end

  def self.byte_ranges(env, size); end

  def self.clean_path_info(path_info); end

  def self.clock_time(); end

  def self.default_query_parser(); end

  def self.default_query_parser=(default_query_parser); end

  def self.delete_cookie_header!(header, key, value=T.unsafe(nil)); end

  def self.escape(s); end

  def self.escape_html(string); end

  def self.escape_path(s); end

  def self.get_byte_ranges(http_range, size); end

  def self.key_space_limit(); end

  def self.key_space_limit=(v); end

  def self.make_delete_cookie_header(header, key, value); end

  def self.multipart_part_limit(); end

  def self.multipart_part_limit=(multipart_part_limit); end

  def self.param_depth_limit(); end

  def self.param_depth_limit=(v); end

  def self.parse_cookies(env); end

  def self.parse_cookies_header(header); end

  def self.parse_nested_query(qs, d=T.unsafe(nil)); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.q_values(q_value_header); end

  def self.rfc2109(time); end

  def self.rfc2822(time); end

  def self.secure_compare(a, b); end

  def self.select_best_encoding(available_encodings, accept_encoding); end

  def self.set_cookie_header!(header, key, value); end

  def self.status_code(status); end

  def self.unescape(s, encoding=T.unsafe(nil)); end

  def self.unescape_path(s); end

  def self.valid_path?(path); end
end

module Rack
  def self.release(); end

  def self.version(); end
end

class Rails::Application
  def asset_precompiled?(logical_path); end

  def assets(); end

  def assets=(assets); end

  def assets_manifest(); end

  def assets_manifest=(assets_manifest); end

  def build_middleware_stack(); end

  def config=(config); end

  def config_for(name, env: T.unsafe(nil)); end

  def console(&blk); end

  def credentials(); end

  def default_url_options(*args, &block); end

  def default_url_options=(arg); end

  def encrypted(path, key_path: T.unsafe(nil), env_key: T.unsafe(nil)); end

  def executor(); end

  def generators(&blk); end

  def initialize(initial_variable_values=T.unsafe(nil), &block); end

  def initialize!(group=T.unsafe(nil)); end

  def initialized?(); end

  def initializer(name, opts=T.unsafe(nil), &block); end

  def isolate_namespace(mod); end

  def key_generator(); end

  def message_verifier(verifier_name); end

  def migration_railties(); end

  def ordered_railties(); end

  def precompiled_assets(clear_cache=T.unsafe(nil)); end

  def railties_initializers(current); end

  def rake_tasks(&block); end

  def reload_routes!(); end

  def reloader(); end

  def reloaders(); end

  def require_environment!(); end

  def routes_reloader(); end

  def run_load_hooks!(); end

  def run_tasks_blocks(app); end

  def runner(&blk); end

  def sandbox(); end

  def sandbox=(sandbox); end

  def sandbox?(); end

  def secret_key_base(); end

  def secrets(); end

  def secrets=(secrets); end

  def to_app(); end

  def validate_secret_key_base(secret_key_base); end

  def watchable_args(); end
  INITIAL_VARIABLES = ::T.let(nil, ::T.untyped)
end

class Rails::Application
  def self.add_lib_to_load_path!(root); end

  def self.create(initial_variable_values=T.unsafe(nil), &block); end
end

class Rails::ApplicationController
end

class Rails::ApplicationController
end

module Rails::Autoloaders
end

module Rails::Autoloaders
  extend ::Enumerable
  def self.each(&blk); end

  def self.log!(); end

  def self.logger=(logger); end

  def self.main(); end

  def self.once(); end

  def self.zeitwerk_enabled?(); end
end

class Rails::BacktraceCleaner
  APP_DIRS_PATTERN = ::T.let(nil, ::T.untyped)
  DOT_SLASH = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  RENDER_TEMPLATE_PATTERN = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

class Rails::BacktraceCleaner
end

module Rails::Command
  include ::Rails::Command::Behavior
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
end

module Rails::Command::Actions
  def load_generators(); end

  def load_tasks(); end

  def require_application!(); end

  def require_application_and_environment!(); end

  def require_environment!(); end

  def set_application_directory!(); end
end

module Rails::Command::Actions
end

class Rails::Command::Base
  include ::Rails::Command::Actions
  def help(); end
end

class Rails::Command::Base::Error
end

class Rails::Command::Base::Error
end

class Rails::Command::Base
  def self.banner(*_); end

  def self.base_name(); end

  def self.command_name(); end

  def self.default_command_root(); end

  def self.desc(usage=T.unsafe(nil), description=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.engine?(); end

  def self.executable(); end

  def self.hide_command!(); end

  def self.inherited(base); end

  def self.perform(command, args, config); end

  def self.printing_commands(); end

  def self.usage_path(); end
end

module Rails::Command::Behavior
end

module Rails::Command::Behavior::ClassMethods
  def no_color!(); end

  def subclasses(); end
end

module Rails::Command::Behavior::ClassMethods
end

module Rails::Command::Behavior
  extend ::ActiveSupport::Concern
end

module Rails::Command::Spellchecker
end

module Rails::Command::Spellchecker
  def self.suggest(word, from:); end
end

module Rails::Command
  extend ::ActiveSupport::Autoload
  extend ::Rails::Command::Behavior::ClassMethods
  def self.environment(); end

  def self.find_by_namespace(namespace, command_name=T.unsafe(nil)); end

  def self.hidden_commands(); end

  def self.invoke(full_namespace, args=T.unsafe(nil), **config); end

  def self.print_commands(); end

  def self.root(); end
end

module Rails::Configuration
end

class Rails::Configuration::Generators
  def aliases(); end

  def aliases=(aliases); end

  def api_only(); end

  def api_only=(api_only); end

  def colorize_logging(); end

  def colorize_logging=(colorize_logging); end

  def fallbacks(); end

  def fallbacks=(fallbacks); end

  def hidden_namespaces(); end

  def hide_namespace(namespace); end

  def method_missing(method, *args); end

  def options(); end

  def options=(options); end

  def templates(); end

  def templates=(templates); end
end

class Rails::Configuration::Generators
end

class Rails::Configuration::MiddlewareStackProxy
  def +(other); end

  def delete(*args, &block); end

  def delete_operations(); end

  def initialize(operations=T.unsafe(nil), delete_operations=T.unsafe(nil)); end

  def insert(*args, &block); end

  def insert_after(*args, &block); end

  def insert_before(*args, &block); end

  def merge_into(other); end

  def operations(); end

  def swap(*args, &block); end

  def unshift(*args, &block); end

  def use(*args, &block); end
end

class Rails::Configuration::MiddlewareStackProxy
end

module Rails::Configuration
end

module Rails::Controller
end

module Rails::Controller::Testing
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rails::Controller::Testing::Integration
  def delete(*args); end

  def get(*args); end

  def get_via_redirect(*args); end

  def head(*args); end

  def patch(*args); end

  def post(*args); end

  def post_via_redirect(*args); end

  def put(*args); end
end

module Rails::Controller::Testing::Integration
end

class Rails::Controller::Testing::Railtie
end

class Rails::Controller::Testing::Railtie
end

module Rails::Controller::Testing::TemplateAssertions
  def assert_template(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def process(*args); end

  def reset_template_assertion(); end

  def setup_subscriptions(); end

  def teardown_subscriptions(); end
  RENDER_TEMPLATE_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module Rails::Controller::Testing::TemplateAssertions
  extend ::ActiveSupport::Concern
end

module Rails::Controller::Testing::TestProcess
  def assigns(key=T.unsafe(nil)); end
end

module Rails::Controller::Testing::TestProcess
end

module Rails::Controller::Testing
  def self.install(); end
end

module Rails::Controller
end

module Rails::Dom
end

module Rails::Dom::Testing
end

module Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message=T.unsafe(nil)); end

  def assert_dom_not_equal(expected, actual, message=T.unsafe(nil)); end

  def compare_doms(expected, actual); end

  def equal_attribute?(attr, other_attr); end

  def equal_attribute_nodes?(nodes, other_nodes); end

  def equal_children?(child, other_child); end
end

module Rails::Dom::Testing::Assertions::DomAssertions
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  def assert_select(*args, &block); end

  def assert_select_email(&block); end

  def assert_select_encoded(element=T.unsafe(nil), &block); end

  def css_select(*args); end
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  extend ::ActiveSupport::Concern
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
end

module Rails::Dom::Testing::Assertions
  extend ::ActiveSupport::Concern
end

module Rails::Dom::Testing
end

module Rails::Dom
end

class Rails::Engine
  def app(); end

  def call(env); end

  def eager_load!(); end

  def endpoint(); end

  def engine_name(*args, &block); end

  def env_config(); end

  def helpers(); end

  def helpers_paths(); end

  def isolated?(*args, &block); end

  def load_console(app=T.unsafe(nil)); end

  def load_generators(app=T.unsafe(nil)); end

  def load_runner(app=T.unsafe(nil)); end

  def load_seed(); end

  def load_tasks(app=T.unsafe(nil)); end

  def middleware(*args, &block); end

  def paths(*args, &block); end

  def railties(); end

  def root(*args, &block); end

  def routes(&block); end

  def routes?(); end

  def run_tasks_blocks(*_); end
end

class Rails::Engine
  def self.called_from(); end

  def self.called_from=(called_from); end

  def self.eager_load!(*args, &block); end

  def self.endpoint(endpoint=T.unsafe(nil)); end

  def self.engine_name(name=T.unsafe(nil)); end

  def self.find(path); end

  def self.find_root(from); end

  def self.find_root_with_flag(flag, root_path, default=T.unsafe(nil)); end

  def self.isolate_namespace(mod); end

  def self.isolated(); end

  def self.isolated=(isolated); end

  def self.isolated?(); end
end

module Rails::Generators
  include ::Rails::Command::Behavior
  def namespace(); end

  def namespace=(obj); end
  DEFAULT_ALIASES = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Actions
  def add_source(source, options=T.unsafe(nil), &block); end

  def application(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def environment(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def gem(*args); end

  def gem_group(*names, &block); end

  def generate(what, *args); end

  def git(commands=T.unsafe(nil)); end

  def github(repo, options=T.unsafe(nil), &block); end

  def initialize(*_); end

  def initializer(filename, data=T.unsafe(nil)); end

  def lib(filename, data=T.unsafe(nil)); end

  def rails_command(command, options=T.unsafe(nil)); end

  def rake(command, options=T.unsafe(nil)); end

  def rakefile(filename, data=T.unsafe(nil)); end

  def readme(path); end

  def route(routing_code); end

  def vendor(filename, data=T.unsafe(nil)); end
end

module Rails::Generators::Actions
end

class Rails::Generators::ActiveModel
  def destroy(); end

  def errors(); end

  def initialize(name); end

  def name(); end

  def save(); end

  def update(params=T.unsafe(nil)); end
end

class Rails::Generators::ActiveModel
  def self.all(klass); end

  def self.build(klass, params=T.unsafe(nil)); end

  def self.find(klass, params=T.unsafe(nil)); end
end

module Rails::Generators::AppName
  RESERVED_NAMES = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::AppName
end

class Rails::Generators::Base
  include ::Thor::Actions
  include ::Rails::Generators::Actions
end

class Rails::Generators::Base
  def self.add_shebang_option!(); end

  def self.base_name(); end

  def self.base_root(); end

  def self.default_aliases_for_option(name, options); end

  def self.default_for_option(config, name, options, default); end

  def self.default_generator_root(); end

  def self.default_source_root(); end

  def self.default_value_for_option(name, options); end

  def self.generator_name(); end

  def self.hide!(); end

  def self.hook_for(*names, &block); end

  def self.hooks(); end

  def self.inherited(base); end

  def self.prepare_for_invocation(name, value); end

  def self.remove_hook_for(*names); end

  def self.usage_path(); end
end

module Rails::Generators::Database
  def convert_database_option_for_jruby(); end

  def gem_for_database(database=T.unsafe(nil)); end

  def initialize(*_); end
  DATABASES = ::T.let(nil, ::T.untyped)
  JDBC_DATABASES = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Database
end

class Rails::Generators::Error
end

class Rails::Generators::Error
end

class Rails::Generators::GeneratedAttribute
  def attachment?(); end

  def attachments?(); end

  def attr_options(); end

  def column_name(); end

  def default(); end

  def field_type(); end

  def foreign_key?(); end

  def has_index?(); end

  def has_uniq_index?(); end

  def human_name(); end

  def index_name(); end

  def index_name=(index_name); end

  def initialize(name, type=T.unsafe(nil), index_type=T.unsafe(nil), attr_options=T.unsafe(nil)); end

  def inject_index_options(); end

  def inject_options(); end

  def name(); end

  def name=(name); end

  def options_for_migration(); end

  def password_digest?(); end

  def plural_name(); end

  def polymorphic?(); end

  def reference?(); end

  def required?(); end

  def rich_text?(); end

  def singular_name(); end

  def token?(); end

  def type(); end

  def type=(type); end

  def virtual?(); end
  INDEX_OPTIONS = ::T.let(nil, ::T.untyped)
  UNIQ_INDEX_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rails::Generators::GeneratedAttribute
  def self.parse(column_definition); end

  def self.reference?(type); end
end

module Rails::Generators::Migration
  def create_migration(destination, data, config=T.unsafe(nil), &block); end

  def migration_class_name(); end

  def migration_file_name(); end

  def migration_number(); end

  def migration_template(source, destination, config=T.unsafe(nil)); end

  def set_migration_assigns!(destination); end
end

module Rails::Generators::Migration
  extend ::ActiveSupport::Concern
end

class Rails::Generators::NamedBase
  def file_name(); end

  def initialize(args, *options); end

  def js_template(source, destination); end

  def name(); end

  def name=(name); end
end

class Rails::Generators::NamedBase
  def self.check_class_collision(options=T.unsafe(nil)); end
end

module Rails::Generators::ResourceHelpers
  def initialize(*args); end
end

module Rails::Generators::ResourceHelpers
  def self.included(base); end
end

class Rails::Generators::TestCase
  include ::Rails::Generators::Testing::Behaviour
  include ::ActiveSupport::Testing::Stream
  include ::Rails::Generators::Testing::SetupAndTeardown
  include ::Rails::Generators::Testing::Assertions
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def current_path(); end

  def current_path=(val); end

  def current_path?(); end

  def default_arguments(); end

  def default_arguments=(val); end

  def default_arguments?(); end

  def destination_root(); end

  def destination_root=(val); end

  def destination_root?(); end

  def generator_class(); end

  def generator_class=(val); end

  def generator_class?(); end
end

class Rails::Generators::TestCase
  def self.current_path(); end

  def self.current_path=(val); end

  def self.current_path?(); end

  def self.default_arguments(); end

  def self.default_arguments=(val); end

  def self.default_arguments?(); end

  def self.destination_root(); end

  def self.destination_root=(val); end

  def self.destination_root?(); end

  def self.generator_class(); end

  def self.generator_class=(val); end

  def self.generator_class?(); end
end

module Rails::Generators::Testing
end

module Rails::Generators::Testing::Assertions
  def assert_class_method(method, content, &block); end

  def assert_directory(relative, *contents); end

  def assert_field_default_value(attribute_type, value); end

  def assert_field_type(attribute_type, field_type); end

  def assert_file(relative, *contents); end

  def assert_instance_method(method, content); end

  def assert_method(method, content); end

  def assert_migration(relative, *contents, &block); end

  def assert_no_directory(relative); end

  def assert_no_file(relative); end

  def assert_no_migration(relative); end
end

module Rails::Generators::Testing::Assertions
end

module Rails::Generators::Testing::Behaviour
  include ::ActiveSupport::Testing::Stream
  def create_generated_attribute(attribute_type, name=T.unsafe(nil), index=T.unsafe(nil)); end

  def generator(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def run_generator(args=T.unsafe(nil), config=T.unsafe(nil)); end
end

module Rails::Generators::Testing::Behaviour
  extend ::ActiveSupport::Concern
end

module Rails::Generators::Testing::SetupAndTeardown
  def setup(); end

  def teardown(); end
end

module Rails::Generators::Testing::SetupAndTeardown
end

module Rails::Generators::Testing
end

module Rails::Generators
  extend ::Rails::Command::Behavior::ClassMethods
  def self.aliases(); end

  def self.api_only!(); end

  def self.configure!(config); end

  def self.fallbacks(); end

  def self.find_by_namespace(name, base=T.unsafe(nil), context=T.unsafe(nil)); end

  def self.help(command=T.unsafe(nil)); end

  def self.hidden_namespaces(); end

  def self.hide_namespace(*namespaces); end

  def self.hide_namespaces(*namespaces); end

  def self.invoke(namespace, args=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.namespace(); end

  def self.namespace=(obj); end

  def self.options(); end

  def self.print_generators(); end

  def self.public_namespaces(); end

  def self.sorted_groups(); end

  def self.templates_path(); end
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::FullSanitizer
end

class Rails::Html::FullSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::PermitScrubber
  def allowed_node?(node); end

  def attributes(); end

  def attributes=(attributes); end

  def initialize(); end

  def keep_node?(node); end

  def scrub_attribute(node, attr_node); end

  def scrub_attribute?(name); end

  def scrub_attributes(node); end

  def scrub_css_attribute(node); end

  def scrub_node(node); end

  def skip_node?(node); end

  def tags(); end

  def tags=(tags); end

  def validate!(var, name); end
end

class Rails::Html::PermitScrubber
end

class Rails::Html::SafeListSanitizer
  def sanitize_css(style_string); end
end

class Rails::Html::SafeListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(allowed_attributes); end

  def self.allowed_tags(); end

  def self.allowed_tags=(allowed_tags); end
end

class Rails::Html::Sanitizer
  def sanitize(html, options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  def self.full_sanitizer(); end

  def self.link_sanitizer(); end

  def self.safe_list_sanitizer(); end

  def self.white_list_sanitizer(); end
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TextOnlyScrubber
  def initialize(); end
end

class Rails::Html::TextOnlyScrubber
end

Rails::Html::WhiteListSanitizer = Rails::Html::SafeListSanitizer

module Rails::Html
end

module Rails::Info
  def properties(); end

  def properties=(obj); end
end

module Rails::Info
  def self.properties(); end

  def self.properties=(obj); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def _layout_from_proc(); end

  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

module Rails::Initializable
  def initializers(); end

  def run_initializers(group=T.unsafe(nil), *args); end
end

module Rails::Initializable
  def self.included(base); end
end

module Rails::LineFiltering
  def run(reporter, options=T.unsafe(nil)); end
end

module Rails::LineFiltering
end

class Rails::MailersController
  def index(); end

  def preview(); end
end

class Rails::MailersController
end

module Rails::Paths
end

class Rails::Paths::Path
  include ::Enumerable
  def <<(path); end

  def absolute_current(); end

  def autoload!(); end

  def autoload?(); end

  def autoload_once!(); end

  def autoload_once?(); end

  def children(); end

  def concat(paths); end

  def each(&block); end

  def eager_load!(); end

  def eager_load?(); end

  def existent(); end

  def existent_directories(); end

  def expanded(); end

  def extensions(); end

  def first(); end

  def glob(); end

  def glob=(glob); end

  def initialize(root, current, paths, options=T.unsafe(nil)); end

  def last(); end

  def load_path!(); end

  def load_path?(); end

  def push(path); end

  def skip_autoload!(); end

  def skip_autoload_once!(); end

  def skip_eager_load!(); end

  def skip_load_path!(); end

  def to_a(); end

  def to_ary(); end

  def unshift(*paths); end
end

class Rails::Paths::Path
end

class Rails::Paths::Root
  def [](path); end

  def []=(path, value); end

  def add(path, options=T.unsafe(nil)); end

  def all_paths(); end

  def autoload_once(); end

  def autoload_paths(); end

  def eager_load(); end

  def initialize(path); end

  def keys(); end

  def load_paths(); end

  def path(); end

  def path=(path); end

  def values(); end

  def values_at(*list); end
end

class Rails::Paths::Root
end

module Rails::Paths
end

module Rails::Rack
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

class Rails::Rack::Logger
end

module Rails::Rack
end

class Rails::Railtie
  include ::Rails::Initializable
  def config(); end

  def configure(&block); end

  def railtie_name(*args, &block); end

  def railtie_namespace(); end

  def run_console_blocks(app); end

  def run_generators_blocks(app); end

  def run_runner_blocks(app); end

  def run_tasks_blocks(app); end
  ABSTRACT_RAILTIES = ::T.let(nil, ::T.untyped)
end

class Rails::Railtie
  def self.abstract_railtie?(); end

  def self.config(*args, &block); end

  def self.configure(&block); end

  def self.console(&blk); end

  def self.generators(&blk); end

  def self.inherited(base); end

  def self.instance(); end

  def self.railtie_name(name=T.unsafe(nil)); end

  def self.rake_tasks(&blk); end

  def self.runner(&blk); end
end

class Rails::Secrets
end

class Rails::Secrets::MissingKeyError
  def initialize(); end
end

class Rails::Secrets::MissingKeyError
end

class Rails::Secrets
  def self.decrypt(data); end

  def self.encrypt(data); end

  def self.key(); end

  def self.parse(paths, env:); end

  def self.read(); end

  def self.read_for_editing(&block); end

  def self.root=(root); end

  def self.write(contents); end
end

class Rails::SourceAnnotationExtractor
  def display(results, options=T.unsafe(nil)); end

  def extract_annotations_from(file, pattern); end

  def find(dirs); end

  def find_in(dir); end

  def initialize(tag); end

  def tag(); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def to_s(options=T.unsafe(nil)); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def self.directories(); end

  def self.extensions(); end

  def self.notes_task_deprecation_warning(); end

  def self.register_directories(*dirs); end

  def self.register_extensions(*exts, &block); end

  def self.register_tags(*additional_tags); end

  def self.tags(); end
end

class Rails::SourceAnnotationExtractor
  def self.enumerate(tag=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Rails::TestUnit
end

class Rails::TestUnit::CompositeFilter
  def ===(method); end

  def initialize(runnable, filter, patterns); end

  def named_filter(); end
end

class Rails::TestUnit::CompositeFilter
end

class Rails::TestUnit::Filter
  def ===(method); end

  def initialize(runnable, file, line); end
end

class Rails::TestUnit::Filter
end

class Rails::TestUnit::Runner
  def filters(); end
end

class Rails::TestUnit::Runner
  def self.attach_before_load_options(opts); end

  def self.compose_filter(runnable, filter); end

  def self.filters(); end

  def self.load_tests(argv); end

  def self.parse_options(argv); end

  def self.rake_run(argv=T.unsafe(nil)); end

  def self.run(argv=T.unsafe(nil)); end
end

module Rails::TestUnit
end

class Rails::TestUnitRailtie
end

class Rails::TestUnitRailtie
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Rails::VERSION
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

module Rails
  extend ::ActiveSupport::Autoload
  def self.app_class(); end

  def self.app_class=(app_class); end

  def self.application=(application); end

  def self.autoloaders(); end

  def self.backtrace_cleaner(); end

  def self.cache(); end

  def self.cache=(cache); end

  def self.configuration(); end

  def self.env(); end

  def self.env=(environment); end

  def self.gem_version(); end

  def self.groups(*groups); end

  def self.initialize!(*args, &block); end

  def self.initialized?(*args, &block); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.public_path(); end

  def self.version(); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  def self.collapse(backtrace); end
end

module Rake::Cloneable
end

module Rake::Cloneable
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  include ::Rake::Cloneable
  def &(*args, &block); end

  def *(other); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(obj); end

  def ==(array); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def add(*filenames); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def clear_exclude(); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def egrep(pattern, *options); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude(*patterns, &block); end

  def exclude?(*args, &block); end

  def excluded_from_list?(fn); end

  def excluding(*args, &block); end

  def existing(); end

  def existing!(); end

  def ext(newext=T.unsafe(nil)); end

  def extract!(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def gsub(pat, rep); end

  def gsub!(pat, rep); end

  def import(array); end

  def include(*filenames); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def initialize(*patterns); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def is_a?(klass); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def kind_of?(klass); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(&block); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def permutation(*args, &block); end

  def pluck(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resolve(); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sub(pat, rep); end

  def sub!(pat, rep); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_a(); end

  def to_ary(); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileList
  def self.[](*args); end

  def self.glob(pattern, *args); end
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, **options, &block); end

  def chdir(*args, **options, &block); end

  def chmod(*args, **options, &block); end

  def chmod_R(*args, **options, &block); end

  def chown(*args, **options, &block); end

  def chown_R(*args, **options, &block); end

  def copy(*args, **options, &block); end

  def cp(*args, **options, &block); end

  def cp_lr(*args, **options, &block); end

  def cp_r(*args, **options, &block); end

  def install(*args, **options, &block); end

  def link(*args, **options, &block); end

  def ln(*args, **options, &block); end

  def ln_s(*args, **options, &block); end

  def ln_sf(*args, **options, &block); end

  def makedirs(*args, **options, &block); end

  def mkdir(*args, **options, &block); end

  def mkdir_p(*args, **options, &block); end

  def mkpath(*args, **options, &block); end

  def move(*args, **options, &block); end

  def mv(*args, **options, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_output_message(message); end

  def remove(*args, **options, &block); end

  def rm(*args, **options, &block); end

  def rm_f(*args, **options, &block); end

  def rm_r(*args, **options, &block); end

  def rm_rf(*args, **options, &block); end

  def rmdir(*args, **options, &block); end

  def rmtree(*args, **options, &block); end

  def safe_unlink(*args, **options, &block); end

  def symlink(*args, **options, &block); end

  def touch(*args, **options, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
end

module Rake::PrivateReader
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def order_only_prerequisites(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end

  def |(deps); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.format_deps(deps); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.each_dir_parent(dir); end

  def self.from_pathname(path); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

RakeFileUtils = Rake::FileUtilsExt

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::IncludeTimeWithZone
  include ::ActiveSupport::EachTimeWithZone
  def %(_); end

  def entries(); end

  def overlaps?(other); end

  def sum(identity=T.unsafe(nil)); end

  def to_a(); end
end

class Rational
  def to_d(precision); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module RbReadline
  def history_base=(history_base); end

  def history_length=(history_length); end

  def rl_point=(rl_point); end
  ABORT_CHAR = ::T.let(nil, ::T.untyped)
  ANCHORED_SEARCH = ::T.let(nil, ::T.untyped)
  ANYOTHERKEY = ::T.let(nil, ::T.untyped)
  AUDIBLE_BELL = ::T.let(nil, ::T.untyped)
  BAD_MODIFIER = ::T.let(nil, ::T.untyped)
  BAD_WORD_SPEC = ::T.let(nil, ::T.untyped)
  BFIND = ::T.let(nil, ::T.untyped)
  BTO = ::T.let(nil, ::T.untyped)
  CapCase = ::T.let(nil, ::T.untyped)
  DEFAULT_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_INPUTRC = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_KILLS = ::T.let(nil, ::T.untyped)
  DownCase = ::T.let(nil, ::T.untyped)
  EOF = ::T.let(nil, ::T.untyped)
  ESC = ::T.let(nil, ::T.untyped)
  EVENT_NOT_FOUND = ::T.let(nil, ::T.untyped)
  FFIND = ::T.let(nil, ::T.untyped)
  FTO = ::T.let(nil, ::T.untyped)
  HISTORY_APPEND = ::T.let(nil, ::T.untyped)
  HISTORY_OVERWRITE = ::T.let(nil, ::T.untyped)
  HISTORY_QUOTE_CHARACTERS = ::T.let(nil, ::T.untyped)
  HISTORY_WORD_DELIMITERS = ::T.let(nil, ::T.untyped)
  ISFUNC = ::T.let(nil, ::T.untyped)
  ISKMAP = ::T.let(nil, ::T.untyped)
  ISMACR = ::T.let(nil, ::T.untyped)
  KEYMAP_SIZE = ::T.let(nil, ::T.untyped)
  KSEQ_DISPATCHED = ::T.let(nil, ::T.untyped)
  KSEQ_RECURSIVE = ::T.let(nil, ::T.untyped)
  KSEQ_SUBSEQ = ::T.let(nil, ::T.untyped)
  MB_FIND_ANY = ::T.let(nil, ::T.untyped)
  MB_FIND_NONZERO = ::T.let(nil, ::T.untyped)
  MB_LEN_MAX = ::T.let(nil, ::T.untyped)
  MULT_MATCH = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  NON_ANCHORED_SEARCH = ::T.let(nil, ::T.untyped)
  NO_BELL = ::T.let(nil, ::T.untyped)
  NO_MATCH = ::T.let(nil, ::T.untyped)
  NO_PREV_SUBST = ::T.let(nil, ::T.untyped)
  NUM_READONE = ::T.let(nil, ::T.untyped)
  NUM_SAWDIGITS = ::T.let(nil, ::T.untyped)
  NUM_SAWMINUS = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  RB_READLINE_VERSION = ::T.let(nil, ::T.untyped)
  READERR = ::T.let(nil, ::T.untyped)
  RETURN = ::T.let(nil, ::T.untyped)
  RL_IM_DEFAULT = ::T.let(nil, ::T.untyped)
  RL_IM_INSERT = ::T.let(nil, ::T.untyped)
  RL_IM_OVERWRITE = ::T.let(nil, ::T.untyped)
  RL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  RL_PROMPT_END_IGNORE = ::T.let(nil, ::T.untyped)
  RL_PROMPT_START_IGNORE = ::T.let(nil, ::T.untyped)
  RL_QF_BACKSLASH = ::T.let(nil, ::T.untyped)
  RL_QF_DOUBLE_QUOTE = ::T.let(nil, ::T.untyped)
  RL_QF_OTHER_QUOTE = ::T.let(nil, ::T.untyped)
  RL_QF_SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  RL_READLINE_VERSION = ::T.let(nil, ::T.untyped)
  RL_SEARCH_CSEARCH = ::T.let(nil, ::T.untyped)
  RL_SEARCH_ISEARCH = ::T.let(nil, ::T.untyped)
  RL_SEARCH_NSEARCH = ::T.let(nil, ::T.untyped)
  RL_STATE_CALLBACK = ::T.let(nil, ::T.untyped)
  RL_STATE_COMPLETING = ::T.let(nil, ::T.untyped)
  RL_STATE_DISPATCHING = ::T.let(nil, ::T.untyped)
  RL_STATE_DONE = ::T.let(nil, ::T.untyped)
  RL_STATE_INITIALIZED = ::T.let(nil, ::T.untyped)
  RL_STATE_INITIALIZING = ::T.let(nil, ::T.untyped)
  RL_STATE_INPUTPENDING = ::T.let(nil, ::T.untyped)
  RL_STATE_ISEARCH = ::T.let(nil, ::T.untyped)
  RL_STATE_MACRODEF = ::T.let(nil, ::T.untyped)
  RL_STATE_MACROINPUT = ::T.let(nil, ::T.untyped)
  RL_STATE_METANEXT = ::T.let(nil, ::T.untyped)
  RL_STATE_MOREINPUT = ::T.let(nil, ::T.untyped)
  RL_STATE_MULTIKEY = ::T.let(nil, ::T.untyped)
  RL_STATE_NONE = ::T.let(nil, ::T.untyped)
  RL_STATE_NSEARCH = ::T.let(nil, ::T.untyped)
  RL_STATE_NUMERICARG = ::T.let(nil, ::T.untyped)
  RL_STATE_OVERWRITE = ::T.let(nil, ::T.untyped)
  RL_STATE_READCMD = ::T.let(nil, ::T.untyped)
  RL_STATE_SEARCH = ::T.let(nil, ::T.untyped)
  RL_STATE_SIGHANDLER = ::T.let(nil, ::T.untyped)
  RL_STATE_TERMPREPPED = ::T.let(nil, ::T.untyped)
  RL_STATE_TTYCSAVED = ::T.let(nil, ::T.untyped)
  RL_STATE_UNDOING = ::T.let(nil, ::T.untyped)
  RL_STATE_VICMDONCE = ::T.let(nil, ::T.untyped)
  RL_STATE_VIMOTION = ::T.let(nil, ::T.untyped)
  RUBOUT = ::T.let(nil, ::T.untyped)
  SF_FAILED = ::T.let(nil, ::T.untyped)
  SF_FOUND = ::T.let(nil, ::T.untyped)
  SF_REVERSE = ::T.let(nil, ::T.untyped)
  SINGLE_MATCH = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  SUBST_FAILED = ::T.let(nil, ::T.untyped)
  SYS_INPUTRC = ::T.let(nil, ::T.untyped)
  TAB = ::T.let(nil, ::T.untyped)
  UNDO_BEGIN = ::T.let(nil, ::T.untyped)
  UNDO_DELETE = ::T.let(nil, ::T.untyped)
  UNDO_END = ::T.let(nil, ::T.untyped)
  UNDO_INSERT = ::T.let(nil, ::T.untyped)
  UpCase = ::T.let(nil, ::T.untyped)
  VISIBLE_BELL = ::T.let(nil, ::T.untyped)
  XOK = ::T.let(nil, ::T.untyped)
end

module RbReadline
  def self.__rl_fix_point(x); end

  def self._extract_last_quote(string, quote_char); end

  def self._rl_abort_internal(); end

  def self._rl_adjust_point(string, point); end

  def self._rl_any_typein(); end

  def self._rl_arg_dispatch(cxt, c); end

  def self._rl_arg_getchar(); end

  def self._rl_arg_init(); end

  def self._rl_arg_overflow(); end

  def self._rl_backspace(count); end

  def self._rl_bind_tty_special_chars(kmap); end

  def self._rl_char_search(count, fdir, bdir); end

  def self._rl_char_search_internal(count, dir, smbchar, len); end

  def self._rl_char_value(buf, ind); end

  def self._rl_clean_up_for_exit(); end

  def self._rl_clear_screen(); end

  def self._rl_clear_to_eol(count); end

  def self._rl_col_width(string, start, _end); end

  def self._rl_compare_chars(buf1, pos1, buf2, pos2); end

  def self._rl_control_keypad(on); end

  def self._rl_copy_to_kill_ring(text, append); end

  def self._rl_current_display_line(); end

  def self._rl_dispatch(key, map); end

  def self._rl_dispatch_subseq(key, map, got_subseq); end

  def self._rl_enable_meta_key(); end

  def self._rl_erase_at_end_of_line(l); end

  def self._rl_erase_entire_line(); end

  def self._rl_find_completion_word(); end

  def self._rl_find_next_mbchar(string, seed, count, flags); end

  def self._rl_find_prev_mbchar(string, seed, flags); end

  def self._rl_fix_point(fix_mark_too); end

  def self._rl_get_char_len(src); end

  def self._rl_get_screen_size(tty, ignore_env); end

  def self._rl_history_set_point(); end

  def self._rl_init_eightbit(); end

  def self._rl_init_line_state(); end

  def self._rl_init_terminal_io(terminal_name); end

  def self._rl_input_available(); end

  def self._rl_insert_char(count, c); end

  def self._rl_insert_next(count); end

  def self._rl_insert_typein(c); end

  def self._rl_internal_char_cleanup(); end

  def self._rl_internal_pager(lines); end

  def self._rl_is_mbchar_matched(string, seed, _end, mbchar, length); end

  def self._rl_isearch_cleanup(cxt, r); end

  def self._rl_isearch_dispatch(cxt, c); end

  def self._rl_isearch_fini(cxt); end

  def self._rl_isearch_init(direction); end

  def self._rl_make_prompt_for_search(pchar); end

  def self._rl_move_cursor_relative(new, data, start=T.unsafe(nil)); end

  def self._rl_move_vert(to); end

  def self._rl_nsearch_abort(cxt); end

  def self._rl_nsearch_cleanup(cxt, r); end

  def self._rl_nsearch_dispatch(cxt, c); end

  def self._rl_nsearch_dosearch(cxt); end

  def self._rl_nsearch_init(dir, pchar); end

  def self._rl_output_some_chars(string, start, count); end

  def self._rl_overwrite_char(count, c); end

  def self._rl_overwrite_rubout(count, key); end

  def self._rl_read_init_file(filename, include_level); end

  def self._rl_read_mbchar(mbchar, size); end

  def self._rl_read_mbstring(first, mb, mlen); end

  def self._rl_redisplay_after_sigwinch(); end

  def self._rl_replace_text(text, start, _end); end

  def self._rl_reset_argument(); end

  def self._rl_rubout_char(count, key); end

  def self._rl_scxt_alloc(type, flags); end

  def self._rl_search_getchar(cxt); end

  def self._rl_set_insert_mode(im, force); end

  def self._rl_set_mark_at_pos(position); end

  def self._rl_start_using_history(); end

  def self._rl_strip_prompt(pmt); end

  def self._rl_subseq_getchar(key); end

  def self._rl_to_lower(char); end

  def self._rl_unget_char(key); end

  def self._rl_update_final(); end

  def self._rl_vi_done_inserting(); end

  def self._rl_vi_initialize_line(); end

  def self._rl_vi_reset_last(); end

  def self._rl_vi_save_insert(up); end

  def self._rl_vi_textmod_command(c); end

  def self._rl_walphabetic(c); end

  def self.add_history(string); end

  def self.alloc_history_entry(string, ts); end

  def self.alloc_undo_entry(what, start, _end, text); end

  def self.append_to_match(text, delimiter, quote_char, nontrivial_match); end

  def self.bind_arrow_keys(); end

  def self.bind_arrow_keys_internal(map); end

  def self.bind_termcap_arrow_keys(map); end

  def self.block_sigint(); end

  def self.clear_history(); end

  def self.compute_lcd_of_matches(match_list, matches, text); end

  def self.cr(); end

  def self.cr_faster(new, cur); end

  def self.ctrl_char(c); end

  def self.current_history(); end

  def self.delete_chars(count); end

  def self.display_matches(matches); end

  def self.endsrch_char(c); end

  def self.expand_prompt(pmt); end

  def self.fnprint(to_print); end

  def self.fnwidth(string); end

  def self.gen_completion_matches(text, start, _end, our_func, found_quote, quote_char); end

  def self.get_term_capabilities(buffer); end

  def self.get_y_or_n(for_pager); end

  def self.handle_parser_directive(statement); end

  def self.hist_inittime(); end

  def self.history_arg_extract(first, last, string); end

  def self.history_base(); end

  def self.history_get(offset); end

  def self.history_is_stifled(); end

  def self.history_length(); end

  def self.history_list(); end

  def self.history_search_pos(string, dir, pos); end

  def self.history_search_prefix(string, direction); end

  def self.history_set_pos(pos); end

  def self.ibuffer_space(); end

  def self.init_line_structures(minsize); end

  def self.insert_all_matches(matches, point, qc); end

  def self.insert_match(match, start, mtype, qc); end

  def self.insert_some_chars(string, count, col); end

  def self.inv_line(line); end

  def self.inv_llen(l); end

  def self.isascii(c); end

  def self.isprint(c); end

  def self.m_offset(margin, offset); end

  def self.make_history_line_current(entry); end

  def self.make_quoted_replacement(match, mtype, qc); end

  def self.meta_char(c); end

  def self.next_history(); end

  def self.no_terminal?(); end

  def self.noninc_dosearch(string, dir); end

  def self.noninc_search(dir, pchar); end

  def self.noninc_search_from_pos(string, pos, dir); end

  def self.parser_else(args); end

  def self.parser_endif(args); end

  def self.parser_if(args); end

  def self.parser_include(args); end

  def self.path_isdir(filename); end

  def self.postprocess_matches(matchesp, matching_filenames); end

  def self.prepare_terminal_settings(meta_flag); end

  def self.previous_history(); end

  def self.print_filename(to_print, full_pathname); end

  def self.printable_part(pathname); end

  def self.prompt_ending_index(); end

  def self.readline(prompt); end

  def self.readline_default_bindings(); end

  def self.readline_initialize_everything(); end

  def self.readline_internal(); end

  def self.readline_internal_charloop(); end

  def self.readline_internal_setup(); end

  def self.readline_internal_teardown(eof); end

  def self.redraw_prompt(t); end

  def self.release_sigint(); end

  def self.remove_duplicate_matches(matches); end

  def self.remove_history(which); end

  def self.replace_history_data(which, old, new); end

  def self.replace_history_entry(which, line, data); end

  def self.retry_if_interrupted(&block); end

  def self.rl_abort(count, key); end

  def self.rl_add_undo(what, start, _end, text); end

  def self.rl_alphabetic(c); end

  def self.rl_arrow_keys(count, c); end

  def self.rl_attempted_completion_function(); end

  def self.rl_attempted_completion_function=(rl_attempted_completion_function); end

  def self.rl_attempted_completion_over(); end

  def self.rl_attempted_completion_over=(rl_attempted_completion_over); end

  def self.rl_backward(count, key); end

  def self.rl_backward_byte(count, key); end

  def self.rl_backward_char(count, key); end

  def self.rl_backward_char_search(count, key); end

  def self.rl_backward_kill_line(direction, ignore); end

  def self.rl_backward_kill_word(count, ignore); end

  def self.rl_backward_word(count, key); end

  def self.rl_basic_quote_characters(); end

  def self.rl_basic_quote_characters=(rl_basic_quote_characters); end

  def self.rl_basic_word_break_characters(); end

  def self.rl_basic_word_break_characters=(rl_basic_word_break_characters); end

  def self.rl_beg_of_line(count, key); end

  def self.rl_begin_undo_group(); end

  def self.rl_beginning_of_history(count, key); end

  def self.rl_bind_key(key, function); end

  def self.rl_bind_keyseq_if_unbound(keyseq, default_func); end

  def self.rl_bind_keyseq_if_unbound_in_map(keyseq, default_func, kmap); end

  def self.rl_bind_keyseq_in_map(keyseq, function, map); end

  def self.rl_capitalize_word(count, key); end

  def self.rl_change_case(count, op); end

  def self.rl_char_search(count, key); end

  def self.rl_character_len(c, pos); end

  def self.rl_cleanup_after_signal(); end

  def self.rl_clear_message(); end

  def self.rl_clear_pending_input(); end

  def self.rl_clear_screen(count, key); end

  def self.rl_clear_signals(); end

  def self.rl_complete(ignore, invoking_key); end

  def self.rl_complete_internal(what_to_do); end

  def self.rl_completer_quote_characters(); end

  def self.rl_completer_quote_characters=(rl_completer_quote_characters); end

  def self.rl_completer_word_break_characters(); end

  def self.rl_completer_word_break_characters=(rl_completer_word_break_characters); end

  def self.rl_completion_append_character(); end

  def self.rl_completion_append_character=(rl_completion_append_character); end

  def self.rl_completion_matches(text, entry_function); end

  def self.rl_copy_text(from, to); end

  def self.rl_crlf(); end

  def self.rl_delete(count, key); end

  def self.rl_delete_horizontal_space(count, ignore); end

  def self.rl_delete_or_show_completions(count, key); end

  def self.rl_delete_text(from, to); end

  def self.rl_deprep_term_function(); end

  def self.rl_deprep_term_function=(rl_deprep_term_function); end

  def self.rl_deprep_terminal(); end

  def self.rl_digit_argument(ignore, key); end

  def self.rl_digit_loop(); end

  def self.rl_ding(); end

  def self.rl_display_match_list(matches, len, max); end

  def self.rl_display_search(search_string, reverse_p, where); end

  def self.rl_do_lowercase_version(ignore1, ignore2); end

  def self.rl_do_undo(); end

  def self.rl_downcase_word(count, key); end

  def self.rl_emacs_editing_mode(count, key); end

  def self.rl_end_of_history(count, key); end

  def self.rl_end_of_line(count, key); end

  def self.rl_end_undo_group(); end

  def self.rl_event_hook(); end

  def self.rl_event_hook=(rl_event_hook); end

  def self.rl_exchange_point_and_mark(count, key); end

  def self.rl_execute_next(c); end

  def self.rl_expand_prompt(prompt); end

  def self.rl_extend_line_buffer(len); end

  def self.rl_filename_completion_function(text, state); end

  def self.rl_filename_quote_characters(); end

  def self.rl_filename_quote_characters=(rl_filename_quote_characters); end

  def self.rl_forced_update_display(); end

  def self.rl_forward(count, key); end

  def self.rl_forward_byte(count, key); end

  def self.rl_forward_char(count, key); end

  def self.rl_forward_search_history(sign, key); end

  def self.rl_forward_word(count, key); end

  def self.rl_free_undo_list(); end

  def self.rl_function_of_keyseq(keyseq, map, type); end

  def self.rl_gather_tyi(); end

  def self.rl_generic_bind(type, keyseq, data, map); end

  def self.rl_get_char(); end

  def self.rl_get_keymap_name_from_edit_mode(); end

  def self.rl_get_next_history(count, key); end

  def self.rl_get_previous_history(count, key); end

  def self.rl_getc(stream); end

  def self.rl_initialize(); end

  def self.rl_insert(count, c); end

  def self.rl_insert_comment(count, key); end

  def self.rl_insert_completions(ignore, invoking_key); end

  def self.rl_insert_text(string); end

  def self.rl_instream(); end

  def self.rl_instream=(rl_instream); end

  def self.rl_isstate(x); end

  def self.rl_kill_full_line(count, ignore); end

  def self.rl_kill_line(direction, ignore); end

  def self.rl_kill_text(from, to); end

  def self.rl_kill_word(count, key); end

  def self.rl_library_version(); end

  def self.rl_library_version=(rl_library_version); end

  def self.rl_line_buffer(); end

  def self.rl_maybe_replace_line(); end

  def self.rl_maybe_save_line(); end

  def self.rl_maybe_unsave_line(); end

  def self.rl_message(msg_buf); end

  def self.rl_modifying(start, _end); end

  def self.rl_named_function(name); end

  def self.rl_newline(count, key); end

  def self.rl_noninc_forward_search(count, key); end

  def self.rl_noninc_reverse_search(count, key); end

  def self.rl_on_new_line(); end

  def self.rl_on_new_line_with_prompt(); end

  def self.rl_outstream(); end

  def self.rl_outstream=(rl_outstream); end

  def self.rl_overwrite_mode(count, key); end

  def self.rl_parse_and_bind(string); end

  def self.rl_point(); end

  def self.rl_possible_completions(ignore, invoking_key); end

  def self.rl_prep_terminal(meta_flag); end

  def self.rl_quoted_insert(count, key); end

  def self.rl_re_read_init_file(count, ignore); end

  def self.rl_read_init_file(filename); end

  def self.rl_read_key(); end

  def self.rl_readline_name(); end

  def self.rl_readline_name=(rl_readline_name); end

  def self.rl_redisplay(); end

  def self.rl_refresh_line(ignore1, ignore2); end

  def self.rl_replace_from_history(entry, flags); end

  def self.rl_replace_line(text, clear_undo); end

  def self.rl_reset_line_state(); end

  def self.rl_resize_terminal(); end

  def self.rl_restart_output(count, key); end

  def self.rl_restore_prompt(); end

  def self.rl_reverse_search_history(sign, key); end

  def self.rl_revert_line(count, key); end

  def self.rl_rubout(count, key); end

  def self.rl_rubout_or_delete(count, key); end

  def self.rl_save_prompt(); end

  def self.rl_search_history(direction, invoking_key); end

  def self.rl_set_keymap_from_edit_mode(); end

  def self.rl_set_mark(count, key); end

  def self.rl_set_prompt(prompt); end

  def self.rl_set_signals(); end

  def self.rl_setstate(x); end

  def self.rl_sigwinch_handler(sig); end

  def self.rl_stuff_char(key); end

  def self.rl_tab_insert(count, key); end

  def self.rl_tilde_expand(ignore, key); end

  def self.rl_translate_keyseq(seq); end

  def self.rl_transpose_chars(count, key); end

  def self.rl_transpose_words(count, key); end

  def self.rl_tty_set_default_bindings(kmap); end

  def self.rl_tty_unset_default_bindings(kmap); end

  def self.rl_undo_command(count, key); end

  def self.rl_unix_filename_rubout(count, key); end

  def self.rl_unix_line_discard(count, key); end

  def self.rl_unix_word_rubout(count, key); end

  def self.rl_unsetstate(x); end

  def self.rl_upcase_word(count, key); end

  def self.rl_username_completion_function(text, state); end

  def self.rl_variable_bind(name, value); end

  def self.rl_vi_check(); end

  def self.rl_vi_editing_mode(count, key); end

  def self.rl_vi_insertion_mode(count, key); end

  def self.rl_yank(count, ignore); end

  def self.rl_yank_last_arg(count, key); end

  def self.rl_yank_nth_arg(count, ignore); end

  def self.rl_yank_nth_arg_internal(count, ignore, history_skip); end

  def self.rl_yank_pop(count, key); end

  def self.save_tty_chars(); end

  def self.set_completion_defaults(what_to_do); end

  def self.sh_set_lines_and_columns(lines, cols); end

  def self.space_to_eol(count); end

  def self.stat_char(filename); end

  def self.stifle_history(max); end

  def self.tgetflag(name); end

  def self.trans(i); end

  def self.unstifle_history(); end

  def self.update_line(old, ostart, new, current_line, omax, nmax, inv_botlin); end

  def self.using_history(); end

  def self.vis_chars(line); end

  def self.vis_line(line); end

  def self.vis_llen(l); end

  def self.vis_pos(line); end

  def self.w_offset(line, offset); end

  def self.where_history(); end

  def self.whitespace(c); end
end

module Readline
  include ::RbReadline
  VERSION = ::T.let(nil, ::T.untyped)
end

Readline::FILENAME_COMPLETION_PROC = Readline::Fcomp

class Readline::Fcomp
end

class Readline::Fcomp
  def self.call(str); end
end

Readline::HISTORY = Readline::History

class Readline::History
end

class Readline::History
  extend ::Enumerable
  def self.<<(str); end

  def self.[](index); end

  def self.[]=(index, str); end

  def self.delete_at(index); end

  def self.each(&blk); end

  def self.empty?(); end

  def self.length(); end

  def self.pop(); end

  def self.push(*args); end

  def self.rb_remove_history(index); end

  def self.shift(); end

  def self.size(); end
end

Readline::USERNAME_COMPLETION_PROC = Readline::Ucomp

class Readline::Ucomp
end

class Readline::Ucomp
  def self.call(str); end
end

module Readline
  def self.basic_quote_characters(); end

  def self.basic_quote_characters=(str); end

  def self.basic_word_break_characters(); end

  def self.basic_word_break_characters=(str); end

  def self.completer_quote_characters(); end

  def self.completer_quote_characters=(str); end

  def self.completer_word_break_characters(); end

  def self.completer_word_break_characters=(str); end

  def self.completion_append_character(); end

  def self.completion_append_character=(char); end

  def self.completion_case_fold(); end

  def self.completion_case_fold=(bool); end

  def self.completion_proc(); end

  def self.completion_proc=(proc); end

  def self.emacs_editing_mode(); end

  def self.filename_quote_characters(); end

  def self.filename_quote_characters=(str); end

  def self.input=(input); end

  def self.line_buffer(); end

  def self.output=(output); end

  def self.point(); end

  def self.readline(prompt=T.unsafe(nil), add_history=T.unsafe(nil)); end

  def self.readline_attempted_completion_function(text, start, _end); end

  def self.silence_warnings(&block); end

  def self.vi_editing_mode(); end
end

class Regexp
  def multiline?(); end
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

class RubyVM::DebugInspector
  def backtrace_locations(); end

  def frame_binding(_); end

  def frame_class(_); end

  def frame_iseq(_); end

  def frame_self(_); end
end

class RubyVM::DebugInspector
  def self.open(); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end

  def self.stat(*_); end
end

SE = PryStackExplorer

module SQLite3
  SQLITE_VERSION = ::T.let(nil, ::T.untyped)
  SQLITE_VERSION_NUMBER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class SQLite3::AbortException
end

class SQLite3::AbortException
end

class SQLite3::AuthorizationException
end

class SQLite3::AuthorizationException
end

class SQLite3::Backup
  def finish(); end

  def initialize(_, _1, _2, _3); end

  def pagecount(); end

  def remaining(); end

  def step(_); end
end

class SQLite3::Backup
end

class SQLite3::Blob
end

class SQLite3::Blob
end

class SQLite3::BusyException
end

class SQLite3::BusyException
end

class SQLite3::CantOpenException
end

class SQLite3::CantOpenException
end

module SQLite3::Constants
end

module SQLite3::Constants::ColumnType
  BLOB = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::ColumnType
end

module SQLite3::Constants::ErrorCode
  ABORT = ::T.let(nil, ::T.untyped)
  AUTH = ::T.let(nil, ::T.untyped)
  BUSY = ::T.let(nil, ::T.untyped)
  CANTOPEN = ::T.let(nil, ::T.untyped)
  CONSTRAINT = ::T.let(nil, ::T.untyped)
  CORRUPT = ::T.let(nil, ::T.untyped)
  DONE = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FULL = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  INTERRUPT = ::T.let(nil, ::T.untyped)
  IOERR = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MISMATCH = ::T.let(nil, ::T.untyped)
  MISUSE = ::T.let(nil, ::T.untyped)
  NOLFS = ::T.let(nil, ::T.untyped)
  NOMEM = ::T.let(nil, ::T.untyped)
  NOTFOUND = ::T.let(nil, ::T.untyped)
  OK = ::T.let(nil, ::T.untyped)
  PERM = ::T.let(nil, ::T.untyped)
  PROTOCOL = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  ROW = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  TOOBIG = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::ErrorCode
end

module SQLite3::Constants::Open
  AUTOPROXY = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETEONCLOSE = ::T.let(nil, ::T.untyped)
  EXCLUSIVE = ::T.let(nil, ::T.untyped)
  FULLMUTEX = ::T.let(nil, ::T.untyped)
  MAIN_DB = ::T.let(nil, ::T.untyped)
  MAIN_JOURNAL = ::T.let(nil, ::T.untyped)
  MASTER_JOURNAL = ::T.let(nil, ::T.untyped)
  MEMORY = ::T.let(nil, ::T.untyped)
  NOMUTEX = ::T.let(nil, ::T.untyped)
  PRIVATECACHE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  READWRITE = ::T.let(nil, ::T.untyped)
  SHAREDCACHE = ::T.let(nil, ::T.untyped)
  SUBJOURNAL = ::T.let(nil, ::T.untyped)
  TEMP_DB = ::T.let(nil, ::T.untyped)
  TEMP_JOURNAL = ::T.let(nil, ::T.untyped)
  TRANSIENT_DB = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  WAL = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::Open
end

module SQLite3::Constants::TextRep
  ANY = ::T.let(nil, ::T.untyped)
  DETERMINISTIC = ::T.let(nil, ::T.untyped)
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module SQLite3::Constants::TextRep
end

module SQLite3::Constants
end

class SQLite3::ConstraintException
end

class SQLite3::ConstraintException
end

class SQLite3::CorruptException
end

class SQLite3::CorruptException
end

class SQLite3::Database
  include ::SQLite3::Pragmas
  def authorizer(&block); end

  def authorizer=(authorizer); end

  def busy_handler(*_); end

  def busy_timeout(_); end

  def busy_timeout=(busy_timeout); end

  def changes(); end

  def close(); end

  def closed?(); end

  def collation(_, _1); end

  def collations(); end

  def commit(); end

  def complete?(_); end

  def create_aggregate(name, arity, step=T.unsafe(nil), finalize=T.unsafe(nil), text_rep=T.unsafe(nil), &block); end

  def create_aggregate_handler(handler); end

  def create_function(name, arity, text_rep=T.unsafe(nil), &block); end

  def define_aggregator(name, aggregator); end

  def define_function(_); end

  def define_function_with_flags(_, _1); end

  def enable_load_extension(_); end

  def errcode(); end

  def errmsg(); end

  def execute(sql, bind_vars=T.unsafe(nil), *args, &block); end

  def execute2(sql, *bind_vars); end

  def execute_batch(sql, bind_vars=T.unsafe(nil), *args); end

  def execute_batch2(sql, &block); end

  def extended_result_codes=(extended_result_codes); end

  def filename(db_name=T.unsafe(nil)); end

  def get_first_row(sql, *bind_vars); end

  def get_first_value(sql, *bind_vars); end

  def initialize(file, options=T.unsafe(nil), zvfs=T.unsafe(nil)); end

  def interrupt(); end

  def last_insert_row_id(); end

  def load_extension(_); end

  def prepare(sql); end

  def query(sql, bind_vars=T.unsafe(nil), *args); end

  def readonly?(); end

  def results_as_hash(); end

  def results_as_hash=(results_as_hash); end

  def rollback(); end

  def total_changes(); end

  def trace(*_); end

  def transaction(mode=T.unsafe(nil)); end

  def transaction_active?(); end

  def translate_from_db(types, row); end

  def translator(); end

  def type_translation(); end

  def type_translation=(value); end
  NULL_TRANSLATOR = ::T.let(nil, ::T.untyped)
end

class SQLite3::Database::FunctionProxy
  def [](key); end

  def []=(key, value); end

  def count(); end

  def result(); end

  def result=(result); end

  def set_error(error); end
end

class SQLite3::Database::FunctionProxy
end

class SQLite3::Database
  def self.quote(string); end
end

class SQLite3::EmptyException
end

class SQLite3::EmptyException
end

class SQLite3::Exception
  def code(); end
end

class SQLite3::Exception
end

class SQLite3::FormatException
end

class SQLite3::FormatException
end

class SQLite3::FullException
end

class SQLite3::FullException
end

class SQLite3::IOException
end

class SQLite3::IOException
end

class SQLite3::InternalException
end

class SQLite3::InternalException
end

class SQLite3::InterruptException
end

class SQLite3::InterruptException
end

class SQLite3::LockedException
end

class SQLite3::LockedException
end

class SQLite3::MemoryException
end

class SQLite3::MemoryException
end

class SQLite3::MismatchException
end

class SQLite3::MismatchException
end

class SQLite3::MisuseException
end

class SQLite3::MisuseException
end

class SQLite3::NotADatabaseException
end

class SQLite3::NotADatabaseException
end

class SQLite3::NotFoundException
end

class SQLite3::NotFoundException
end

class SQLite3::PermissionException
end

class SQLite3::PermissionException
end

module SQLite3::Pragmas
  def application_id(); end

  def application_id=(integer); end

  def auto_vacuum(); end

  def auto_vacuum=(mode); end

  def automatic_index(); end

  def automatic_index=(mode); end

  def busy_timeout(); end

  def busy_timeout=(milliseconds); end

  def cache_size(); end

  def cache_size=(size); end

  def cache_spill(); end

  def cache_spill=(mode); end

  def case_sensitive_like=(mode); end

  def cell_size_check(); end

  def cell_size_check=(mode); end

  def checkpoint_fullfsync(); end

  def checkpoint_fullfsync=(mode); end

  def collation_list(&block); end

  def compile_options(&block); end

  def count_changes(); end

  def count_changes=(mode); end

  def data_version(); end

  def database_list(&block); end

  def default_cache_size(); end

  def default_cache_size=(size); end

  def default_synchronous(); end

  def default_synchronous=(mode); end

  def default_temp_store(); end

  def default_temp_store=(mode); end

  def defer_foreign_keys(); end

  def defer_foreign_keys=(mode); end

  def encoding(); end

  def encoding=(mode); end

  def foreign_key_check(*table, &block); end

  def foreign_key_list(table, &block); end

  def foreign_keys(); end

  def foreign_keys=(mode); end

  def freelist_count(); end

  def full_column_names(); end

  def full_column_names=(mode); end

  def fullfsync(); end

  def fullfsync=(mode); end

  def get_boolean_pragma(name); end

  def get_enum_pragma(name); end

  def get_int_pragma(name); end

  def get_query_pragma(name, *parms, &block); end

  def ignore_check_constraints=(mode); end

  def incremental_vacuum(pages, &block); end

  def index_info(index, &block); end

  def index_list(table, &block); end

  def index_xinfo(index, &block); end

  def integrity_check(*num_errors, &block); end

  def journal_mode(); end

  def journal_mode=(mode); end

  def journal_size_limit(); end

  def journal_size_limit=(size); end

  def legacy_file_format(); end

  def legacy_file_format=(mode); end

  def locking_mode(); end

  def locking_mode=(mode); end

  def max_page_count(); end

  def max_page_count=(size); end

  def mmap_size(); end

  def mmap_size=(size); end

  def page_count(); end

  def page_size(); end

  def page_size=(size); end

  def parser_trace=(mode); end

  def query_only(); end

  def query_only=(mode); end

  def quick_check(*num_errors, &block); end

  def read_uncommitted(); end

  def read_uncommitted=(mode); end

  def recursive_triggers(); end

  def recursive_triggers=(mode); end

  def reverse_unordered_selects(); end

  def reverse_unordered_selects=(mode); end

  def schema_cookie(); end

  def schema_cookie=(cookie); end

  def schema_version(); end

  def schema_version=(version); end

  def secure_delete(); end

  def secure_delete=(mode); end

  def set_boolean_pragma(name, mode); end

  def set_enum_pragma(name, mode, enums); end

  def set_int_pragma(name, value); end

  def short_column_names(); end

  def short_column_names=(mode); end

  def shrink_memory(); end

  def soft_heap_limit(); end

  def soft_heap_limit=(mode); end

  def stats(&block); end

  def synchronous(); end

  def synchronous=(mode); end

  def table_info(table); end

  def temp_store(); end

  def temp_store=(mode); end

  def threads(); end

  def threads=(count); end

  def user_cookie(); end

  def user_cookie=(cookie); end

  def user_version(); end

  def user_version=(version); end

  def vdbe_addoptrace=(mode); end

  def vdbe_debug=(mode); end

  def vdbe_listing=(mode); end

  def vdbe_trace(); end

  def vdbe_trace=(mode); end

  def wal_autocheckpoint(); end

  def wal_autocheckpoint=(mode); end

  def wal_checkpoint(); end

  def wal_checkpoint=(mode); end

  def writable_schema=(mode); end
  AUTO_VACUUM_MODES = ::T.let(nil, ::T.untyped)
  ENCODINGS = ::T.let(nil, ::T.untyped)
  JOURNAL_MODES = ::T.let(nil, ::T.untyped)
  LOCKING_MODES = ::T.let(nil, ::T.untyped)
  SYNCHRONOUS_MODES = ::T.let(nil, ::T.untyped)
  TEMP_STORE_MODES = ::T.let(nil, ::T.untyped)
  WAL_CHECKPOINTS = ::T.let(nil, ::T.untyped)
end

module SQLite3::Pragmas
end

class SQLite3::ProtocolException
end

class SQLite3::ProtocolException
end

class SQLite3::RangeException
end

class SQLite3::RangeException
end

class SQLite3::ReadOnlyException
end

class SQLite3::ReadOnlyException
end

class SQLite3::ResultSet
  include ::Enumerable
  def close(); end

  def closed?(); end

  def columns(); end

  def each(&blk); end

  def each_hash(); end

  def eof?(); end

  def initialize(db, stmt); end

  def next(); end

  def next_hash(); end

  def reset(*bind_params); end

  def types(); end
end

class SQLite3::ResultSet::ArrayWithTypes
  def types(); end

  def types=(types); end
end

class SQLite3::ResultSet::ArrayWithTypes
end

class SQLite3::ResultSet::ArrayWithTypesAndFields
  def fields(); end

  def fields=(fields); end

  def types(); end

  def types=(types); end
end

class SQLite3::ResultSet::ArrayWithTypesAndFields
end

class SQLite3::ResultSet::HashWithTypesAndFields
  def [](key); end

  def fields(); end

  def fields=(fields); end

  def types(); end

  def types=(types); end
end

class SQLite3::ResultSet::HashWithTypesAndFields
end

class SQLite3::ResultSet
end

class SQLite3::SQLException
end

class SQLite3::SQLException
end

class SQLite3::SchemaChangedException
end

class SQLite3::SchemaChangedException
end

class SQLite3::Statement
  include ::Enumerable
  def active?(); end

  def bind_param(_, _1); end

  def bind_parameter_count(); end

  def bind_params(*bind_vars); end

  def clear_bindings!(); end

  def close(); end

  def closed?(); end

  def column_count(); end

  def column_decltype(_); end

  def column_name(_); end

  def columns(); end

  def database_name(_); end

  def done?(); end

  def each(&blk); end

  def execute(*bind_vars); end

  def execute!(*bind_vars, &block); end

  def initialize(_, _1); end

  def must_be_open!(); end

  def remainder(); end

  def reset!(); end

  def step(); end

  def types(); end
end

class SQLite3::Statement
end

class SQLite3::TooBigException
end

class SQLite3::TooBigException
end

class SQLite3::Translator
  def add_translator(type, &block); end

  def translate(type, value); end
end

class SQLite3::Translator
end

class SQLite3::UnsupportedException
end

class SQLite3::UnsupportedException
end

class SQLite3::Value
  def handle(); end

  def initialize(db, handle); end

  def length(utf16=T.unsafe(nil)); end

  def null?(); end

  def to_blob(); end

  def to_f(); end

  def to_i(); end

  def to_int64(); end

  def to_s(utf16=T.unsafe(nil)); end

  def type(); end
end

class SQLite3::Value
end

module SQLite3::VersionProxy
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module SQLite3::VersionProxy
end

module SQLite3
  def self.const_missing(name); end

  def self.libversion(); end

  def self.sqlcipher?(); end

  def self.threadsafe(); end

  def self.threadsafe?(); end
end

module SafeYAML
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  MULTI_ARGUMENT_YAML_LOAD = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PREDEFINED_TAGS = ::T.let(nil, ::T.untyped)
  YAML_ENGINE = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Deep
end

class SafeYAML::Deep
  def self.copy(object); end

  def self.freeze(object); end
end

class SafeYAML::LibyamlChecker
  KNOWN_PATCHED_LIBYAML_VERSIONS = ::T.let(nil, ::T.untyped)
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  SAFE_LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
end

class SafeYAML::LibyamlChecker
  def self.libyaml_patched?(); end

  def self.libyaml_version_ok?(); end
end

class SafeYAML::Parse
end

class SafeYAML::Parse::Date
  DATE_MATCHER = ::T.let(nil, ::T.untyped)
  MICROSECONDS_PER_SECOND = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SEC_FRACTION_MULTIPLIER = ::T.let(nil, ::T.untyped)
  TIME_MATCHER = ::T.let(nil, ::T.untyped)
  TO_TIME_AVAILABLE = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Parse::Date
  def self.value(value); end
end

class SafeYAML::Parse::Hexadecimal
  MATCHER = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Parse::Hexadecimal
  def self.value(value); end
end

class SafeYAML::Parse::Sexagesimal
  FLOAT_MATCHER = ::T.let(nil, ::T.untyped)
  INTEGER_MATCHER = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Parse::Sexagesimal
  def self.value(value); end
end

class SafeYAML::Parse
end

class SafeYAML::PsychHandler
  def add_to_current_structure(value, anchor=T.unsafe(nil), quoted=T.unsafe(nil), tag=T.unsafe(nil)); end

  def end_current_structure(); end

  def initialize(options, &block); end

  def result(); end
end

class SafeYAML::PsychHandler
end

class SafeYAML::PsychResolver
  def get_node_tag(node); end

  def get_node_type(node); end

  def get_node_value(node); end

  def initialize(options=T.unsafe(nil)); end

  def native_resolve(node); end

  def resolve_alias(node); end

  def resolve_root(root); end

  def value_is_quoted?(node); end
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class SafeYAML::PsychResolver
end

class SafeYAML::Resolver
  def get_and_check_node_tag(node); end

  def initialize(options); end

  def options(); end

  def resolve_map(node); end

  def resolve_node(node); end

  def resolve_scalar(node); end

  def resolve_seq(node); end

  def tag_is_whitelisted?(tag); end
end

class SafeYAML::Resolver
end

class SafeYAML::SafeToRubyVisitor
  def accept(node); end

  def initialize(resolver); end
  INITIALIZE_ARITY = ::T.let(nil, ::T.untyped)
end

class SafeYAML::SafeToRubyVisitor
end

class SafeYAML::Transform
  TRANSFORMERS = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Transform::ToBoolean
  include ::SafeYAML::Transform::TransformationMap
  def transform?(value); end
  PREDEFINED_VALUES = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Transform::ToBoolean
  extend ::SafeYAML::Transform::TransformationMap::ClassMethods
end

class SafeYAML::Transform::ToDate
  def transform?(value); end
end

class SafeYAML::Transform::ToDate
end

class SafeYAML::Transform::ToFloat
  def transform?(value); end

  def try_edge_cases?(value); end
  Infinity = ::T.let(nil, ::T.untyped)
  MATCHER = ::T.let(nil, ::T.untyped)
  PREDEFINED_VALUES = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Transform::ToFloat
end

class SafeYAML::Transform::ToInteger
  def transform?(value); end

  def try_edge_cases?(value); end
  MATCHERS = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Transform::ToInteger
end

class SafeYAML::Transform::ToNil
  include ::SafeYAML::Transform::TransformationMap
  def transform?(value); end
  PREDEFINED_VALUES = ::T.let(nil, ::T.untyped)
end

class SafeYAML::Transform::ToNil
  extend ::SafeYAML::Transform::TransformationMap::ClassMethods
end

class SafeYAML::Transform::ToSymbol
  def transform?(value, options=T.unsafe(nil)); end
end

class SafeYAML::Transform::ToSymbol
end

module SafeYAML::Transform::TransformationMap
end

class SafeYAML::Transform::TransformationMap::CaseAgnosticMap
  def [](key); end

  def include?(key); end

  def initialize(*args); end
end

class SafeYAML::Transform::TransformationMap::CaseAgnosticMap
end

module SafeYAML::Transform::TransformationMap::ClassMethods
  def set_predefined_values(predefined_values); end
end

module SafeYAML::Transform::TransformationMap::ClassMethods
end

module SafeYAML::Transform::TransformationMap
  def self.included(base); end
end

class SafeYAML::Transform
  def self.to_guessed_type(value, quoted=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.to_proper_type(value, quoted=T.unsafe(nil), tag=T.unsafe(nil), options=T.unsafe(nil)); end
end

module SafeYAML
  def self.load(yaml, filename=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.load_file(filename, options=T.unsafe(nil)); end

  def self.restore_defaults!(); end

  def self.tag_is_explicitly_trusted?(tag); end

  def self.tag_safety_check!(tag, options); end

  def self.whitelist!(*classes); end

  def self.whitelist_class!(klass); end
end

ScanError = StringScanner::Error

module SecureRandom
  BASE36_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE58_ALPHABET = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  def self.base36(n=T.unsafe(nil)); end

  def self.base58(n=T.unsafe(nil)); end

  def self.bytes(n); end
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class Shop
  include ::Shop::GeneratedAttributeMethods
  include ::Shop::GeneratedAssociationMethods
end

module Shop::GeneratedAssociationMethods
end

module Shop::GeneratedAssociationMethods
end

module Shop::GeneratedAttributeMethods
end

module Shop::GeneratedAttributeMethods
  extend ::Mutex_m
end

class Shopify::AfterAuthenticateJob
end

class Shopify::RotateShopifyTokenJob
end

module ShopifyAPI
  include ::ShopifyAPI::Limits
  VERSION = ::T.let(nil, ::T.untyped)
end

class ShopifyAPI::AbandonedCheckout
end

class ShopifyAPI::AbandonedCheckout
end

class ShopifyAPI::AccessScope
end

class ShopifyAPI::AccessScope
  def self.prefix(_options=T.unsafe(nil)); end
end

class ShopifyAPI::AccessToken
end

class ShopifyAPI::AccessToken
  def self.delegate(access_scope, expires_in=T.unsafe(nil)); end
end

class ShopifyAPI::Address
end

class ShopifyAPI::Address
end

class ShopifyAPI::Announcement
end

class ShopifyAPI::Announcement
end

class ShopifyAPI::ApiPermission
end

class ShopifyAPI::ApiPermission
  def self.destroy(); end
end

class ShopifyAPI::ApiVersion
  include ::Comparable
  def ==(other); end

  def construct_api_path(path); end

  def construct_graphql_path(); end

  def display_name(); end

  def handle(); end

  def handle_as_date(); end

  def initialize(attributes); end

  def latest_supported(); end

  def latest_supported?(); end

  def name(); end

  def stable?(); end

  def supported(); end

  def supported?(); end

  def unstable?(); end

  def verified(); end

  def verified?(); end
  API_PREFIX = ::T.let(nil, ::T.untyped)
  HANDLE_FORMAT = ::T.let(nil, ::T.untyped)
  LOOKUP_MODES = ::T.let(nil, ::T.untyped)
  UNSTABLE_AS_DATE = ::T.let(nil, ::T.untyped)
  UNSTABLE_HANDLE = ::T.let(nil, ::T.untyped)
end

class ShopifyAPI::ApiVersion::ApiVersionNotSetError
end

class ShopifyAPI::ApiVersion::ApiVersionNotSetError
end

class ShopifyAPI::ApiVersion::NullVersion
end

class ShopifyAPI::ApiVersion::NullVersion
  def self.construct_api_path(*_args); end

  def self.construct_graphql_path(*_args); end

  def self.display_name(*_args); end

  def self.handle(*_args); end

  def self.latest_supported(*_args); end

  def self.latest_supported?(*_args); end

  def self.matches?(version); end

  def self.name(*_args); end

  def self.new(*_args); end

  def self.raise_not_set_error(*_args); end

  def self.stable?(*_args); end

  def self.supported(*_args); end

  def self.supported?(*_args); end

  def self.unstable?(*_args); end

  def self.verified(*_args); end

  def self.verified?(*_args); end
end

class ShopifyAPI::ApiVersion::UnknownVersion
end

class ShopifyAPI::ApiVersion::UnknownVersion
end

class ShopifyAPI::ApiVersion
  def self.add_to_known_versions(version); end

  def self.clear_defined_versions(); end

  def self.clear_known_versions(); end

  def self.coerce_to_version(version_or_handle); end

  def self.define_known_versions(); end

  def self.fetch_known_versions(); end

  def self.find_version(version_or_handle); end

  def self.latest_stable_version(); end

  def self.version_lookup_mode(); end

  def self.version_lookup_mode=(mode); end

  def self.versions(); end
end

class ShopifyAPI::ApplicationCharge
  def activate(); end
end

class ShopifyAPI::ApplicationCharge
  def self.accepted(); end

  def self.declined(); end

  def self.expired(); end

  def self.pending(); end
end

class ShopifyAPI::ApplicationCredit
end

class ShopifyAPI::ApplicationCredit
end

class ShopifyAPI::ArrayBase
end

class ShopifyAPI::ArrayBase
end

class ShopifyAPI::Article
  include ::ShopifyAPI::Events
  include ::ShopifyAPI::Metafields
  include ::ShopifyAPI::DisablePrefixCheck
  def blog_id(); end

  def comments(); end
end

class ShopifyAPI::Article
  extend ::ShopifyAPI::DisablePrefixCheck::ClassMethods
  def self.authors(options=T.unsafe(nil)); end

  def self.resource_prefix(options=T.unsafe(nil)); end

  def self.tags(options=T.unsafe(nil)); end
end

class ShopifyAPI::Asset
  include ::ShopifyAPI::DisablePrefixCheck
  def attach(data); end

  def theme_id(); end

  def value(); end
end

class ShopifyAPI::Asset
  extend ::ShopifyAPI::DisablePrefixCheck::ClassMethods
  def self.find(*args); end

  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::AssignedFulfillmentOrder
end

class ShopifyAPI::AssignedFulfillmentOrder
  def self.find(scope, *args); end
end

class ShopifyAPI::Base
end

class ShopifyAPI::Base::InvalidSessionError
end

class ShopifyAPI::Base::InvalidSessionError
end

class ShopifyAPI::Base
  extend ::ShopifyAPI::Countable
  def self._api_version(); end

  def self._api_version=(value); end

  def self._api_version_defined?(); end

  def self.activate_session(session); end

  def self.api_version(); end

  def self.api_version=(version); end

  def self.clear_session(); end

  def self.early_july_pagination?(); end

  def self.init_prefix(resource); end

  def self.init_prefix_explicit(resource_type, resource_id); end

  def self.prefix=(value); end

  def self.resource_prefix(_options=T.unsafe(nil)); end

  def self.resource_prefix=(value); end

  def self.set_prefix(value); end

  def self.version_validation!(minimum_version); end
end

class ShopifyAPI::BillingAddress
end

class ShopifyAPI::BillingAddress
end

class ShopifyAPI::Blog
  include ::ShopifyAPI::Events
  include ::ShopifyAPI::Metafields
  def articles(); end
end

class ShopifyAPI::Blog
end

class ShopifyAPI::CarrierService
end

class ShopifyAPI::CarrierService
end

class ShopifyAPI::Cart
end

class ShopifyAPI::Cart
end

class ShopifyAPI::Checkout
  def complete(); end

  def payments(); end

  def ready?(); end

  def shipping_rates(); end
end

class ShopifyAPI::Checkout
end

class ShopifyAPI::Collect
end

class ShopifyAPI::Collect
end

class ShopifyAPI::Collection
  include ::ShopifyAPI::Events
  include ::ShopifyAPI::Metafields
  def products(options=T.unsafe(nil)); end
end

class ShopifyAPI::Collection
end

class ShopifyAPI::CollectionListing
  def product_ids(); end
end

class ShopifyAPI::CollectionListing
end

class ShopifyAPI::CollectionPublication
  def publication_id(); end
end

class ShopifyAPI::CollectionPublication
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::Comment
  def approve(); end

  def not_spam(); end

  def remove(); end

  def restore(); end

  def spam(); end
end

class ShopifyAPI::Comment
end

class ShopifyAPI::Connection
  include ::ShopifyAPI::Connection::ResponseCapture
  include ::ShopifyAPI::Connection::RequestNotification
  def response(); end
end

module ShopifyAPI::Connection::RequestNotification
  def notify_about_request(method, path, response, arguments); end

  def request(method, path, *arguments); end
end

module ShopifyAPI::Connection::RequestNotification
end

module ShopifyAPI::Connection::ResponseCapture
  def handle_response(response); end
end

module ShopifyAPI::Connection::ResponseCapture
end

class ShopifyAPI::Connection
end

module ShopifyAPI::Countable
  def count(options=T.unsafe(nil)); end
end

module ShopifyAPI::Countable
end

class ShopifyAPI::Country
end

class ShopifyAPI::Country
end

class ShopifyAPI::Currency
end

class ShopifyAPI::Currency
end

class ShopifyAPI::CustomCollection
  include ::ShopifyAPI::Events
  include ::ShopifyAPI::Metafields
  def add_product(product); end

  def products(); end

  def remove_product(product); end
end

class ShopifyAPI::CustomCollection
end

class ShopifyAPI::Customer
  include ::ShopifyAPI::Metafields
  def account_activation_url(); end

  def orders(); end

  def send_invite(customer_invite=T.unsafe(nil)); end
end

class ShopifyAPI::Customer
  def self.search(params); end
end

ShopifyAPI::CustomerGroup = ShopifyAPI::CustomerSavedSearch

class ShopifyAPI::CustomerInvite
end

class ShopifyAPI::CustomerInvite
end

class ShopifyAPI::CustomerSavedSearch
  def customers(params=T.unsafe(nil)); end
end

class ShopifyAPI::CustomerSavedSearch
end

module ShopifyAPI::DisablePrefixCheck
end

module ShopifyAPI::DisablePrefixCheck::ClassMethods
  def check_prefix_options(options); end

  def conditional_prefix(resource, flexible=T.unsafe(nil)); end
end

module ShopifyAPI::DisablePrefixCheck::ClassMethods
end

module ShopifyAPI::DisablePrefixCheck
  extend ::ActiveSupport::Concern
end

class ShopifyAPI::DiscountCode
  def price_rule_id(); end
end

class ShopifyAPI::DiscountCode
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::DiscountCodeBatch
  def discount_code_job(); end

  def price_rule_id(); end
end

class ShopifyAPI::DiscountCodeBatch
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::DraftOrder
  include ::ShopifyAPI::Metafields
  def complete(options=T.unsafe(nil)); end

  def send_invoice(draft_order_invoice=T.unsafe(nil)); end
end

class ShopifyAPI::DraftOrder
end

class ShopifyAPI::DraftOrderInvoice
end

class ShopifyAPI::DraftOrderInvoice
end

class ShopifyAPI::Event
  include ::ShopifyAPI::DisablePrefixCheck
  def resource_id(); end
end

class ShopifyAPI::Event
  extend ::ShopifyAPI::DisablePrefixCheck::ClassMethods
  def self.resource_prefix(options=T.unsafe(nil)); end
end

module ShopifyAPI::Events
  def events(); end
end

module ShopifyAPI::Events
end

class ShopifyAPI::Fulfillment
  def cancel(); end

  def complete(); end

  def open(); end

  def order_id(); end

  def order_id=(order_id); end

  def save(); end

  def update_tracking(tracking_info:, notify_customer:); end
end

class ShopifyAPI::Fulfillment
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::FulfillmentEvent
  def fulfillment_id(); end

  def order_id(); end
end

class ShopifyAPI::FulfillmentEvent
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::FulfillmentOrder
  def accept_cancellation_request(message: T.unsafe(nil)); end

  def accept_fulfillment_request(message: T.unsafe(nil)); end

  def cancel(); end

  def close(message: T.unsafe(nil)); end

  def fulfillments(options=T.unsafe(nil)); end

  def locations_for_move(); end

  def move(new_location_id:); end

  def reject_cancellation_request(message: T.unsafe(nil)); end

  def reject_fulfillment_request(message: T.unsafe(nil)); end

  def request_cancellation(message: T.unsafe(nil)); end

  def request_fulfillment(fulfillment_order_line_items: T.unsafe(nil), message: T.unsafe(nil)); end
  MINIMUM_VERSION = ::T.let(nil, ::T.untyped)
end

class ShopifyAPI::FulfillmentOrder
  def self.find(scope, *args); end
end

class ShopifyAPI::FulfillmentOrderLocationsForMove
end

class ShopifyAPI::FulfillmentOrderLocationsForMove
end

class ShopifyAPI::FulfillmentRequest
  def mark_as_failed(); end

  def order_id(); end
end

class ShopifyAPI::FulfillmentRequest
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::FulfillmentService
end

class ShopifyAPI::FulfillmentService
end

class ShopifyAPI::FulfillmentV2
  def update_tracking(tracking_info:, notify_customer:); end
end

class ShopifyAPI::FulfillmentV2
end

class ShopifyAPI::GiftCard
  def disable(); end
end

class ShopifyAPI::GiftCard
end

module ShopifyAPI::GraphQL
  DEFAULT_SCHEMA_LOCATION_PATH = ::T.let(nil, ::T.untyped)
end

class ShopifyAPI::GraphQL::HTTPClient
  def initialize(api_version); end
end

class ShopifyAPI::GraphQL::HTTPClient
end

class ShopifyAPI::GraphQL::InvalidClient
end

class ShopifyAPI::GraphQL::InvalidClient
end

class ShopifyAPI::GraphQL::InvalidSchema
end

class ShopifyAPI::GraphQL::InvalidSchema
end

class ShopifyAPI::GraphQL::Railtie
end

class ShopifyAPI::GraphQL::Railtie
end

module ShopifyAPI::GraphQL
  def self.clear_clients(); end

  def self.client(api_version=T.unsafe(nil)); end

  def self.initialize_clients(raise_on_invalid_schema: T.unsafe(nil)); end

  def self.parse(*args, &block); end

  def self.query(*args, &block); end

  def self.schema_location(); end

  def self.schema_location=(path); end
end

class ShopifyAPI::Image
  def attach_image(data, filename=T.unsafe(nil)); end

  def compact(); end

  def grande(); end

  def icon(); end

  def large(); end

  def medium(); end

  def original(); end

  def pico(); end

  def product_id(); end

  def small(); end

  def thumb(); end
end

class ShopifyAPI::Image
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::InvalidPaginationLinksError
end

class ShopifyAPI::InvalidPaginationLinksError
end

class ShopifyAPI::InventoryItem
end

class ShopifyAPI::InventoryItem
end

class ShopifyAPI::InventoryLevel
  def adjust(available_adjustment); end

  def connect(relocate_if_necessary: T.unsafe(nil)); end

  def set(new_available, disconnect_if_necessary: T.unsafe(nil)); end
end

class ShopifyAPI::InventoryLevel
  def self.element_path(prefix_options=T.unsafe(nil), query_options=T.unsafe(nil)); end
end

module ShopifyAPI::Limits
end

module ShopifyAPI::Limits::ClassMethods
  def available_calls(); end

  def call_count(scope=T.unsafe(nil)); end

  def call_limit(scope=T.unsafe(nil)); end

  def credit_left(); end

  def credit_limit(scope=T.unsafe(nil)); end

  def credit_maxed?(); end

  def credit_used(scope=T.unsafe(nil)); end

  def maxed?(); end

  def response(); end
  CREDIT_LIMIT_HEADER_PARAM = ::T.let(nil, ::T.untyped)
end

module ShopifyAPI::Limits::ClassMethods
end

class ShopifyAPI::Limits::LimitUnavailable
end

class ShopifyAPI::Limits::LimitUnavailable
end

module ShopifyAPI::Limits
  def self.included(klass); end
end

class ShopifyAPI::LineItem
end

class ShopifyAPI::LineItem::Property
  def initialize(*args); end
end

class ShopifyAPI::LineItem::Property
end

class ShopifyAPI::LineItem
end

class ShopifyAPI::Location
  def inventory_levels(); end
end

class ShopifyAPI::Location
end

class ShopifyAPI::MarketingEvent
  include ::ShopifyAPI::Countable
  def add_engagements(engagements); end
end

class ShopifyAPI::MarketingEvent
end

class ShopifyAPI::MessageEnricher
  def message(); end
end

class ShopifyAPI::MessageEnricher
end

class ShopifyAPI::Meta
end

class ShopifyAPI::Meta
  def self.admin_versions(); end
end

class ShopifyAPI::Metafield
  include ::ShopifyAPI::DisablePrefixCheck
  def resource_id(); end

  def value(); end
end

class ShopifyAPI::Metafield
  extend ::ShopifyAPI::DisablePrefixCheck::ClassMethods
  def self.resource_prefix(options=T.unsafe(nil)); end
end

module ShopifyAPI::Metafields
  def add_metafield(metafield); end

  def metafields(**options); end
end

module ShopifyAPI::Metafields
end

class ShopifyAPI::NoteAttribute
end

class ShopifyAPI::NoteAttribute
end

class ShopifyAPI::Option
end

class ShopifyAPI::Option
end

class ShopifyAPI::Order
  include ::ShopifyAPI::Events
  include ::ShopifyAPI::Metafields
  def cancel(options=T.unsafe(nil)); end

  def capture(amount=T.unsafe(nil), currency: T.unsafe(nil)); end

  def close(); end

  def fulfillment_orders(options=T.unsafe(nil)); end

  def open(); end

  def transactions(); end
end

class ShopifyAPI::Order::ClientDetails
end

class ShopifyAPI::Order::ClientDetails
end

class ShopifyAPI::Order
end

class ShopifyAPI::OrderRisk
  def order_id(); end
end

class ShopifyAPI::OrderRisk
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::Page
  include ::ShopifyAPI::Events
  include ::ShopifyAPI::Metafields
end

class ShopifyAPI::Page
end

class ShopifyAPI::PaginatedCollection
  include ::ShopifyAPI::PaginatedCollection::CollectionPagination
end

module ShopifyAPI::PaginatedCollection::CollectionPagination
  def fetch_next_page(); end

  def fetch_previous_page(); end

  def initialize(args); end

  def next_page?(); end

  def next_page_info(); end

  def previous_page?(); end

  def previous_page_info(); end
  AVAILABLE_IN_VERSION = ::T.let(nil, ::T.untyped)
  AVAILABLE_IN_VERSION_EARLY = ::T.let(nil, ::T.untyped)
end

module ShopifyAPI::PaginatedCollection::CollectionPagination
end

class ShopifyAPI::PaginatedCollection
end

class ShopifyAPI::PaginationLinkHeaders
  def initialize(link_header); end

  def next_link(); end

  def previous_link(); end
end

class ShopifyAPI::PaginationLinkHeaders::LinkHeader
  def rel(); end

  def rel=(_); end

  def url(); end

  def url=(_); end
end

class ShopifyAPI::PaginationLinkHeaders::LinkHeader
  def self.[](*_); end

  def self.members(); end
end

class ShopifyAPI::PaginationLinkHeaders
end

class ShopifyAPI::Payment
end

class ShopifyAPI::Payment
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::PaymentDetails
end

class ShopifyAPI::PaymentDetails
end

class ShopifyAPI::Policy
end

class ShopifyAPI::Policy
  def self.all(); end
end

class ShopifyAPI::PriceRule
  def discount_codes(); end
end

class ShopifyAPI::PriceRule
end

class ShopifyAPI::Product
  include ::ShopifyAPI::Events
  include ::ShopifyAPI::Metafields
  def add_to_collection(collection); end

  def collections(); end

  def price_range(); end

  def remove_from_collection(collection); end

  def smart_collections(); end

  def total_inventory=(new_value); end
end

class ShopifyAPI::Product
end

class ShopifyAPI::ProductListing
end

class ShopifyAPI::ProductListing
  def self.product_ids(); end
end

class ShopifyAPI::ProductPublication
  def publication_id(); end
end

class ShopifyAPI::ProductPublication
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::Province
  def country_id(); end
end

class ShopifyAPI::Province
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::Publication
end

class ShopifyAPI::Publication
end

class ShopifyAPI::Receipt
end

class ShopifyAPI::Receipt
end

class ShopifyAPI::RecurringApplicationCharge
  def activate(); end

  def cancel(); end

  def customize(customize_recurring_app_charge_params=T.unsafe(nil)); end

  def usage_charges(); end
end

class ShopifyAPI::RecurringApplicationCharge
  def self.accepted(); end

  def self.cancelled(); end

  def self.current(); end

  def self.declined(); end

  def self.pending(); end
end

class ShopifyAPI::Redirect
end

class ShopifyAPI::Redirect
end

class ShopifyAPI::Refund
  def order_id(); end
end

class ShopifyAPI::Refund
  def self.calculate(*args); end

  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::Report
end

class ShopifyAPI::Report
end

class ShopifyAPI::ResourceFeedback
  include ::ShopifyAPI::DisablePrefixCheck
  def product_id(); end

  def save(); end
  EXISTING_FEEDBACK_SAVED_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ShopifyAPI::ResourceFeedback::ExistingFeedbackSaved
end

class ShopifyAPI::ResourceFeedback::ExistingFeedbackSaved
end

class ShopifyAPI::ResourceFeedback
  extend ::ShopifyAPI::DisablePrefixCheck::ClassMethods
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::Rule
end

class ShopifyAPI::Rule
end

class ShopifyAPI::ScriptTag
end

class ShopifyAPI::ScriptTag
end

class ShopifyAPI::Session
  def api_key(); end

  def api_key=(obj); end

  def api_version(); end

  def api_version=(version); end

  def create_permission_url(scope, redirect_uri, options=T.unsafe(nil)); end

  def domain(); end

  def domain=(domain); end

  def expired?(); end

  def expires_at(); end

  def expires_in(); end

  def extra(); end

  def extra=(extra); end

  def initialize(domain:, token:, api_version:, extra: T.unsafe(nil)); end

  def myshopify_domain(); end

  def myshopify_domain=(obj); end

  def name(); end

  def name=(name); end

  def request_token(params); end

  def secret(); end

  def secret=(obj); end

  def shop(); end

  def site(); end

  def token(); end

  def token=(token); end

  def url(); end

  def valid?(); end
end

class ShopifyAPI::Session
  def self.api_key(); end

  def self.api_key=(obj); end

  def self.myshopify_domain(); end

  def self.myshopify_domain=(obj); end

  def self.prepare_domain(domain); end

  def self.secret(); end

  def self.secret=(obj); end

  def self.setup(params); end

  def self.temp(domain:, token:, api_version:, &block); end

  def self.validate_signature(params); end

  def self.with_session(session, &_block); end

  def self.with_version(api_version, &block); end
end

class ShopifyAPI::ShippingAddress
end

class ShopifyAPI::ShippingAddress
end

class ShopifyAPI::ShippingLine
end

class ShopifyAPI::ShippingLine
end

class ShopifyAPI::ShippingRate
end

class ShopifyAPI::ShippingRate
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::ShippingZone
end

class ShopifyAPI::ShippingZone
end

class ShopifyAPI::Shop
  include ::ActiveResource::Singleton
  def add_metafield(metafield); end

  def events(); end

  def metafields(**options); end
end

class ShopifyAPI::Shop
  extend ::ActiveResource::Singleton::ClassMethods
  def self.current(options=T.unsafe(nil)); end
end

class ShopifyAPI::SmartCollection
  include ::ShopifyAPI::Events
  include ::ShopifyAPI::Metafields
  def order(options=T.unsafe(nil)); end

  def products(options=T.unsafe(nil)); end
end

class ShopifyAPI::SmartCollection
end

class ShopifyAPI::StorefrontAccessToken
end

class ShopifyAPI::StorefrontAccessToken
end

class ShopifyAPI::TaxLine
end

class ShopifyAPI::TaxLine
end

class ShopifyAPI::TaxService
end

class ShopifyAPI::TaxService
end

class ShopifyAPI::TenderTransaction
end

class ShopifyAPI::TenderTransaction
end

class ShopifyAPI::Theme
end

class ShopifyAPI::Theme
end

class ShopifyAPI::Transaction
  def order_id(); end
end

class ShopifyAPI::Transaction
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::UsageCharge
  def recurring_application_charge_id(); end
end

class ShopifyAPI::UsageCharge
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::User
end

class ShopifyAPI::User
end

class ShopifyAPI::ValidationException
end

class ShopifyAPI::ValidationException
end

class ShopifyAPI::Variant
  include ::ShopifyAPI::Metafields
  include ::ShopifyAPI::DisablePrefixCheck
  def inventory_quantity=(new_value); end

  def inventory_quantity_adjustment=(new_value); end

  def old_inventory_quantity=(new_value); end

  def product_id(); end
end

class ShopifyAPI::Variant
  extend ::ShopifyAPI::DisablePrefixCheck::ClassMethods
  def self.resource_prefix(options=T.unsafe(nil)); end
end

class ShopifyAPI::Webhook
end

class ShopifyAPI::Webhook
end

module ShopifyAPI
  extend ::ShopifyAPI::Limits::ClassMethods
end

module ShopifyApp::AppProxyVerification
  extend ::ActiveSupport::Concern
end

module ShopifyApp::Authenticated
  extend ::ActiveSupport::Concern
end

class ShopifyApp::AuthenticatedController
  include ::ShopifyApp::Localization
  include ::ShopifyApp::LoginProtection
  include ::ShopifyApp::Itp
  include ::ShopifyApp::EmbeddedApp
end

class ShopifyApp::Configuration
  def after_authenticate_job(); end

  def after_authenticate_job=(after_authenticate_job); end

  def api_key(); end

  def api_key=(api_key); end

  def api_version(); end

  def api_version=(api_version); end

  def application_name(); end

  def application_name=(application_name); end

  def disable_webpacker(); end

  def disable_webpacker=(disable_webpacker); end

  def embedded_app(); end

  def embedded_app=(embedded_app); end

  def embedded_app?(); end

  def enable_same_site_none(); end

  def enable_same_site_none=(enable_same_site_none); end

  def has_scripttags?(); end

  def has_webhooks?(); end

  def login_url(); end

  def login_url=(login_url); end

  def myshopify_domain(); end

  def myshopify_domain=(myshopify_domain); end

  def old_secret(); end

  def old_secret=(old_secret); end

  def root_url(); end

  def root_url=(root_url); end

  def scope(); end

  def scope=(scope); end

  def scripttags(); end

  def scripttags=(scripttags); end

  def scripttags_manager_queue_name(); end

  def scripttags_manager_queue_name=(scripttags_manager_queue_name); end

  def secret(); end

  def secret=(secret); end

  def shop_session_repository(); end

  def shop_session_repository=(klass); end

  def user_session_repository(); end

  def user_session_repository=(klass); end

  def webhook_jobs_namespace(); end

  def webhook_jobs_namespace=(webhook_jobs_namespace); end

  def webhooks(); end

  def webhooks=(webhooks); end

  def webhooks_manager_queue_name(); end

  def webhooks_manager_queue_name=(webhooks_manager_queue_name); end
end

class ShopifyApp::Configuration
end

module ShopifyApp::EmbeddedApp
  extend ::ActiveSupport::Concern
end

class ShopifyApp::Engine
end

class ShopifyApp::Generators::AddAfterAuthenticateJobGenerator
  def _invoke_from_option_test_framework(); end
end

class ShopifyApp::Generators::AddMarketingActivityExtensionGenerator
end

class ShopifyApp::Generators::AddWebhookGenerator
  def _invoke_from_option_test_framework(); end
end

class ShopifyApp::Generators::AppProxyControllerGenerator
end

class ShopifyApp::Generators::AuthenticatedControllerGenerator
end

class ShopifyApp::Generators::ControllersGenerator
end

class ShopifyApp::Generators::HomeControllerGenerator
end

class ShopifyApp::Generators::InstallGenerator
  include ::Rails::Generators::Migration
end

class ShopifyApp::Generators::RotateShopifyTokenJobGenerator
end

class ShopifyApp::Generators::RoutesGenerator
end

class ShopifyApp::Generators::ShopModelGenerator
  include ::Rails::Generators::Migration
end

class ShopifyApp::Generators::ShopifyAppGenerator
end

class ShopifyApp::Generators::UserModelGenerator
  include ::Rails::Generators::Migration
end

class ShopifyApp::Generators::ViewsGenerator
end

module ShopifyApp::Localization
  extend ::ActiveSupport::Concern
end

module ShopifyApp::LoginProtection
  extend ::ActiveSupport::Concern
end

class ShopifyApp::MissingWebhookJobError
end

class ShopifyApp::MissingWebhookJobError
end

class ShopifyApp::ScripttagsManagerJob
end

module ShopifyApp::SessionStorage
  extend ::ActiveSupport::Concern
end

class ShopifyApp::SessionsController
  include ::ActionView::Layouts::ClassMethods::LayoutConditions
end

module ShopifyApp::ShopSessionStorage
  extend ::ActiveSupport::Concern
end

module ShopifyApp::UserSessionStorage::ClassMethods
  def retrieve(id); end

  def store(auth_session, user); end
end

module ShopifyApp::UserSessionStorage::ClassMethods
end

module ShopifyApp::UserSessionStorage
  extend ::ActiveSupport::Concern
end

module ShopifyApp::WebhookVerification
  extend ::ActiveSupport::Concern
end

class ShopifyApp::WebhooksController
  include ::ShopifyApp::WebhookVerification
end

class ShopifyApp::WebhooksManagerJob
end

module ShopifyApp
  def self.configuration(); end

  def self.configuration=(config); end

  def self.configure(); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class SignalException
  def signm(); end

  def signo(); end
end

class SignedGlobalID
  def expires_at(); end

  def purpose(); end

  def to_h(); end

  def to_s(); end

  def verifier(); end
end

class SignedGlobalID::ExpiredMessage
end

class SignedGlobalID::ExpiredMessage
end

class SignedGlobalID
  def self.expires_in(); end

  def self.expires_in=(expires_in); end

  def self.parse(sgid, options=T.unsafe(nil)); end

  def self.pick_purpose(options); end

  def self.pick_verifier(options); end

  def self.verifier(); end

  def self.verifier=(verifier); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

module SourceAnnotationExtractor
end

module SourceAnnotationExtractor
end

module Sprockets
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::AddSourceMapCommentToAssetProcessor
end

class Sprockets::AddSourceMapCommentToAssetProcessor
  def self.call(input); end
end

class Sprockets::ArgumentError
end

class Sprockets::ArgumentError
end

class Sprockets::Asset
  def ==(other); end

  def base64digest(); end

  def bytesize(); end

  def charset(); end

  def content_type(); end

  def digest(); end

  def digest_path(); end

  def each(&blk); end

  def eql?(other); end

  def etag(); end

  def filename(); end

  def full_digest_path(); end

  def hexdigest(); end

  def id(); end

  def initialize(attributes=T.unsafe(nil)); end

  def integrity(); end

  def length(); end

  def links(); end

  def logical_path(); end

  def metadata(); end

  def source(); end

  def to_hash(); end

  def uri(); end

  def write_to(filename); end
end

class Sprockets::Asset
end

module Sprockets::Autoload
end

module Sprockets::Autoload
end

class Sprockets::BabelProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::BabelProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::Base
  include ::Sprockets::SourceMapUtils
  include ::Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Exporting
  include ::Sprockets::Server
  include ::Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::Bower
  include ::Sprockets::Npm
  def [](*args); end

  def cache(); end

  def cache=(cache); end

  def cached(); end

  def compress_from_root(uri); end

  def expand_from_root(uri); end

  def find_all_linked_assets(*args); end

  def find_asset(*args, **options); end

  def find_asset!(*args); end

  def index(); end
end

class Sprockets::Base
end

module Sprockets::Bower
  def read_bower_main(dirname, filename); end

  def resolve_alternates(load_path, logical_path); end
  POSSIBLE_BOWER_JSONS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Bower
end

class Sprockets::Bundle
end

class Sprockets::Bundle
  def self.call(input); end

  def self.dedup(required); end

  def self.process_bundle_reducers(input, assets, reducers); end
end

class Sprockets::Cache
  def clear(options=T.unsafe(nil)); end

  def fetch(key); end

  def get(key, local=T.unsafe(nil)); end

  def initialize(cache=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value, local=T.unsafe(nil)); end
  PEEK_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def initialize(root, max_size=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
  EXCLUDED_DIRS = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def self.default_logger(); end
end

class Sprockets::Cache::GetWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::GetWrapper
end

class Sprockets::Cache::HashWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::HashWrapper
end

class Sprockets::Cache::MemoryStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def initialize(max_size=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::MemoryStore
end

class Sprockets::Cache::NullStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::NullStore
end

class Sprockets::Cache::ReadWriteWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::ReadWriteWrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache
  def self.default_logger(); end
end

class Sprockets::CachedEnvironment
  def initialize(environment); end

  def processor_cache_key(str); end
end

class Sprockets::CachedEnvironment
end

class Sprockets::ClosureCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::ClosureCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets::CoffeeScriptProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::Compressing
  include ::Sprockets::Utils
  def compressors(); end

  def css_compressor(); end

  def css_compressor=(compressor); end

  def gzip=(gzip); end

  def gzip?(); end

  def js_compressor(); end

  def js_compressor=(compressor); end

  def register_compressor(mime_type, sym, klass); end

  def skip_gzip?(); end
end

module Sprockets::Compressing
end

module Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Exporting
  include ::Sprockets::Processing
  include ::Sprockets::Transformers
  include ::Sprockets::Mime
  include ::Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def config(); end

  def config=(config); end

  def context_class(); end

  def digest_class(); end

  def digest_class=(klass); end

  def initialize_configuration(parent); end

  def logger(); end

  def logger=(logger); end

  def version(); end

  def version=(version); end
end

module Sprockets::Configuration
end

class Sprockets::ContentTypeMismatch
end

class Sprockets::ContentTypeMismatch
end

class Sprockets::Context
  def asset_data_uri(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def base64_asset_data_uri(asset); end

  def content_type(); end

  def depend_on(path); end

  def depend_on_asset(path); end

  def depend_on_env(key); end

  def env_proxy(); end

  def environment(); end

  def filename(); end

  def font_path(path); end

  def image_path(path); end

  def initialize(input); end

  def javascript_path(path); end

  def link_asset(path); end

  def load(uri); end

  def load_path(); end

  def logical_path(); end

  def metadata(); end

  def optimize_quoted_uri_escapes!(escaped); end

  def optimize_svg_for_uri_escaping!(svg); end

  def require_asset(path); end

  def resolve(path, **kargs); end

  def root_path(); end

  def stub_asset(path); end

  def stylesheet_path(path); end

  def svg_asset_data_uri(asset); end

  def video_path(path); end
end

class Sprockets::Context::ENVProxy
  def [](key); end

  def fetch(key, *_); end

  def initialize(context); end
end

class Sprockets::Context::ENVProxy
end

class Sprockets::Context
end

class Sprockets::ConversionError
end

class Sprockets::ConversionError
end

module Sprockets::Dependencies
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def add_dependency(uri); end

  def depend_on(uri); end

  def dependencies(); end

  def dependency_resolvers(); end

  def register_dependency_resolver(scheme, &block); end

  def resolve_dependency(str); end
end

module Sprockets::Dependencies
end

module Sprockets::DigestUtils
  def detect_digest_class(bytes); end

  def digest(obj); end

  def digest_class(); end

  def hexdigest(obj); end

  def hexdigest_integrity_uri(hexdigest); end

  def integrity_uri(digest); end

  def pack_base64digest(bin); end

  def pack_hexdigest(bin); end

  def pack_urlsafe_base64digest(bin); end

  def unpack_hexdigest(hex); end
  DIGEST_SIZES = ::T.let(nil, ::T.untyped)
  HASH_ALGORITHMS = ::T.let(nil, ::T.untyped)
end

module Sprockets::DigestUtils
  extend ::Sprockets::DigestUtils
end

class Sprockets::DirectiveProcessor
  def _call(input); end

  def call(input); end

  def compile_header_pattern(comments); end

  def extract_directives(header); end

  def initialize(comments: T.unsafe(nil)); end

  def process_depend_on_asset_directive(path); end

  def process_depend_on_directive(path); end

  def process_directives(directives); end

  def process_link_directive(path); end

  def process_link_directory_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_link_tree_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_require_directive(path); end

  def process_require_directory_directive(path=T.unsafe(nil)); end

  def process_require_self_directive(); end

  def process_require_tree_directive(path=T.unsafe(nil)); end

  def process_source(source); end

  def process_stub_directive(path); end
  DIRECTIVE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Sprockets::DirectiveProcessor
  def self.call(input); end

  def self.instance(); end
end

class Sprockets::DoubleLinkError
  def initialize(parent_filename:, logical_path:, last_filename:, filename:); end
end

class Sprockets::DoubleLinkError
end

class Sprockets::ERBProcessor
  def call(input); end

  def initialize(&block); end
end

class Sprockets::ERBProcessor
  def self.call(input); end

  def self.instance(); end
end

module Sprockets::EcoProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::EjsProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::EncodingUtils
  def base64(str); end

  def charlock_detect(str); end

  def deflate(str); end

  def detect(str); end

  def detect_css(str); end

  def detect_html(str); end

  def detect_unicode(str); end

  def detect_unicode_bom(str); end

  def gzip(str); end

  def scan_css_charset(str); end

  def unmarshaled_deflated(str, window_bits=T.unsafe(nil)); end
  BOM = ::T.let(nil, ::T.untyped)
  CHARSET_DETECT = ::T.let(nil, ::T.untyped)
  CHARSET_SIZE = ::T.let(nil, ::T.untyped)
  CHARSET_START = ::T.let(nil, ::T.untyped)
end

module Sprockets::EncodingUtils
  extend ::Sprockets::EncodingUtils
end

class Sprockets::Environment
  def find_all_linked_assets(*args, &block); end

  def initialize(root=T.unsafe(nil)); end

  def load(*args); end
end

class Sprockets::Environment
end

class Sprockets::Error
end

class Sprockets::Error
end

module Sprockets::Exporters
end

class Sprockets::Exporters::Base
  def asset(); end

  def call(); end

  def directory(); end

  def environment(); end

  def initialize(asset: T.unsafe(nil), environment: T.unsafe(nil), directory: T.unsafe(nil)); end

  def setup(); end

  def skip?(logger); end

  def target(); end

  def write(filename=T.unsafe(nil)); end
end

class Sprockets::Exporters::Base
end

class Sprockets::Exporters::FileExporter
end

class Sprockets::Exporters::FileExporter
end

class Sprockets::Exporters::ZlibExporter
end

class Sprockets::Exporters::ZlibExporter
end

class Sprockets::Exporters::ZopfliExporter
end

class Sprockets::Exporters::ZopfliExporter
end

module Sprockets::Exporters
end

module Sprockets::Exporting
  def export_concurrent(); end

  def export_concurrent=(export_concurrent); end

  def exporters(); end

  def register_exporter(mime_types, klass=T.unsafe(nil)); end

  def unregister_exporter(mime_types, exporter=T.unsafe(nil)); end
end

module Sprockets::Exporting
end

class Sprockets::FileNotFound
end

class Sprockets::FileNotFound
end

class Sprockets::FileOutsidePaths
end

class Sprockets::FileOutsidePaths
end

class Sprockets::FileReader
end

class Sprockets::FileReader
  def self.call(input); end
end

module Sprockets::HTTPUtils
  def find_best_mime_type_match(q_value_header, available); end

  def find_best_q_match(q_values, available, &matcher); end

  def find_mime_type_matches(q_value_header, available); end

  def find_q_matches(q_values, available, &matcher); end

  def match_mime_type?(value, matcher); end

  def match_mime_type_keys(hash, mime_type); end

  def parse_q_values(values); end
end

module Sprockets::HTTPUtils
  extend ::Sprockets::HTTPUtils
end

class Sprockets::JSMincCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::JSMincCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::JstProcessor
  def call(input); end

  def initialize(namespace: T.unsafe(nil)); end
end

class Sprockets::JstProcessor
  def self.call(input); end

  def self.default_namespace(); end

  def self.instance(); end
end

module Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  def load(uri); end
end

module Sprockets::Loader
end

class Sprockets::Manifest
  include ::Sprockets::ManifestUtils
  def assets(); end

  def clean(count=T.unsafe(nil), age=T.unsafe(nil)); end

  def clobber(); end

  def compile(*args); end

  def dir(); end

  def directory(); end

  def environment(); end

  def filename(); end

  def files(); end

  def find(*args); end

  def find_sources(*args); end

  def initialize(*args); end

  def path(); end

  def remove(filename); end

  def save(); end
end

class Sprockets::Manifest
end

module Sprockets::ManifestUtils
  def find_directory_manifest(dirname, logger=T.unsafe(nil)); end

  def generate_manifest_path(); end
  MANIFEST_RE = ::T.let(nil, ::T.untyped)
end

module Sprockets::ManifestUtils
  extend ::Sprockets::ManifestUtils
end

module Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::HTTPUtils
  def mime_exts(); end

  def mime_type_charset_detecter(mime_type); end

  def mime_types(); end

  def read_file(filename, content_type=T.unsafe(nil)); end

  def register_mime_type(mime_type, extensions: T.unsafe(nil), charset: T.unsafe(nil)); end
end

module Sprockets::Mime
end

class Sprockets::NotFound
end

class Sprockets::NotFound
end

class Sprockets::NotImplementedError
end

class Sprockets::NotImplementedError
end

module Sprockets::Npm
  def read_package_directives(dirname, filename); end

  def resolve_alternates(load_path, logical_path); end
end

module Sprockets::Npm
end

module Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
  def entries_with_dependencies(path); end

  def stat_directory_with_dependencies(dir); end

  def stat_sorted_tree_with_dependencies(dir); end
end

module Sprockets::PathDependencyUtils
end

module Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def file_digest(path); end

  def files_digest(paths); end

  def stat_digest(path, stat); end
end

module Sprockets::PathDigestUtils
end

module Sprockets::PathUtils
  def absolute_path?(path); end

  def atomic_write(filename); end

  def directory?(path); end

  def entries(path); end

  def file?(path); end

  def find_matching_path_for_extensions(path, basename, extensions); end

  def find_upwards(basename, path, root=T.unsafe(nil)); end

  def join(base, path); end

  def match_path_extname(path, extensions); end

  def path_extnames(path); end

  def path_parents(path, root=T.unsafe(nil)); end

  def paths_split(paths, filename); end

  def relative_path?(path); end

  def relative_path_from(start, dest); end

  def set_pipeline(path, mime_exts, pipeline_exts, pipeline); end

  def split_subpath(path, subpath); end

  def stat(path); end

  def stat_directory(dir); end

  def stat_sorted_tree(dir, &block); end

  def stat_tree(dir, &block); end
  SEPARATOR_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::PathUtils
  extend ::Sprockets::PathUtils
end

module Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::PathUtils
  def append_path(path); end

  def clear_paths(); end

  def each_file(); end

  def paths(); end

  def prepend_path(path); end

  def root(); end
end

module Sprockets::Paths
end

module Sprockets::Preprocessors
end

class Sprockets::Preprocessors::DefaultSourceMap
  def call(input); end
end

class Sprockets::Preprocessors::DefaultSourceMap
end

module Sprockets::Preprocessors
end

module Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  def build_processors_uri(type, file_type, pipeline); end

  def bundle_processors(); end

  def default_processors_for(type, file_type); end

  def pipelines(); end

  def postprocessors(); end

  def preprocessors(); end

  def processors(); end

  def processors_for(type, file_type, pipeline); end

  def register_bundle_metadata_reducer(mime_type, key, *args, &block); end

  def register_bundle_processor(*args, &block); end

  def register_pipeline(name, proc=T.unsafe(nil), &block); end

  def register_postprocessor(*args, &block); end

  def register_preprocessor(*args, &block); end

  def register_processor(*args, &block); end

  def resolve_processors_cache_key_uri(uri); end

  def self_processors_for(type, file_type); end

  def unregister_bundle_processor(*args); end

  def unregister_postprocessor(*args); end

  def unregister_preprocessor(*args); end

  def unregister_processor(*args); end
end

module Sprockets::Processing
end

module Sprockets::ProcessorUtils
  def call_processor(processor, input); end

  def call_processors(processors, input); end

  def compose_processors(*processors); end

  def processor_cache_key(processor); end

  def processors_cache_keys(processors); end

  def validate_processor_result!(result); end
  VALID_METADATA_COMPOUND_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_COMPOUND_TYPES_HASH = ::T.let(nil, ::T.untyped)
  VALID_METADATA_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES_HASH = ::T.let(nil, ::T.untyped)
end

class Sprockets::ProcessorUtils::CompositeProcessor
  def cache_key(); end

  def call(input); end
  PLURAL = ::T.let(nil, ::T.untyped)
  SINGULAR = ::T.let(nil, ::T.untyped)
end

class Sprockets::ProcessorUtils::CompositeProcessor
  def self.create(processors); end
end

module Sprockets::ProcessorUtils
  extend ::Sprockets::ProcessorUtils
end

module Sprockets::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Context
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def compute_asset_path(path, options=T.unsafe(nil)); end
end

module Sprockets::Rails::Context
  def self.included(klass); end
end

module Sprockets::Rails::Helper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::Sprockets::Rails::Utils
  def asset_digest_path(path, options=T.unsafe(nil)); end

  def asset_integrity(path, options=T.unsafe(nil)); end

  def asset_resolver_strategies(); end

  def compute_asset_path(path, options=T.unsafe(nil)); end

  def compute_integrity?(options); end

  def javascript_include_tag(*sources); end

  def legacy_debug_path(path, debug); end

  def lookup_debug_asset(path, options=T.unsafe(nil)); end

  def path_with_extname(path, options); end

  def request_debug_assets?(); end

  def resolve_asset(); end

  def resolve_asset_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def secure_subresource_integrity_context?(); end

  def stylesheet_link_tag(*sources); end
  VIEW_ACCESSORS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Helper
  def self.extended(obj); end

  def self.included(klass); end
end

module Sprockets::Rails::HelperAssetResolvers
end

class Sprockets::Rails::HelperAssetResolvers::Environment
  def asset_path(path, digest, allow_non_precompiled=T.unsafe(nil)); end

  def digest_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def find_debug_asset(path); end

  def initialize(view); end

  def integrity(path); end
end

class Sprockets::Rails::HelperAssetResolvers::Environment
end

class Sprockets::Rails::HelperAssetResolvers::Manifest
  def asset_path(path, digest, allow_non_precompiled=T.unsafe(nil)); end

  def digest_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def find_debug_asset(path); end

  def initialize(view); end

  def integrity(path); end
end

class Sprockets::Rails::HelperAssetResolvers::Manifest
end

module Sprockets::Rails::HelperAssetResolvers
  def self.[](name); end
end

class Sprockets::Rails::QuietAssets
  def call(env); end

  def initialize(app); end
end

class Sprockets::Rails::QuietAssets
end

module Sprockets::Rails::RouteWrapper
  def internal?(); end

  def internal_assets_path?(); end
end

module Sprockets::Rails::RouteWrapper
  def self.included(klass); end
end

module Sprockets::Rails::Utils
  def using_sprockets4?(); end
end

module Sprockets::Rails::Utils
end

module Sprockets::Rails
end

class Sprockets::Railtie
  include ::Sprockets::Rails::Utils
  def build_environment(app, initialized=T.unsafe(nil)); end
  LOOSE_APP_ASSETS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Railtie::ManifestNeededError
  def initialize(); end
end

class Sprockets::Railtie::ManifestNeededError
end

class Sprockets::Railtie::OrderedOptions
  def configure(&block); end
end

class Sprockets::Railtie::OrderedOptions
end

class Sprockets::Railtie
  def self.build_manifest(app); end
end

module Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
  include ::Sprockets::HTTPUtils
  def parse_accept_options(mime_type, explicit_type); end

  def resolve(path, load_paths: T.unsafe(nil), accept: T.unsafe(nil), pipeline: T.unsafe(nil), base_path: T.unsafe(nil)); end

  def resolve!(path, **kargs); end

  def resolve_absolute_path(paths, filename, accept); end

  def resolve_alternates(load_path, logical_name); end

  def resolve_alts_under_path(load_path, logical_name, mime_exts); end

  def resolve_asset_uri(uri); end

  def resolve_index_under_path(load_path, logical_name, mime_exts); end

  def resolve_logical_path(paths, logical_path, accept); end

  def resolve_main_under_path(load_path, logical_name, mime_exts); end

  def resolve_relative_path(paths, path, dirname, accept); end

  def resolve_under_paths(paths, logical_name, accepts); end
end

module Sprockets::Resolve
end

class Sprockets::SassCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::SassCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::SasscCompressor
  def call(input); end

  def initialize(options=T.unsafe(nil)); end
end

class Sprockets::SasscCompressor
  def self.call(input); end

  def self.instance(); end
end

class Sprockets::SasscProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil), &block); end
end

module Sprockets::SasscProcessor::Functions
  def asset_data_url(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def asset_url(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def audio_url(path); end

  def font_path(path); end

  def font_url(path); end

  def image_path(path); end

  def image_url(path); end

  def javascript_path(path); end

  def javascript_url(path); end

  def sprockets_context(); end

  def sprockets_dependencies(); end

  def sprockets_environment(); end

  def stylesheet_path(path); end

  def stylesheet_url(path); end

  def video_path(path); end

  def video_url(path); end
end

module Sprockets::SasscProcessor::Functions
end

class Sprockets::SasscProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end

  def self.syntax(); end
end

class Sprockets::ScsscProcessor
end

class Sprockets::ScsscProcessor
end

module Sprockets::Server
  def call(env); end
  ALLOWED_REQUEST_METHODS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Server
end

class Sprockets::SourceMapProcessor
end

class Sprockets::SourceMapProcessor
  def self.call(input); end

  def self.original_content_type(source_map_content_type, error_when_not_found: T.unsafe(nil)); end
end

module Sprockets::SourceMapUtils
  def bsearch_mappings(mappings, offset, from=T.unsafe(nil), to=T.unsafe(nil)); end

  def combine_source_maps(first, second); end

  def compare_source_offsets(a, b); end

  def concat_source_maps(a, b); end

  def decode_source_map(map); end

  def decode_vlq_mappings(str, sources: T.unsafe(nil), names: T.unsafe(nil)); end

  def encode_source_map(map); end

  def encode_vlq_mappings(mappings, sources: T.unsafe(nil), names: T.unsafe(nil)); end

  def format_source_map(map, input); end

  def make_index_map(map); end

  def vlq_decode(str); end

  def vlq_decode_mappings(str); end

  def vlq_encode(ary); end

  def vlq_encode_mappings(ary); end
  BASE64_DIGITS = ::T.let(nil, ::T.untyped)
  BASE64_VALUES = ::T.let(nil, ::T.untyped)
  VLQ_BASE = ::T.let(nil, ::T.untyped)
  VLQ_BASE_MASK = ::T.let(nil, ::T.untyped)
  VLQ_BASE_SHIFT = ::T.let(nil, ::T.untyped)
  VLQ_CONTINUATION_BIT = ::T.let(nil, ::T.untyped)
end

module Sprockets::SourceMapUtils
  extend ::Sprockets::SourceMapUtils
end

module Sprockets::Transformers
  include ::Sprockets::Utils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  def compose_transformers(transformers, types, preprocessors, postprocessors); end

  def expand_transform_accepts(parsed_accepts); end

  def register_transformer(from, to, proc); end

  def register_transformer_suffix(types, type_format, extname, processor); end

  def resolve_transform_type(type, accept); end

  def transformers(); end
end

class Sprockets::Transformers::Transformer
  def from(); end

  def from=(_); end

  def proc=(_); end

  def to(); end

  def to=(_); end
end

class Sprockets::Transformers::Transformer
  def self.[](*_); end

  def self.members(); end
end

module Sprockets::Transformers
end

class Sprockets::URITar
  def absolute_path?(); end

  def compress(); end

  def compressed_path(); end

  def expand(); end

  def initialize(uri, env); end

  def path(); end

  def root(); end

  def scheme(); end
end

class Sprockets::URITar
end

module Sprockets::URIUtils
  def build_asset_uri(path, params=T.unsafe(nil)); end

  def build_file_digest_uri(path); end

  def encode_uri_query_params(params); end

  def join_file_uri(scheme, host, path, query); end

  def join_uri(scheme, userinfo, host, port, registry, path, opaque, query, fragment); end

  def parse_asset_uri(uri); end

  def parse_file_digest_uri(uri); end

  def parse_uri_query_params(query); end

  def split_file_uri(uri); end

  def split_uri(uri); end

  def valid_asset_uri?(str); end
end

module Sprockets::URIUtils
  extend ::Sprockets::URIUtils
end

class Sprockets::UglifierCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::UglifierCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::UnloadedAsset
  def asset_key(); end

  def compressed_path(); end

  def dependency_history_key(); end

  def digest_key(digest); end

  def file_digest_key(stat); end

  def filename(); end

  def initialize(uri, env); end

  def params(); end

  def uri(); end
end

class Sprockets::UnloadedAsset
end

module Sprockets::Utils
  def concat_javascript_sources(buf, source); end

  def dfs(initial); end

  def dfs_paths(path); end

  def duplicable?(obj); end

  def hash_reassoc(hash, key_a, key_b=T.unsafe(nil), &block); end

  def hash_reassoc1(hash, key); end

  def module_include(base, mod); end

  def string_end_with_semicolon?(str); end
end

class Sprockets::Utils::Gzip
  def archiver(); end

  def can_compress?(); end

  def cannot_compress?(); end

  def charset(); end

  def compress(file, target); end

  def content_type(); end

  def initialize(asset, archiver: T.unsafe(nil)); end

  def source(); end
  COMPRESSABLE_MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Sprockets::Utils::Gzip::ZlibArchiver
end

module Sprockets::Utils::Gzip::ZlibArchiver
  def self.call(file, source, mtime); end
end

module Sprockets::Utils::Gzip::ZopfliArchiver
end

module Sprockets::Utils::Gzip::ZopfliArchiver
  def self.call(file, source, mtime); end
end

class Sprockets::Utils::Gzip
end

module Sprockets::Utils
  extend ::Sprockets::Utils
end

class Sprockets::YUICompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::YUICompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets
  extend ::Sprockets::Configuration
  extend ::Sprockets::Dependencies
  extend ::Sprockets::Compressing
  extend ::Sprockets::Exporting
  extend ::Sprockets::Processing
  extend ::Sprockets::Transformers
  extend ::Sprockets::Mime
  extend ::Sprockets::Paths
  extend ::Sprockets::Utils
  extend ::Sprockets::URIUtils
  extend ::Sprockets::PathDigestUtils
  extend ::Sprockets::ProcessorUtils
  extend ::Sprockets::HTTPUtils
  extend ::Sprockets::PathUtils
  extend ::Sprockets::DigestUtils
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def ext(newext=T.unsafe(nil)); end

  def grapheme_clusters(); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def to_blob(); end

  def to_d(); end

  def truncate_bytes(truncate_at, omission: T.unsafe(nil)); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

class Struct::HTMLElementDescription
  def attrs_depr(); end

  def attrs_depr=(_); end

  def attrs_opt(); end

  def attrs_opt=(_); end

  def attrs_req(); end

  def attrs_req=(_); end

  def defaultsubelt(); end

  def defaultsubelt=(_); end

  def depr(); end

  def depr=(_); end

  def desc(); end

  def desc=(_); end

  def dtd(); end

  def dtd=(_); end

  def empty(); end

  def empty=(_); end

  def endTag(); end

  def endTag=(_); end

  def isinline(); end

  def isinline=(_); end

  def name(); end

  def name=(_); end

  def saveEndTag(); end

  def saveEndTag=(_); end

  def startTag(); end

  def startTag=(_); end

  def subelts(); end

  def subelts=(_); end
end

class Struct::HTMLElementDescription
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class StubSocket
  def close(); end

  def closed?(); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def initialize(*args); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def readuntil(*args); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class StubSocket
end

class SubstitutionContext
  def match(matches, attribute, matcher); end

  def substitute!(selector, values, format_for_presentation=T.unsafe(nil)); end
end

class SubstitutionContext
end

class SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
end

class SynchronizedDelegator
end

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

module TZInfo
end

class TZInfo::AmbiguousTime
end

class TZInfo::AmbiguousTime
end

class TZInfo::Country
  include ::Comparable
  def _dump(limit); end

  def code(); end

  def eql?(c); end

  def name(); end

  def zone_identifiers(); end

  def zone_info(); end

  def zone_names(); end

  def zones(); end
end

class TZInfo::Country
  def self._load(data); end

  def self.all(); end

  def self.all_codes(); end

  def self.data_source(); end

  def self.get(identifier); end

  def self.init_countries(); end

  def self.new(identifier); end
end

module TZInfo::CountryIndexDefinition
end

module TZInfo::CountryIndexDefinition::ClassMethods
  def countries(); end

  def country(code, name, &block); end
end

module TZInfo::CountryIndexDefinition::ClassMethods
end

module TZInfo::CountryIndexDefinition
  def self.append_features(base); end
end

class TZInfo::CountryInfo
  def code(); end

  def initialize(code, name); end

  def name(); end

  def zone_identifiers(); end

  def zones(); end
end

class TZInfo::CountryInfo
end

class TZInfo::CountryTimezone
  def ==(ct); end

  def description(); end

  def description_or_friendly_identifier(); end

  def eql?(ct); end

  def identifier(); end

  def initialize(identifier, latitude_numerator, latitude_denominator, longitude_numerator, longitude_denominator, description=T.unsafe(nil)); end

  def latitude(); end

  def longitude(); end

  def timezone(); end
end

class TZInfo::CountryTimezone
  def self.new(identifier, latitude, longitude, description=T.unsafe(nil)); end

  def self.new!(*_); end
end

class TZInfo::DataSource
  def country_codes(); end

  def data_timezone_identifiers(); end

  def linked_timezone_identifiers(); end

  def load_country_info(code); end

  def load_timezone_info(identifier); end

  def timezone_identifiers(); end
end

class TZInfo::DataSource
  def self.create_default_data_source(); end

  def self.get(); end

  def self.set(data_source_or_type, *args); end
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezoneInfo
  def period_for_utc(utc); end

  def periods_for_local(local); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end
end

class TZInfo::DataTimezoneInfo
end

class TZInfo::InfoTimezone
  def info(); end

  def setup(info); end
end

class TZInfo::InfoTimezone
  def self.new(info); end
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidZoneinfoDirectory
end

class TZInfo::InvalidZoneinfoDirectory
end

class TZInfo::InvalidZoneinfoFile
end

class TZInfo::InvalidZoneinfoFile
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezoneInfo
  def initialize(identifier, link_to_identifier); end

  def link_to_identifier(); end
end

class TZInfo::LinkedTimezoneInfo
end

class TZInfo::NoOffsetsDefined
end

class TZInfo::NoOffsetsDefined
end

module TZInfo::OffsetRationals
end

module TZInfo::OffsetRationals
  def self.rational_for_offset(offset); end
end

class TZInfo::PeriodNotFound
end

class TZInfo::PeriodNotFound
end

module TZInfo::RubyCoreSupport
  HALF_DAYS_IN_DAY = ::T.let(nil, ::T.untyped)
end

module TZInfo::RubyCoreSupport
  def self.datetime_new(y=T.unsafe(nil), m=T.unsafe(nil), d=T.unsafe(nil), h=T.unsafe(nil), min=T.unsafe(nil), s=T.unsafe(nil), of=T.unsafe(nil), sg=T.unsafe(nil)); end

  def self.datetime_new!(ajd=T.unsafe(nil), of=T.unsafe(nil), sg=T.unsafe(nil)); end

  def self.force_encoding(str, encoding); end

  def self.open_file(file_name, mode, opts, &block); end

  def self.rational_new!(numerator, denominator=T.unsafe(nil)); end

  def self.time_nsec(time); end

  def self.time_supports_64bit(); end

  def self.time_supports_negative(); end
end

class TZInfo::RubyCountryInfo
  def initialize(code, name, &block); end
end

class TZInfo::RubyCountryInfo::Zones
  def list(); end

  def timezone(identifier, latitude_numerator, latitude_denominator, longitude_numerator, longitude_denominator, description=T.unsafe(nil)); end
end

class TZInfo::RubyCountryInfo::Zones
end

class TZInfo::RubyCountryInfo
end

class TZInfo::RubyDataSource
end

class TZInfo::RubyDataSource
end

class TZInfo::TimeOrDateTime
  include ::Comparable
  def +(seconds); end

  def -(seconds); end

  def add_with_convert(seconds); end

  def day(); end

  def eql?(todt); end

  def hour(); end

  def initialize(timeOrDateTime); end

  def mday(); end

  def min(); end

  def mon(); end

  def month(); end

  def sec(); end

  def to_datetime(); end

  def to_i(); end

  def to_orig(); end

  def to_time(); end

  def usec(); end

  def year(); end
end

class TZInfo::TimeOrDateTime
  def self.wrap(timeOrDateTime); end
end

class TZInfo::Timezone
  include ::Comparable
  def _dump(limit); end

  def canonical_identifier(); end

  def canonical_zone(); end

  def current_period(); end

  def current_period_and_time(); end

  def current_time_and_period(); end

  def eql?(tz); end

  def friendly_identifier(skip_first_part=T.unsafe(nil)); end

  def identifier(); end

  def local_to_utc(local, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def offsets_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def period_for_local(local, dst=T.unsafe(nil)); end

  def period_for_utc(utc); end

  def periods_for_local(local); end

  def strftime(format, utc=T.unsafe(nil)); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def utc_to_local(utc); end
end

class TZInfo::Timezone
  def self._load(data); end

  def self.all(); end

  def self.all_country_zone_identifiers(); end

  def self.all_country_zones(); end

  def self.all_data_zone_identifiers(); end

  def self.all_data_zones(); end

  def self.all_identifiers(); end

  def self.all_linked_zone_identifiers(); end

  def self.all_linked_zones(); end

  def self.data_source(); end

  def self.default_dst(); end

  def self.default_dst=(value); end

  def self.get(identifier); end

  def self.get_proxies(identifiers); end

  def self.get_proxy(identifier); end

  def self.init_loaded_zones(); end

  def self.new(identifier=T.unsafe(nil)); end

  def self.us_zone_identifiers(); end

  def self.us_zones(); end
end

module TZInfo::TimezoneDefinition
end

module TZInfo::TimezoneDefinition::ClassMethods
  def get(); end

  def linked_timezone(identifier, link_to_identifier); end

  def timezone(identifier); end
end

module TZInfo::TimezoneDefinition::ClassMethods
end

module TZInfo::TimezoneDefinition
  def self.append_features(base); end
end

module TZInfo::TimezoneIndexDefinition
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
  def data_timezones(); end

  def linked_timezone(identifier); end

  def linked_timezones(); end

  def timezone(identifier); end

  def timezones(); end
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
end

module TZInfo::TimezoneIndexDefinition
  def self.append_features(base); end
end

class TZInfo::TimezoneInfo
  def create_timezone(); end

  def identifier(); end

  def initialize(identifier); end
end

class TZInfo::TimezoneInfo
end

class TZInfo::TimezoneOffset
  def ==(toi); end

  def abbreviation(); end

  def dst?(); end

  def eql?(toi); end

  def initialize(utc_offset, std_offset, abbreviation); end

  def std_offset(); end

  def to_local(utc); end

  def to_utc(local); end

  def utc_offset(); end

  def utc_total_offset(); end
end

class TZInfo::TimezoneOffset
end

class TZInfo::TimezonePeriod
  def ==(p); end

  def abbreviation(); end

  def dst?(); end

  def end_transition(); end

  def eql?(p); end

  def initialize(start_transition, end_transition, offset=T.unsafe(nil)); end

  def local_after_start?(local); end

  def local_before_end?(local); end

  def local_end(); end

  def local_end_time(); end

  def local_start(); end

  def local_start_time(); end

  def offset(); end

  def start_transition(); end

  def std_offset(); end

  def to_local(utc); end

  def to_utc(local); end

  def utc_after_start?(utc); end

  def utc_before_end?(utc); end

  def utc_end(); end

  def utc_end_time(); end

  def utc_offset(); end

  def utc_start(); end

  def utc_start_time(); end

  def utc_total_offset(); end

  def utc_total_offset_rational(); end

  def valid_for_local?(local); end

  def valid_for_utc?(utc); end

  def zone_identifier(); end
end

class TZInfo::TimezonePeriod
end

class TZInfo::TimezoneProxy
  def transitions_up_to(to, from=T.unsafe(nil)); end
end

class TZInfo::TimezoneProxy
  def self.new(identifier); end
end

class TZInfo::TimezoneTransition
  def ==(tti); end

  def at(); end

  def datetime(); end

  def eql?(tti); end

  def initialize(offset, previous_offset); end

  def local_end(); end

  def local_end_at(); end

  def local_end_time(); end

  def local_start(); end

  def local_start_at(); end

  def local_start_time(); end

  def offset(); end

  def previous_offset(); end

  def time(); end
end

class TZInfo::TimezoneTransition
end

class TZInfo::TimezoneTransitionDefinition
  def denominator(); end

  def initialize(offset, previous_offset, numerator_or_timestamp, denominator_or_numerator=T.unsafe(nil), denominator=T.unsafe(nil)); end

  def numerator_or_time(); end
end

class TZInfo::TimezoneTransitionDefinition
end

class TZInfo::TransitionDataTimezoneInfo
  def offset(id, utc_offset, std_offset, abbreviation); end

  def transition(year, month, offset_id, numerator_or_timestamp, denominator_or_numerator=T.unsafe(nil), denominator=T.unsafe(nil)); end
end

class TZInfo::TransitionDataTimezoneInfo
end

class TZInfo::UnknownTimezone
end

class TZInfo::UnknownTimezone
end

class TZInfo::ZoneinfoCountryInfo
  def initialize(code, name, zones); end
end

class TZInfo::ZoneinfoCountryInfo
end

class TZInfo::ZoneinfoDataSource
  def initialize(zoneinfo_dir=T.unsafe(nil), alternate_iso3166_tab_path=T.unsafe(nil)); end

  def zoneinfo_dir(); end
  DEFAULT_ALTERNATE_ISO3166_TAB_SEARCH_PATH = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATH = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoDataSource
  def self.alternate_iso3166_tab_search_path(); end

  def self.alternate_iso3166_tab_search_path=(alternate_iso3166_tab_search_path); end

  def self.process_search_path(path, default); end

  def self.search_path(); end

  def self.search_path=(search_path); end
end

class TZInfo::ZoneinfoDirectoryNotFound
end

class TZInfo::ZoneinfoDirectoryNotFound
end

class TZInfo::ZoneinfoTimezoneInfo
  def initialize(identifier, file_path); end
  MAX_TIMESTAMP = ::T.let(nil, ::T.untyped)
  MIN_TIMESTAMP = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoTimezoneInfo
end

module TZInfo
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Thor
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

module Thor::Actions
  def self.included(base); end
end

class Thor::AmbiguousCommandError
end

class Thor::AmbiguousCommandError
end

Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

class Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Argument
end

class Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Thor::Command
end

module Thor::CoreExt
end

class Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Thor::CoreExt::HashWithIndifferentAccess
end

module Thor::CoreExt
end

Thor::Correctable = DidYouMean::Correctable

class Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Thor::DynamicCommand
end

Thor::DynamicTask = Thor::DynamicCommand

class Thor::Error
end

class Thor::Error
end

class Thor::Group
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Thor::HiddenCommand
end

class Thor::HiddenCommand
end

Thor::HiddenTask = Thor::HiddenCommand

module Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Thor::Invocation
  def self.included(base); end
end

class Thor::InvocationError
end

class Thor::InvocationError
end

module Thor::LineEditor
end

class Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Thor::LineEditor::Basic
  def self.available?(); end
end

class Thor::LineEditor::Readline
end

class Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Thor::LineEditor::Readline::PathCompletion
end

class Thor::LineEditor::Readline
end

module Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Thor::MalformattedArgumentError
end

class Thor::MalformattedArgumentError
end

class Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Thor::NestedContext
end

class Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Thor::NoKwargSpellChecker
end

class Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Option
  def self.parse(key, value); end
end

class Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Thor::Options
  def self.to_switches(options); end
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Thor::RequiredArgumentMissingError
end

class Thor::RequiredArgumentMissingError
end

module Thor::Sandbox
end

module Thor::Sandbox
end

module Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Thor::Shell
end

Thor::Task = Thor::Command

class Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Thor::UndefinedCommandError::SpellChecker
end

class Thor::UndefinedCommandError
end

Thor::UndefinedTaskError = Thor::UndefinedCommandError

class Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Thor::UnknownArgumentError::SpellChecker
end

class Thor::UnknownArgumentError
end

module Thor::Util
end

module Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Thor
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

module ThreadSafe
  NULL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

ThreadSafe::Array = Array

class ThreadSafe::AtomicReferenceCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def empty?(); end

  def get_and_set(key, value); end

  def get_or_default(key, else_value=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
  DEFAULT_CAPACITY = ::T.let(nil, ::T.untyped)
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAX_CAPACITY = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  NOW_RESIZING = ::T.let(nil, ::T.untyped)
  TRANSFER_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  include ::ThreadSafe::Util::CheapLockable
  def initialize(hash, key, value, next_node=T.unsafe(nil)); end

  def key(); end

  def key?(key); end

  def locked?(); end

  def matches?(key, hash); end

  def pure_hash(); end

  def try_await_lock(table, i); end

  def try_lock_via_hash(node_hash=T.unsafe(nil)); end

  def unlock_via_hash(locked_hash, node_hash); end
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  SPIN_LOCK_ATTEMPTS = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  extend ::ThreadSafe::Util::Volatile
  def self.locked_hash?(hash); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
  def cas_new_node(i, hash, key, value); end

  def delete_node_at(i, node, predecessor_node); end

  def try_lock_via_hash(i, node, node_hash); end

  def try_to_cas_in_computed(i, hash, key); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
end

class ThreadSafe::AtomicReferenceCacheBackend
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Cache
  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def values(); end
end

class ThreadSafe::Cache
end

ThreadSafe::ConcurrentCacheBackend = ThreadSafe::MriCacheBackend

ThreadSafe::Hash = Hash

class ThreadSafe::MriCacheBackend
  WRITE_LOCK = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::MriCacheBackend
end

class ThreadSafe::NonConcurrentCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end

  def value?(value); end
end

class ThreadSafe::NonConcurrentCacheBackend
end

class ThreadSafe::SynchronizedCacheBackend
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ThreadSafe::SynchronizedCacheBackend
end

module ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Adder
  def add(x); end

  def decrement(); end

  def increment(); end

  def reset(); end

  def sum(); end
end

class ThreadSafe::Util::Adder
end

class ThreadSafe::Util::AtomicReference
  def compare_and_set(old_value, new_value); end

  def get(); end

  def initialize(value=T.unsafe(nil)); end

  def set(new_value); end

  def value(); end

  def value=(new_value); end
end

class ThreadSafe::Util::AtomicReference
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

module ThreadSafe::Util::CheapLockable
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::PowerOfTwoTuple
  def hash_to_index(hash); end

  def next_in_size_table(); end

  def volatile_get_by_hash(hash); end

  def volatile_set_by_hash(hash, value); end
end

class ThreadSafe::Util::PowerOfTwoTuple
end

class ThreadSafe::Util::Striped64
  def busy?(); end

  def initialize(); end

  def retry_update(x, hash_code, was_uncontended); end
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Striped64::Cell
  def cas(old_value, new_value); end

  def cas_computed(); end

  def padding_(); end
end

class ThreadSafe::Util::Striped64::Cell
end

class ThreadSafe::Util::Striped64
  extend ::ThreadSafe::Util::Volatile
end

module ThreadSafe::Util::Volatile
  def attr_volatile(*attr_names); end
end

module ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::VolatileTuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def initialize(size); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class ThreadSafe::Util::VolatileTuple
end

module ThreadSafe::Util::XorShiftRandom
  def get(); end

  def xorshift(x); end
  MAX_XOR_SHIFTABLE_INT = ::T.let(nil, ::T.untyped)
end

module ThreadSafe::Util::XorShiftRandom
  extend ::ThreadSafe::Util::XorShiftRandom
end

module ThreadSafe::Util
end

module ThreadSafe
end

module Threadsafe
end

module Threadsafe
  def self.const_missing(name); end
end

module ThreadsafeAttributes
end

module ThreadsafeAttributes::ClassMethods
  def threadsafe_attribute(*attrs); end
end

module ThreadsafeAttributes::ClassMethods
end

module ThreadsafeAttributes
  def self.included(klass); end
end

class Time
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::DateAndTime::Compatibility
  include ::Mocha::Inspect::TimeMethods
  def acts_like_time?(); end

  def ago(seconds); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_day(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def end_of_day(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def eql_with_coercion(other); end

  def eql_without_coercion(_); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def in(seconds); end

  def minus_with_coercion(other); end

  def minus_with_duration(other); end

  def minus_without_coercion(other); end

  def minus_without_duration(_); end

  def next_day(days=T.unsafe(nil)); end

  def next_month(months=T.unsafe(nil)); end

  def next_year(years=T.unsafe(nil)); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def prev_day(days=T.unsafe(nil)); end

  def prev_month(months=T.unsafe(nil)); end

  def prev_year(years=T.unsafe(nil)); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def sec_fraction(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def since(seconds); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Time
  def self.===(other); end

  def self.at_with_coercion(*args); end

  def self.at_without_coercion(*_); end

  def self.current(); end

  def self.days_in_month(month, year=T.unsafe(nil)); end

  def self.days_in_year(year=T.unsafe(nil)); end

  def self.find_zone(time_zone); end

  def self.find_zone!(time_zone); end

  def self.rfc3339(str); end

  def self.use_zone(time_zone); end

  def self.zone(); end

  def self.zone=(time_zone); end

  def self.zone_default(); end

  def self.zone_default=(zone_default); end

end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::GID
  def app(); end

  def model_id(); end

  def model_name(); end

  def params(); end

  def query=(query); end

  def set_params(params); end

  def set_path(path); end

  def set_query(query); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class URI::GID::MissingModelIdError
end

class URI::GID::MissingModelIdError
end

class URI::GID
  def self.create(app, model, params=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.validate_app(app); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

  def self.parser(); end

end

class UnboundMethod
  include ::MethodSource::SourceLocation::UnboundMethodExtensions
  include ::MethodSource::MethodExtensions
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class UploadIO
  def content_type(); end

  def initialize(filename_or_io, content_type, filename=T.unsafe(nil), opts=T.unsafe(nil)); end

  def io(); end

  def local_path(); end

  def method_missing(*args); end

  def opts(); end

  def original_filename(); end

  def respond_to?(meth, include_all=T.unsafe(nil)); end
end

class UploadIO
  def self.convert!(io, content_type, original_filename, local_path); end
end

class User
  include ::User::GeneratedAttributeMethods
  include ::User::GeneratedAssociationMethods
end

module User::GeneratedAssociationMethods
end

module User::GeneratedAssociationMethods
end

module User::GeneratedAttributeMethods
end

module User::GeneratedAttributeMethods
  extend ::Mutex_m
end

class User
  extend ::ShopifyApp::UserSessionStorage::ClassMethods
end

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end

  def weakref_alive?(); end
end

class WeakRef::RefError
end

class WeakRef::RefError
end

class WeakRef
end

module WebMock
  include ::WebMock::API
  def after_request(*args, &block); end

  def allow_net_connect!(*args, &block); end

  def disable_net_connect!(*args, &block); end

  def net_connect_allowed?(*args, &block); end

  def registered_request?(*args, &block); end

  def reset_callbacks(*args, &block); end

  def reset_webmock(*args, &block); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module WebMock::API
  def a_request(method, uri); end

  def assert_not_requested(*args, &block); end

  def assert_requested(*args, &block); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def refute_requested(*args, &block); end

  def remove_request_stub(stub); end

  def reset_executed_requests!(); end

  def stub_http_request(method, uri); end

  def stub_request(method, uri); end
end

module WebMock::API
  extend ::WebMock::API
  def self.request(method, uri); end
end

class WebMock::AssertionFailure
end

class WebMock::AssertionFailure
  def self.error_class(); end

  def self.error_class=(error_class); end

  def self.failure(message); end
end

class WebMock::BodyPattern
  include ::WebMock::RSpecMatcherDetector
  def initialize(pattern); end

  def matches?(body, content_type=T.unsafe(nil)); end

  def pattern(); end
  BODY_FORMATS = ::T.let(nil, ::T.untyped)
end

class WebMock::BodyPattern
end

class WebMock::CallbackRegistry
end

class WebMock::CallbackRegistry
  def self.add_callback(options, block); end

  def self.any_callbacks?(); end

  def self.callbacks(); end

  def self.invoke_callbacks(options, request_signature, response); end

  def self.reset(); end
end

class WebMock::Config
  include ::Singleton
  def allow(); end

  def allow=(allow); end

  def allow_localhost(); end

  def allow_localhost=(allow_localhost); end

  def allow_net_connect(); end

  def allow_net_connect=(allow_net_connect); end

  def net_http_connect_on_start(); end

  def net_http_connect_on_start=(net_http_connect_on_start); end

  def query_values_notation(); end

  def query_values_notation=(query_values_notation); end

  def show_body_diff(); end

  def show_body_diff=(show_body_diff); end

  def show_stubbing_instructions(); end

  def show_stubbing_instructions=(show_stubbing_instructions); end
end

class WebMock::Config
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class WebMock::Deprecation
end

class WebMock::Deprecation
  def self.warning(message); end
end

class WebMock::DynamicResponse
  def initialize(responder); end

  def responder(); end

  def responder=(responder); end
end

class WebMock::DynamicResponse
end

class WebMock::HashValidator
  def initialize(hash); end

  def validate_keys(*valid_keys); end
end

class WebMock::HashValidator
end

class WebMock::HeadersPattern
  def initialize(pattern); end

  def matches?(headers); end

  def pp_to_s(); end
end

class WebMock::HeadersPattern
end

class WebMock::HttpLibAdapter
end

class WebMock::HttpLibAdapter
  def self.adapter_for(lib); end
end

class WebMock::HttpLibAdapterRegistry
  include ::Singleton
  def each_adapter(&block); end

  def http_lib_adapters(); end

  def http_lib_adapters=(http_lib_adapters); end

  def register(lib, adapter); end
end

class WebMock::HttpLibAdapterRegistry
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module WebMock::HttpLibAdapters
end

class WebMock::HttpLibAdapters::NetHttpAdapter
end

WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetBufferedIO = Net::BufferedIO

WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetHTTP = Net::HTTP

class WebMock::HttpLibAdapters::NetHttpAdapter
  def self.disable!(); end

  def self.enable!(); end
end

module WebMock::HttpLibAdapters
end

module WebMock::Matchers
end

class WebMock::Matchers::AnyArgMatcher
  def ==(other); end

  def initialize(ignore); end
end

class WebMock::Matchers::AnyArgMatcher
end

class WebMock::Matchers::HashArgumentMatcher
  def ==(_actual, &block); end

  def initialize(expected); end
end

class WebMock::Matchers::HashArgumentMatcher
  def self.from_rspec_matcher(matcher); end
end

class WebMock::Matchers::HashExcludingMatcher
  def ==(actual); end
end

class WebMock::Matchers::HashExcludingMatcher
end

class WebMock::Matchers::HashIncludingMatcher
  def ==(actual); end
end

class WebMock::Matchers::HashIncludingMatcher
end

module WebMock::Matchers
end

class WebMock::MethodPattern
  def initialize(pattern); end

  def matches?(method); end
end

class WebMock::MethodPattern
end

class WebMock::NetConnectNotAllowedError
  def initialize(request_signature); end
end

class WebMock::NetConnectNotAllowedError
end

module WebMock::NetHTTPUtility
end

module WebMock::NetHTTPUtility
  def self.check_right_http_connection(); end

  def self.puts_warning_for_right_http_if_needed(); end

  def self.request_signature_from_request(net_http, request, body=T.unsafe(nil)); end

  def self.validate_headers(headers); end
end

module WebMock::RSpecMatcherDetector
  def rSpecHashExcludingMatcher?(matcher); end

  def rSpecHashIncludingMatcher?(matcher); end
end

module WebMock::RSpecMatcherDetector
end

class WebMock::RackResponse
  def body_from_rack_response(response); end

  def build_rack_env(request); end

  def evaluate(request); end

  def initialize(app); end

  def session(); end

  def session_options(); end
end

class WebMock::RackResponse
end

class WebMock::RequestBodyDiff
  def body_diff(); end

  def initialize(request_signature, request_stub); end
end

class WebMock::RequestBodyDiff
end

class WebMock::RequestExecutionVerifier
  def at_least_times_executed(); end

  def at_least_times_executed=(at_least_times_executed); end

  def at_most_times_executed(); end

  def at_most_times_executed=(at_most_times_executed); end

  def description(); end

  def does_not_match?(); end

  def expected_times_executed(); end

  def expected_times_executed=(expected_times_executed); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(request_pattern=T.unsafe(nil), expected_times_executed=T.unsafe(nil), at_least_times_executed=T.unsafe(nil), at_most_times_executed=T.unsafe(nil)); end

  def matches?(); end

  def request_pattern(); end

  def request_pattern=(request_pattern); end

  def times_executed(); end

  def times_executed=(times_executed); end
end

class WebMock::RequestExecutionVerifier
  def self.executed_requests_message(); end
end

class WebMock::RequestPattern
  def body_pattern(); end

  def headers_pattern(); end

  def initialize(method, uri, options=T.unsafe(nil)); end

  def matches?(request_signature); end

  def method_pattern(); end

  def uri_pattern(); end

  def with(options=T.unsafe(nil), &block); end
end

class WebMock::RequestPattern
end

class WebMock::RequestRegistry
  include ::Singleton
  def requested_signatures(); end

  def requested_signatures=(requested_signatures); end

  def reset!(); end

  def times_executed(request_pattern); end
end

class WebMock::RequestRegistry
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class WebMock::RequestSignature
  def ==(other); end

  def body(); end

  def body=(body); end

  def eql?(other); end

  def headers(); end

  def headers=(headers); end

  def initialize(method, uri, options=T.unsafe(nil)); end

  def json_headers?(); end

  def method(); end

  def method=(method); end

  def uri(); end

  def uri=(uri); end

  def url_encoded?(); end
end

class WebMock::RequestSignature
end

class WebMock::RequestSignatureSnippet
  def initialize(request_signature); end

  def request_signature(); end

  def request_stub(); end

  def request_stubs(); end

  def stubbing_instructions(); end
end

class WebMock::RequestSignatureSnippet
end

class WebMock::RequestStub
  def and_raise(*exceptions); end

  def and_return(*response_hashes, &block); end

  def and_timeout(); end

  def has_responses?(); end

  def initialize(method, uri); end

  def matches?(request_signature); end

  def request_pattern(); end

  def request_pattern=(request_pattern); end

  def response(); end

  def times(number); end

  def to_rack(app, options=T.unsafe(nil)); end

  def to_raise(*exceptions); end

  def to_return(*response_hashes, &block); end

  def to_timeout(); end

  def with(params=T.unsafe(nil), &block); end
end

class WebMock::RequestStub
  def self.from_request_signature(signature); end
end

class WebMock::Response
  def ==(other); end

  def body(); end

  def body=(body); end

  def evaluate(request_signature); end

  def exception(); end

  def exception=(exception); end

  def headers(); end

  def headers=(headers); end

  def initialize(options=T.unsafe(nil)); end

  def options=(options); end

  def raise_error_if_any(); end

  def should_timeout(); end

  def status(); end

  def status=(status); end
end

class WebMock::Response::InvalidBody
end

class WebMock::Response::InvalidBody
end

class WebMock::Response
end

class WebMock::ResponseFactory
end

class WebMock::ResponseFactory
  def self.response_for(options); end
end

class WebMock::ResponsesSequence
  def end?(); end

  def initialize(responses); end

  def next_response(); end

  def times_to_repeat(); end

  def times_to_repeat=(times_to_repeat); end
end

class WebMock::ResponsesSequence
end

class WebMock::StubRegistry
  include ::Singleton
  def global_stubs(); end

  def register_global_stub(&block); end

  def register_request_stub(stub); end

  def registered_request?(request_signature); end

  def remove_request_stub(stub); end

  def request_stubs(); end

  def request_stubs=(request_stubs); end

  def reset!(); end

  def response_for_request(request_signature); end
end

class WebMock::StubRegistry
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class WebMock::StubRequestSnippet
  def body_pattern(); end

  def initialize(request_stub); end

  def to_s(with_response=T.unsafe(nil)); end
end

class WebMock::StubRequestSnippet
end

class WebMock::URIAddressablePattern
  def matches?(uri); end
end

class WebMock::URIAddressablePattern
end

class WebMock::URIPattern
  include ::WebMock::RSpecMatcherDetector
  def add_query_params(query_params); end

  def initialize(pattern); end
end

class WebMock::URIPattern
end

class WebMock::URIRegexpPattern
  def matches?(uri); end
end

class WebMock::URIRegexpPattern
end

class WebMock::URIStringPattern
  def matches?(uri); end
end

class WebMock::URIStringPattern
end

module WebMock::Util
end

class WebMock::Util::HashCounter
  def each(&block); end

  def get(key); end

  def hash=(hash); end

  def put(key, num=T.unsafe(nil)); end

  def select(&block); end
end

class WebMock::Util::HashCounter
end

class WebMock::Util::HashKeysStringifier
end

class WebMock::Util::HashKeysStringifier
  def self.stringify_keys!(arg, options=T.unsafe(nil)); end
end

class WebMock::Util::Headers
end

class WebMock::Util::Headers
  def self.basic_auth_header(*credentials); end

  def self.decode_userinfo_from_header(header); end

  def self.normalize_headers(headers); end

  def self.pp_headers_string(headers); end

  def self.sorted_headers_string(headers); end
end

class WebMock::Util::JSON
end

class WebMock::Util::JSON::ParseError
end

class WebMock::Util::JSON::ParseError
end

class WebMock::Util::JSON
  def self.convert_json_to_yaml(json); end

  def self.parse(json); end

  def self.unescape(str); end
end

class WebMock::Util::QueryMapper
end

class WebMock::Util::QueryMapper
  def self.collect_query_hash(query_array, empty_accumulator, options); end

  def self.collect_query_parts(query); end

  def self.dehash(hash); end

  def self.fill_accumulator_for_dot(accumulator, key, value); end

  def self.fill_accumulator_for_flat(accumulator, key, value); end

  def self.fill_accumulator_for_flat_array(accumulator, key, value); end

  def self.fill_accumulator_for_subscript(accumulator, key, value); end

  def self.normalize_query_hash(query_hash, empty_accumulator, options); end

  def self.query_to_values(query, options=T.unsafe(nil)); end

  def self.to_query(parent, value, options=T.unsafe(nil)); end

  def self.values_to_query(new_query_values, options=T.unsafe(nil)); end
end

class WebMock::Util::URI
  ADDRESSABLE_URIS = ::T.let(nil, ::T.untyped)
  NORMALIZED_URIS = ::T.let(nil, ::T.untyped)
end

module WebMock::Util::URI::CharacterClasses
  USERINFO = ::T.let(nil, ::T.untyped)
end

module WebMock::Util::URI::CharacterClasses
end

class WebMock::Util::URI
  def self.encode_unsafe_chars_in_userinfo(userinfo); end

  def self.heuristic_parse(uri); end

  def self.is_uri_localhost?(uri); end

  def self.normalize_uri(uri); end

  def self.sort_query_values(query_values); end

  def self.strip_default_port_from_uri_string(uri_string); end

  def self.uris_encoded_and_unencoded(uris); end

  def self.uris_with_inferred_port_and_without(uris); end

  def self.uris_with_scheme_and_without(uris); end

  def self.uris_with_trailing_slash_and_without(uris); end

  def self.variations_of_uri_as_strings(uri_object, only_with_scheme: T.unsafe(nil)); end
end

class WebMock::Util::ValuesStringifier
end

class WebMock::Util::ValuesStringifier
  def self.stringify_values(value); end
end

module WebMock::Util
end

class WebMock::VersionChecker
  def check_version!(); end

  def initialize(library_name, library_version, min_patch_level, max_minor_version=T.unsafe(nil), unsupported_versions=T.unsafe(nil)); end
end

class WebMock::VersionChecker
end

module WebMock
  extend ::WebMock::API
  def self.after_request(options=T.unsafe(nil), &block); end

  def self.allow_net_connect!(options=T.unsafe(nil)); end

  def self.disable!(options=T.unsafe(nil)); end

  def self.disable_net_connect!(options=T.unsafe(nil)); end

  def self.disallow_net_connect!(options=T.unsafe(nil)); end

  def self.enable!(); end

  def self.enable_net_connect!(options=T.unsafe(nil)); end

  def self.globally_stub_request(&block); end

  def self.hide_body_diff!(); end

  def self.hide_stubbing_instructions!(); end

  def self.included(clazz); end

  def self.net_connect_allowed?(uri=T.unsafe(nil)); end

  def self.net_connect_explicit_allowed?(allowed, uri=T.unsafe(nil)); end

  def self.print_executed_requests(); end

  def self.registered_request?(request_signature); end

  def self.request(method, uri); end

  def self.reset!(); end

  def self.reset_callbacks(); end

  def self.reset_webmock(); end

  def self.show_body_diff!(); end

  def self.show_body_diff?(); end

  def self.show_stubbing_instructions!(); end

  def self.show_stubbing_instructions?(); end

  def self.version(); end
end

YAML = Psych

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
